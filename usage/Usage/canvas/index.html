<html lang="en"><HEAD>
<meta charset="utf-8" >
<meta name="viewport" content="width=device-width, initial-scale=1" >
<link rel="stylesheet" href="../../../html/www/css/magick.css">
<TITLE>Canvas Creation -- IM v6 Examples</TITLE>
<LINK REL="icon" HREF="../img_www/favicon.ico" type="image/x-icon">
<LINK REL="shortcut" HREF="../img_www/favicon.ico" type="image/x-icon">
<LINK REL="canonical" HREF="https://legacy.imagemagick.org/Usage/canvas/">
</HEAD><BODY BGCOLOR="#B0C4DE">

<H1>ImageMagick v6 Examples -- <BR>
    <IMG SRC="../img_www/space.gif" width=50 height=1>
    Canvas Creation</H1>

<DIV ALIGN=justify>

<B>Index</B>
<TABLE CELLSPACING=0>
<TR VALIGN=top><TD COLSPAN=2>
<A HREF="../index.html"
   ><IMG SRC="../img_www/granitesm_left.gif" BORDER=0 WIDTH=15 HEIGHT=15
   > ImageMagick Examples Preface and Index</A>
</TD></TR>
<TR VALIGN=top><TD><DL>

<DD><A HREF="index.html#solid"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > Solid Color Canvases</A>
    <UL>
    <LI><A HREF="index.html#solid"
        >Direct Generation</A>
    <LI><A HREF="index.html#blank"
        >Blanking Existing Images</A>
    <LI><A HREF="index.html#blank_pick"
        >Blanking Image with Picked Color</A>
    <LI><A HREF="index.html#specific"
        >Overlay a Specific Color</A>
    <LI><A HREF="index.html#other"
        >Other Canvas Techniques</A>
    </UL>
<DD><A HREF="index.html#gradient"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > Gradients of Colors</A>
    <UL>
    <LI><A HREF="index.html#gradient"
        >Gradient Image Generator</A>
    <LI><A HREF="index.html#radial-gradient"
        >Radial Gradient Generator</A>
    <LI><A HREF="index.html#gradient_transparent"
        >Gradients with Transparency</A>
    <LI><A HREF="index.html#gradient_histogram"
        >Histogram Adjusted Gradients</A>
    <LI><A HREF="index.html#gradient_functions"
        >Evaluated Gradients</A>
    <LI><A HREF="index.html#gradient_distort"
        >Distorted Gradients</A>
    <LI><A HREF="index.html#gradient_compose"
        >Gradients by Composition</A>
    <LI><A HREF="index.html#gradient_colorspace"
        >Gradients in other Colorspaces</A>
    <LI><A HREF="index.html#gradient_resize"
        >Resized Image Gradients</A>
    <LI><A HREF="index.html#gradient_interpolate"
        >Interpolated Lookup Gradients</A>
    <LI><A HREF="index.html#gradient_fx"
        >Roll your own Gradient</A>
    <LI><A HREF="index.html#gradient_complex"
        >More Complex DIY Gradients</A>
    <LI><A HREF="index.html#gradient_complex_hues"
        >DIY Gradients and Hues</A>
    <LI><A HREF="index.html#perfect_gradients"
        >Generating the Perfect Gradient</A>
    </UL>
<DD><A HREF="index.html#sparse-color"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > Sparse Points of Color</A>
    <UL>
    <LI><A HREF="index.html#barycentric"
        ><B>Barycentric</B> - The Triangle Gradient</A>
        <UL><FONT SIZE=-1>
        <LI><A HREF="index.html#two_color_gradients"
            >Two Color Gradients</A>
        <LI><A HREF="index.html#diagonal_gradients"
            >Diagonal Gradients</A>
        <LI><A HREF="index.html#two_point_gradients"
            >Barycentric and Two Color Gradients</A>
         </FONT></UL>
    <LI><A HREF="index.html#bilinear"
        ><B>Bilinear</B> - 4 Point Gradient</A>
    <LI><A HREF="index.html#voronoi"
        ><B>Voronoi</B> - Nearest Color</A>
    <LI><A HREF="index.html#shepards"
        ><B>Shepards</B> - Spotlights of Color</A>
    <LI><A HREF="index.html#inverse"
        ><B>Inverse</B> - Sharp Points of Color</A>
    <LI><A HREF="index.html#shepards_power"
        >Shepards Power Factor</A>
    <LI><A HREF="index.html#sparse_summery"
        >Summery of Sparse Color Methods</A>
    <LI><A HREF="index.html#sparse_channel"
        >Channel Setting and Sparse Color</A>
    <LI><A HREF="index.html#sparse_fill"
        >Sparse Color as a Fill Operator</A>
    <LI><A HREF="index.html#sparse_blur"
        >Sparse Color Shepards, a Blur Alternative</A>
    <LI><A HREF="index.html#shepards_leakage"
        >Shepards Method 'Leaks'</A>
    </UL>

</DL></TD><TD><DL>

<DD><A HREF="index.html#plasma"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > Plasma Images</A>
    <UL>
    <LI><A HREF="index.html#plasma_gradients"
        >Plasma Gradients</A>
    <LI><A HREF="index.html#plasma_fractal"
        >Fractal Plasma</A>
    <LI><A HREF="index.html#plasma_greyscale"
        >Gray-scale Plasma</A>
    <LI><A HREF="index.html#plasma_seeded"
        >Seeded Plasma</A>
    <LI><A HREF="index.html#plasma_problems"
        >Problems using Plasma</A>
    </UL>
&nbsp;
<DD><A HREF="index.html#random"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > Random Images</A>
    <UL>
    <LI><A HREF="index.html#random_noise"
        >Raw Random Noise</A> <FONT SIZE=-1>- pure random</FONT>
    <LI><A HREF="index.html#plasma_gradients"
        >Plasma Gradients</A>
    <LI><A HREF="index.html#random_specks"
        >Random Speckles</A>  <FONT SIZE=-1>- pixel dust</FONT>
    <LI><A HREF="index.html#random_blur"
        >Blurred Random Images</A> <FONT SIZE=-1>- random blobs</FONT>
    <LI><A HREF="index.html#granularity"
        >Random Granularity</A> <FONT SIZE=-1>- order in the chaos</FONT>
    <LI><A HREF="index.html#random_flux"
        >Random Flux</A> <FONT SIZE=-1>- animated randomness</FONT>
    <LI><A HREF="index.html#random_ripples"
        >Random Ripples</A> <FONT SIZE=-1>- dispersion maps</FONT>
    </UL>
&nbsp;
<DD><A HREF="index.html#tile"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > Tiled Canvases</A>
    <UL>
    <LI><A HREF="index.html#tile"
        >Tiled Canvas</A>
    <LI><A HREF="index.html#tile-offset"
        >Offset Tiling Canvases</A>
    <LI><A HREF="index.html#tile_memory"
        >Tiling with an Image In Memory</A>
    <LI><A HREF="index.html#pattern"
        >Modifying Built-in Patterns</A>
    <LI><A HREF="index.html#tile_mod"
        >Modifying Tile Images</A>
    <LI><A HREF="index.html#tile_gen"
        >Generating Tile Images</A>
    <LI><A HREF="index.html#tile_random"
        >Random Noise Tiles</A>
    <LI><A HREF="index.html#tile_hex"
        >Hexagonal Tiling</A>
    <LI><A HREF="index.html#tile_triple_hex"
        >Triple Hex Tiling</A>
    <LI><A HREF="index.html#tile_diagonal"
        >Diagonal Mirror Tiling</A>
    </UL>
</DL>
</TD></TR></TABLE></P>

Canvases are used by ImageMagick both as a starting image for drawing on,
backgrounds to overlay images with transparent areas, or even just as part of
general image processing.  They can be a solid color, or a range of colors,
or even a tile of a smaller image.  Here we look at just some of the
methods that can be used to generate a whole range of canvas images.  </P>

<HR><!-- ---------------------------------------------------------------- -->

<A NAME="solid"></A>
<H2>Solid Color Canvases</H2>

<H3>Direct Generation</H3>

Generating a canvas of a specific color and size is very simple to do.  You
just specify "<CODE><A HREF="../../../html/www/command-line-options.html#size" >-size</A></CODE>"
(defaulting to "<CODE>1x1</CODE>" is no size given), and then use
"<CODE>canvas:</CODE>" to generate an canvas of the color given.  If no color
is specified a '<CODE>white</CODE>' canvas is generated. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>

For example... here I generate a '<CODE>khaki</CODE>' colors canvas.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 100x100 canvas:khaki  canvas_khaki.gif
</CODE></PRE></TD></TR></TABLE>
</TD><TD>
  <A HREF="canvas_khaki.gif"
     ><IMG SRC="canvas_khaki.gif"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR>
</TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>

More commonly a short hand (and more traditional) format of
"<CODE>xc:</CODE>" (which meant "X Constant Image"). This is generally what
I use.  For example here is an image using the X window color of
'<CODE>wheat</CODE>'.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 100x100 xc:wheat  canvas_wheat.gif
</CODE></PRE></TD></TR></TABLE>
</TD><TD>
  <A HREF="canvas_wheat.gif"
     ><IMG SRC="canvas_wheat.gif"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR>
</TABLE></P>


<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>

Using some fancy <A HREF="../files/index.html#read_mods" >Image Read Modifiers</A>
we can just specify a solid color canvas image as a single argument. This
technique means you can specify a 'xc' canvas image of a specific size and
color as a single 'input image' argument to many ImageMagick Scripts. </P>

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert 'xc:Salmon[100x100!]'  canvas_salmon.gif
</CODE></PRE></TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/warning.gif"  WIDTH=28 HEIGHT=28
    ><IMG SRC="../img_www/space.gif"   WIDTH=12 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  The '!' is needed as the numbers are resize values, otherwise you
  not get the size requested if it isn't square.
</I></FONT></TD></TR></TABLE>

</TD><TD>
  <A HREF="canvas_salmon.gif"
     ><IMG SRC="canvas_salmon.gif"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR>
</TABLE></P>


<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>

If you have already created a canvas, but need one in a different color you
can replace that color using the "<CODE><A HREF="../../../html/www/command-line-options.html#opaque"
>-opaque</A></CODE>" operator.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert canvas_khaki.gif -fill tomato -opaque khaki canvas_tomato.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="canvas_tomato.gif"
     ><IMG SRC="canvas_tomato.gif"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR>
</TABLE></P>

You can even grab a single pixel from an existing image, and expand it to the
canvas size you want.  We use "<CODE><A HREF="../../../html/www/command-line-options.html#scale"
>-scale</A></CODE>" for a simple and fast resizing of the single pixel. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>

Here we grab a rose color from the built-in "<CODE>rose:</CODE>" image.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rose:  -crop 1x1+40+30 +repage -scale 100x100\! canvas_rose_red.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="canvas_rose_red.gif"
     ><IMG SRC="canvas_rose_red.gif"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR>
</TABLE></P>


<A NAME="sized"></A>  <!-- check before removing -->
<A NAME="blank"></A>
<H3>Create Image of same size</H3>

One most basic techniques, when using ImageMagick, is to generate a canvas of
the same size as some existing image.  This can be done by converting that
existing image into the canvas needed, but preserving the image's original
size.  </P>

Generally it is not just the images size that needs to be preserved, but all
the images meta-data as well.  That in things such as labels, comments, color
profiles, time delays, as well as the save compression and depth.  This
meta-data can be important if you want to annotate such information onto the
newly blanked canvas, or you plan to overlay the original image onto the new
canvas, and need to preserve that information. </P>

Naturally IM provides a large number of ways to do this, usually as
a side-effect of using various image operations. Only a few are very obvious
about there use in clearing an image to a solid color. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>

To the left is a test image... Don't worry above how I actually generated this
image, it is not important for the exercise.  I did design it to contain a
range of colors, transparencies and other features, specifically to give IM a
good workout when used. </P>

<I>If you are really interested in the commands used to generate this image
you can look at the special script, "<A HREF="../scripts/generate_test"
>generate_test</A>", I use to create it.</I> </P>

</TD><TD>
  <A HREF="../images/test.png"
     ><IMG SRC="../images/test.png"       WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR>
</TABLE></P>

<A NAME="specific"></A>
<H3>Overlay a Specific Color</H3>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>

As of IM v6.4.2-1 you can  use the "<CODE><A
HREF="../../../html/www/command-line-options.html#level_colors" >+level-colors</A></CODE>" with
a single color and no comma's, to set all the colors.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert test.png  -alpha Opaque +level-colors Sienna  color_levelc.gif
</CODE></PRE></TD></TR></TABLE>
</TD><TD>
  <A HREF="color_levelc.gif"
     ><IMG SRC="color_levelc.gif"       WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Note the use of the "<CODE><A HREF="../../../html/www/command-line-options.html#alpha"
>-alpha</A></CODE>" operator to set the transparency to something useful
before (or after) the color has been added.  Altrunativally you could use
"<CODE>-channel All</CODE>" to ensure the transparency channel is also set by
the color resetting  operation. </P>

Another older technique is to use "<CODE><A HREF="../../../html/www/command-line-options.html#colorize"
>-colorize</A></CODE>" to overlay the fill color but with a fully opaque
value. However before IM v6.7.9 it did not change the the original images
alpha channel, so it is a good idea if to disable the alpha channel first,
using "<CODE><A HREF="../../../html/www/command-line-options.html#alpha" >-alpha</A> <A
HREF="../masking/index.html#alpha_off" >Off</A></CODE>", or make it opaque with
"<CODE><A HREF="../../../html/www/command-line-options.html#alpha" >-alpha</A> <A
HREF="../masking/index.html#alpha_off" >Opaque</A></CODE>" even though you would get the
same result without it.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert test.png -alpha off -fill Chocolate -colorize 100%  
color_colorize.gif
</CODE></PRE></TD></TR></TABLE> </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  Note that  "<CODE><A HREF="../../../html/www/command-line-options.html#alpha" >-alpha</A> <A
  HREF="../masking/index.html#alpha_off" >Off</A></CODE>" (or the older equivelent
  "<CODE><A HREF="../../../html/www/command-line-options.html#matte" >+matte</A></CODE>") only disables
  the alpha channel. if you turn it <A HREF="../masking/index.html#alpha_on" >On</A>
  again afterwards, the original alpha channel (which was preserved) will be
  restored. Before IM v6.7.9 alpha was preserved when using "<CODE><A
  HREF="../../../html/www/command-line-options.html#colorize" >-colorize</A></CODE>".
</I></FONT></TD></TR></TABLE>

</TD><TD>
  <A HREF="color_colorize.gif"
     ><IMG SRC="color_colorize.gif"       WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR>
</TABLE></P>


<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>

As of IM v6.4.3-0 you can use the "<CODE><A
HREF="../../../html/www/command-line-options.html#sparse-color" >-sparse-color</A></CODE>" operator to
set some point to the color wanted, and have it spread to cover the whole
image, using just about any coloring method it provides (see <A
HREF="index.html#sparse-color" >Sparse Points of Color</A> below).

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert test.png  -alpha Off \
          -sparse-color Voronoi '0,0 Peru' color_sparse.gif
</CODE></PRE></TD></TR></TABLE>
</TD><TD>
  <A HREF="color_sparse.gif"
     ><IMG SRC="color_sparse.gif"       WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR>
</TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>

A more general way is to use "<CODE><A HREF="../../../html/www/command-line-options.html#draw"
>-draw</A></CODE>" to directly reset all the colors in the current image to
the current "<CODE><A HREF="../../../html/www/command-line-options.html#fill" >-fill</A></CODE>" color.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert test.png -fill Tan -draw 'color 0,0 reset' color_reset.gif
</CODE></PRE></TD></TR></TABLE>
</TD><TD>
  <A HREF="color_reset.gif"
     ><IMG SRC="color_reset.gif"       WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR>
</TABLE></P>

This was the recommended method in ImageMagick version 5. </P>

<BR>

The major complaint about all the above 'simple' methods is that none simply
resets the image to the current "<CODE><A HREF="../../../html/www/command-line-options.html#background"
>-background</A></CODE>" color.  The next set methods make use of <A
HREF="../compose/index.html" >Alpha Composition</A> to force various operators to
replace the image with the desired color.  These multi-image techniques work
with operators that use "<CODE><A HREF="../../../html/www/command-line-options.html#compose"
>-compose</A></CODE>". </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>

For example you can use the "<CODE><A HREF="../../../html/www/command-line-options.html#flatten"
>-flatten</A></CODE>" (See <A HREF="../layers/index.html#flatten_bgnd" >Flatten onto
Background</A> example), which creates a canvas using the "<CODE><A
HREF="../../../html/www/command-line-options.html#background" >-background</A></CODE>" color.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert test.png   -background Wheat \
            -compose Dst   -flatten   color_flatten.gif
</CODE></PRE></TD></TR></TABLE>
</TD><TD>
  <A HREF="color_flatten.gif"
     ><IMG SRC="color_flatten.gif"       WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR>
</TABLE></P>

The above as uses the '<CODE><A HREF="../compose/index.html#Dst" >Dst</A></CODE>'
compose method to only read the background canvas, and ignore the pixel colors
of the original image. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

If you are just wanting to grab the original images meta-data (such as the 
comment or label data), but replace the image itself with a specific color and
size of canvas image, then "<CODE><A HREF="../../../html/www/command-line-options.html#extent"
>-extent</A></CODE>" operator (See <A HREF="../crop/index.html#extent" >Extent, Direct
Image Size Adjustment</A>) may be the best solution. </P>

Again the <CODE><A HREF="../compose/index.html#Dst" >Dst</A></CODE>' compose method is
used to have it ignore the original image pixel data, so as to onlyuse the
"<CODE><A HREF="../../../html/www/command-line-options.html#background" >-background</A></CODE>" color.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert test.png   -background LemonChiffon \
            -compose Dst   -extent 100x100   color_extent.gif
</CODE></PRE></TD></TR></TABLE>
</TD><TD>
  <A HREF="color_extent.gif"
     ><IMG SRC="color_extent.gif"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR>
</TABLE></P>


<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>

Or you can use "<CODE><A HREF="../../../html/www/command-line-options.html#border" >-border</A></CODE>"
(See <A HREF="../crop/index.html#border" >Adding a Border</A>), using the "<CODE><A
HREF="../../../html/www/command-line-options.html#bordercolor" >-bordercolor</A></CODE>" as the color
source.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert test.png   -bordercolor Khaki \
            -compose Dst   -border 0   color_border.gif
</CODE></PRE></TD></TR></TABLE>
</TD><TD>
  <A HREF="color_border.gif"
     ><IMG SRC="color_border.gif"       WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR>
</TABLE></P>

This last method has the added advantage of also letting you slightly enlarge
the image canvas, relative to the original images size. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/warning.gif"  WIDTH=28 HEIGHT=28
    ><IMG SRC="../img_www/space.gif"   WIDTH=12 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  The "<CODE><A HREF="../../../html/www/command-line-options.html#border" >-border</A></CODE>" method
  of generating canvases will not work with versions of IM before version
  6.1.4.  Before this the background generated by the "<CODE><A
  HREF="../../../html/www/command-line-options.html#border" >-border</A></CODE>" operator was not a
  simple solid color, but a black canvas surrounded by the border color.  Not
  very useful.
</I></FONT></TD></TR></TABLE></P>


<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>

A more flexible (but very slow) method of canvas generation was provided by
the "<CODE><A HREF="http://legacy.imagemagick.org/Usage/transform/#fx" >FX, DIY Operator</A></CODE>" operator.
You will also need to turn off the input image's transparency channel as by
default "<CODE><A HREF="../../../html/www/command-line-options.html#fx" >-fx</A></CODE>" will not touch
the transparency channel.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert test.png -alpha off -fx Gold  color_fx_constant.gif
</CODE></PRE></TD></TR></TABLE>
</TD><TD>
  <A HREF="color_fx_constant.gif"
     ><IMG SRC="color_fx_constant.gif"       WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR>
</TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>

The "<CODE><A HREF="../../../html/www/command-line-options.html#fx" >-fx</A></CODE>" operator will even
let you do a little color mathematics. For example how about a 70% darker gold
color...

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert test.png -alpha off -fx "Gold*.7"  color_fx_math.gif
</CODE></PRE></TD></TR></TABLE>
</TD><TD>
  <A HREF="color_fx_math.gif"
     ><IMG SRC="color_fx_math.gif"       WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR>
</TABLE></P>


All the above methods cannot only fill using a fully-opaque color, but can
also use semi-transparent colors.  However it is a good idea to ensure the
image you have a transparency channel before hand. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>

Here for example we create a canvas with a semi-transparent red.  However when
overlaid on the web pages 'bluish' background we get an off purple-pink color.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert test.png -alpha set -fill '#FF000040' -draw 'color 0,0 reset' \
            color_semitrans.png
</CODE></PRE></TD></TR></TABLE>
</TD><TD>
  <A HREF="color_semitrans.png"
     ><IMG SRC="color_semitrans.png"       WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR>
</TABLE></P>

Also note that when using "<CODE><A HREF="../../../html/www/command-line-options.html#fx"
>-fx</A></CODE>" operator with transparency, you will need to set "<CODE><A
HREF="../../../html/www/command-line-options.html#channel" >-channel</A></CODE>" to modify all four
'<CODE>RGBA</CODE>' color channels. </P>

<A NAME="blank_pick"></A>
<H3>Blanking Image with Picked Color</H3>

Blanking images using a color from the original image is also posible,
though can be tricky. It is an useful technique when you want to use
a specific pixel as a 'background color'. For example pixel 0,0 is a common
choice.</P>

<A HREF="../images/rose.png"
   ><IMG SRC="../images/rose.png"       WIDTH=70 HEIGHT=46
         ALIGN=right VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>

In the following examples I will select colors from various pixels from the
built in rose image (shown left), as I blank the image. </P>


The most obvious (though slow) method is to simply use the "<CODE><A
HREF="http://legacy.imagemagick.org/Usage/transform/#fx" >FX, DIY Operator</A></CODE>" to select the pixel to
use color blanking.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rose: -fx 'p{0,0}'  color_pick_fx.png
</CODE></PRE></TD></TR></TABLE>
</TD><TD>
  <A HREF="color_pick_fx.png"
     ><IMG SRC="color_pick_fx.png"       WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

However this can be speed up by only selecting the pixel once.  This can be done
by using the fx formula as an argument for <A HREF="index.html#sparse-color" >Sparse
Color</A>. It may seem less simple, but it is much faster.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rose: -sparse-color voronoi '0,0 %[pixel:p{40,30}]' 
color_pick_sparse.png
</CODE></PRE></TD></TR></TABLE>
</TD><TD>
  <A HREF="color_pick_sparse.png"
     ><IMG SRC="color_pick_sparse.png"       WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Another more complex method is to crop out that one pixel and tile it across
the image, using techniques described later in detail in <A
HREF="index.html#tile_memory" >Tiling with an Image already In Memory</A>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rose: \( +clone -crop 1x1+64+22 -write MPR:pixel +delete \) \
          -fill mpr:pixel  -draw 'color 0,0 reset' \
          color_pick_draw.png
</CODE></PRE></TD></TR></TABLE>
</TD><TD>
  <A HREF="color_pick_draw.png"
     ><IMG SRC="color_pick_draw.png"       WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rose: -set option:distort:viewport '%wx%h+0+0' \
          -crop 1x1+10+25 +repage     -distort SRT 0 \
          color_pick_distort.png
</CODE></PRE></TD></TR></TABLE>
</TD><TD>
  <A HREF="color_pick_distort.png"
     ><IMG SRC="color_pick_distort.png"       WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>


<BR>

<A NAME="other"></A>
<H3>Other Canvas Techniques</H3>

Their lots of other ways of generating canvases of very specific colors, but
they are rather obtuse. As such without some heavy commenting, it may not be
obvious what you are actually doing when you look at your IM script months or
years later. </P>

I don't recommend these techniques, but are useful to know if you are using
older less flexible versions of IM. </P>

<A NAME="black">
<H4>Black Canvas</H4>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>

Traditionally you can create a black canvas by using "<CODE><A
HREF="../../../html/www/command-line-options.html#threshold" >-threshold</A></CODE>", and then turn off
the transparency channel.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert  test.png -threshold 100% -alpha off  black_threshold.png
</CODE></PRE></TD></TR></TABLE>
</TD><TD>
  <A HREF="black_threshold.png"
     ><IMG SRC="black_threshold.png"       WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>

Providing the "<CODE><A HREF="../../../html/www/command-line-options.html#level" >-level</A></CODE>"
operator with the same argument for both 'black' and 'white' points will have
the same effect.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert  test.png -level 100%,100% -alpha off  black_level.png
</CODE></PRE></TD></TR></TABLE>
</TD><TD>
  <A HREF="black_level.png"
     ><IMG SRC="black_level.png"       WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>

The "<CODE><A HREF="../../../html/www/command-line-options.html#fx" >-fx</A></CODE>" operator
provides a more obvious way of creating a black canvas by clearing all the
pixels to zero.  However you will also need to reset the alpha channel to make
it fully opaque.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert test.png  -fx 0 -alpha off   black_fx.png
</CODE></PRE></TD></TR></TABLE>
</TD><TD>
  <A HREF="black_fx.png"
     ><IMG SRC="black_fx.png"       WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>

However the "<CODE><A HREF="../../../html/www/command-line-options.html#evaluate" 
>-evaluate</A></CODE>"
version of this should be faster, particularly on larger images.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert  test.png  -evaluate set 0  -alpha off  black_evaluate.png
</CODE></PRE></TD></TR></TABLE>
</TD><TD>
  <A HREF="black_evaluate.png"
     ><IMG SRC="black_evaluate.png"       WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>

You can also mis-use the "<CODE><A HREF="../../../html/www/command-line-options.html#gamma"
>-gamma</A></CODE>" operator to make an image all black.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert  test.png  -gamma 0  -alpha off  black_gamma.png
</CODE></PRE></TD></TR></TABLE>
</TD><TD>
  <A HREF="black_gamma.png"
     ><IMG SRC="black_gamma.png"       WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>

A less obvious way is to 'posterize' the image with too few color levels,
resulting in only one color being used, black.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert  test.png  -posterize 1 -alpha off black_posterize.png
</CODE></PRE></TD></TR></TABLE>
</TD><TD>
  <A HREF="black_posterize.png"
     ><IMG SRC="black_posterize.png"       WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>

You can ensure the image is fully transparent then '<CODE>extract</CODE>' the
images mask, using the <A HREF="../basics/index.html#alpha" >Alpha Operator</A>

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert test.png  -alpha transparent -alpha extract  black_alpha.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="black_alpha.png"
     ><IMG SRC="black_alpha.png"       WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>


<A NAME="white">
<H4>White Canvas</H4>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>

The traditional way is again using "<CODE><A 
HREF="../../../html/www/command-line-options.html#threshold"
>-threshold</A></CODE>".  The value however must be a negative number, just to
be sure that all colors will be mapped to white, in all versions of IM.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert  test.png  -threshold -1 -alpha off   white_threshold.png
</CODE></PRE></TD></TR></TABLE>
</TD><TD>
  <A HREF="white_threshold.png"
     ><IMG SRC="white_threshold.png"       WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>

Providing the "<CODE><A HREF="../../../html/www/command-line-options.html#level" >-level</A></CODE>"
operator with same argument for both 'black' and 'white' points will have the
same effect.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert  test.png -level -1,-1 -alpha off  white_level.png
</CODE></PRE></TD></TR></TABLE>
</TD><TD>
  <A HREF="white_level.png"
     ><IMG SRC="white_level.png"       WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>


<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>

You can of course set the pixel values directly using the "<CODE><A
HREF="../../../html/www/command-line-options.html#fx" >-fx</A></CODE>" operator.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert test.png -fx 1.0 -alpha off  white_fx.png
</CODE></PRE></TD></TR></TABLE>
</TD><TD>
  <A HREF="white_fx.png"
     ><IMG SRC="white_fx.png"       WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>

However the "<CODE><A HREF="../../../html/www/command-line-options.html#evaluate" 
>-evaluate</A></CODE>"
version of this should be faster, particularly on larger images.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert  test.png  -evaluate set 100%  -alpha off  white_evaluate.png
</CODE></PRE></TD></TR></TABLE>
</TD><TD>
  <A HREF="white_evaluate.png"
     ><IMG SRC="white_evaluate.png"       WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>

Or negate some other black canvas generation method.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert  test.png -posterize 1 -alpha off -negate  white_posterize.png
</CODE></PRE></TD></TR></TABLE>
</TD><TD>
  <A HREF="white_posterize.png"
     ><IMG SRC="white_posterize.png"       WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>

You can ensure the image is fully opaque (no transparency) then
'<CODE>extract</CODE>' the images mask, using the <A HREF="../basics/index.html#alpha"
>Alpha Operator</A>

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert test.png  -alpha opaque -alpha extract  white_alpha.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="white_alpha.png"
     ><IMG SRC="white_alpha.png"       WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>


<A NAME="transparent">
<H4>Transparent Canvas</H4>

Probably the most important canvas you want to generate from an existing image
is a transparent canvas.   You can then draw and add things to this canvas,
get it the way you want it, the overlay it onto the original image. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>

The fastest and easiest way is to just get IM to directly clear the image to
transparency, using the "<CODE><A HREF="../../../html/www/command-line-options.html#alpha"
>-alpha</A> transparent</CODE>" operator (added IM v6.4.3-7).

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert test.png  -alpha transparent trans_alpha.png
</CODE></PRE></TD></TR></TABLE></P>

However as this is a very recent addition it is probably not widely available
yet. </P>

</TD><TD>
  <A HREF="trans_alpha.png"
     ><IMG SRC="trans_alpha.png"       WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>

We can make a fully-transparent 'black' canvas using the '<A
HREF="../compose/index.html#clear" >Clear</A>'  alpha composition operator, with any
overlay image (a single pixel "<CODE>null:</CODE>" in this case) as it will be
ignored.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert test.png  null: -alpha set -compose Clear -composite -compose Over \
          trans_compose.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="trans_compose.png"
     ><IMG SRC="trans_compose.png"       WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>

Here we use the "<CODE>-draw matte</CODE>" operator to replace the matte
(transparency) channel value with the transparency value of the current
"<CODE><A HREF="../../../html/www/command-line-options.html#fill" >-fill</A></CODE>" color setting.  In
this case make it fully-transparent.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert test.png -alpha set -fill none  -draw 'matte 0,0 reset' 
color_matte.png
</CODE></PRE></TD></TR></TABLE>
</TD><TD>
  <A HREF="color_matte.png"
     ><IMG SRC="color_matte.png"       WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>


<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>

We can also do this more directly with the "<CODE><A
HREF="../../../html/www/command-line-options.html#fx" >-fx</A></CODE>" operator.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert test.png -alpha set -channel A -fx 0 +channel  trans_fx.png
</CODE></PRE></TD></TR></TABLE>
</TD><TD>
  <A HREF="trans_fx.png"
     ><IMG SRC="trans_fx.png"       WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>

Naturally the "<CODE><A HREF="../../../html/www/command-line-options.html#evaluate"
>-evaluate</A></CODE>" version of this should be faster, particularly on
larger images.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert test.png  -alpha set -channel A -evaluate set 0 +channel \
          trans_evaluate.png
</CODE></PRE></TD></TR></TABLE>
</TD><TD>
  <A HREF="trans_evaluate.png"
     ><IMG SRC="trans_evaluate.png"       WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>

Another way to just make the image fully transparent is to use "<CODE><A
HREF="../../../html/www/command-line-options.html#threshold" >-threshold</A></CODE>"  but again
limiting its effects to just the transparency channel.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert test.png -channel A -threshold -1 +channel trans_threshold.png
</CODE></PRE></TD></TR></TABLE>

</TD><TD>
  <A HREF="trans_threshold.png"
     ><IMG SRC="trans_threshold.png"       WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Actually in this case we are mathematically dealing with a 'matte' channel,
using threshold to set it to the maximum value, rather than zero as we did
with the "<CODE><A HREF="../../../html/www/command-line-options.html#fx" >-fx</A></CODE>" operator.
This is why a '<CODE>-1</CODE>' was used in the above, rather than something
like <CODE>101%</CODE>'. </P>

In many of the above image results, the original RGB colors of the original
image are still present, they have just been made transparent. </P>

For example, here we read in one of the above images and ask IM to turn off
the matte/alpha channel in the image so as to make the colors visible again.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert  trans_fx.png -alpha off  trans_fx_alpha_off.jpg
</CODE></PRE></TD></TR></TABLE></P>

Note however that not all image file formats and very few image operations
will preserve the partially-transparent RGB colors that are still present in
the  resulting image. </P>

</TD><TD>
  <A HREF="trans_fx_alpha_off.jpg"
     ><IMG SRC="trans_fx_alpha_off.jpg"       WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR>
</TD></TR></TABLE></P>

As mentioned before, and worth repeating, many of the above methods rely on an
image already having a matte channel. If it doesn't, add one using the
"<CODE><A HREF="../../../html/www/command-line-options.html#alpha" >-alpha</A> <A
HREF="../masking/index.html#alpha_on" >On</A></CODE>", but in that case you may as well
just use the "<CODE><A HREF="../../../html/www/command-line-options.html#alpha" >-alpha</A>
Transparent</CODE>" operator.  See the examples on <A HREF="../masking/index.html#alpha"
>Controlling Image Transparency</A>.  </P>


<A NAME="color_misc">
<H4>Miscellaneous Canvas Coloring</H4>

Other than using a specific color, only the "<CODE><A
HREF="../../../html/www/command-line-options.html#gamma" >-gamma</A></CODE>" operator is truly
flexible enough to  generate a canvas of any primary/secondary color.  You
basically use <CODE>0</CODE> to zero out a channel, and <CODE>-1</CODE> to
maximize a channel values.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>

</P>

For example here I generate a yellow canvas...

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert  test.png  -gamma -1,-1,0  -alpha off  yellow_gamma.png
</CODE></PRE></TD></TR></TABLE>
</TD><TD>
  <A HREF="yellow_gamma.png"
     ><IMG SRC="yellow_gamma.png"       WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>

As of IM v6.4.2 you can also use the "<CODE><A HREF="../../../html/www/command-line-options.html#level"
>+level</A></CODE>" operator to set a specific grey level for all the color
channels.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert  test.png  +level 40%,40%  -alpha off  grey_level.png
</CODE></PRE></TD></TR></TABLE>
</TD><TD>
  <A HREF="grey_level.png"
     ><IMG SRC="grey_level.png"       WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>


<HR><!-- ---------------------------------------------------------------- -->

<A NAME="gradient"></A>
<H2>Gradients of Color</H2>

As you saw above you can create canvases of solid colors easy enough.  But
sometimes you want something more interesting. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>

One very useful image creation operators is "<CODE>gradient:</CODE>".
For example...

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert  -size 100x100 gradient:  gradient.jpg
</CODE></PRE></TD></TR></TABLE>
</TD><TD>
  <A HREF="gradient.jpg"
     ><IMG SRC="gradient.jpg"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

As you can see by default "<CODE>gradient:</CODE>" will create an image with
white at the top, and black at the bottom, and a smooth shading of grey across
the height of the image. </P>

But it does not have to be only a grey-scale gradient, you can also generate
a gradient of different colors by either specifying one color, or both.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 100x100  gradient:blue              gradient_range1.jpg
  convert -size 100x100  gradient:yellow            gradient_range2.jpg
  convert -size 100x100  gradient:green-yellow      gradient_range3.jpg
  convert -size 100x100  gradient:red-blue          gradient_range4.jpg
  convert -size 100x100  gradient:tomato-steelblue  gradient_range5.jpg
</CODE></PRE></TD></TR></TABLE>
  <A HREF="gradient_range1.jpg"
     ><IMG SRC="gradient_range1.jpg"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="gradient_range2.jpg"
     ><IMG SRC="gradient_range2.jpg"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="gradient_range3.jpg"
     ><IMG SRC="gradient_range3.jpg"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="gradient_range4.jpg"
     ><IMG SRC="gradient_range4.jpg"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="gradient_range5.jpg"
     ><IMG SRC="gradient_range5.jpg"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

Notice that when given a single color the second color will be either
'<CODE>white</CODE>' or '<CODE>black</CODE>', which ever produces the largest
color distance from the given color.  As such '<CODE>blue</CODE>' produces
a '<CODE>blue-white</CODE>' gradient, while '<CODE>yellow</CODE>' generated
a '<CODE>yellow-black</CODE>' gradient. </P>

The '<CODE>red-blue</CODE>' gradient shows a much darker band of purple colors
in the middle.  This darkening is caused by the darker non-linear sRGB
colorspace being used, especially with strong primary colors.  See <A
HREF="../color_basics/index.html#processing" >Processing Real Images</A> for more
details. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/expert.gif"   WIDTH=23 HEIGHT=26
    ><IMG SRC="../img_www/space.gif"   WIDTH=17 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  "<CODE>gradient:</CODE>" currently only understands sRGB <A
  HREF="../color_basics/index.html#colorspace" >Color Space</A> color representations.
  As such you can not use it to generate a brighter more correct 'purple'
  gradient using '<CODE>red-blue</CODE>' colors in a linear LAB colorspace.
  </P>

  It also means you can not generate multi-color 'rainbow' gradients using
  HSV colorspace. </P>

  However you can 'fudge' such gradients relatively simply.  See <A
  HREF="index.html#gradient_colorspace" >Gradients in other Colorspaces</A> below.

</I></FONT></TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  Gradients cannot currently be specified at other angles or involving
  more than two colors.  However as this ability is in integral part of SVG
  gradients, this situation will likely change, with a major improvement in
  gradient options.
</I></FONT></TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>
Some particularly nice gradients include...

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 10x120  gradient:snow-navy          gradient_ice-sea.jpg
  convert -size 10x120  gradient:gold-firebrick     gradient_burnished.jpg
  convert -size 10x120  gradient:yellow-limegreen   gradient_grassland.jpg
  convert -size 10x120  gradient:khaki-tomato       gradient_sunset.jpg
  convert -size 10x120  gradient:darkcyan-snow      gradient_snow_scape.jpg
</CODE></PRE></TD></TR></TABLE></TD><TD><NOBR>&nbsp;
  <A HREF="gradient_ice-sea.jpg"
     ><IMG SRC="gradient_ice-sea.jpg"         WIDTH=10 HEIGHT=120
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="gradient_burnished.jpg"
     ><IMG SRC="gradient_burnished.jpg"       WIDTH=10 HEIGHT=120
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="gradient_grassland.jpg"
     ><IMG SRC="gradient_grassland.jpg"       WIDTH=10 HEIGHT=120
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="gradient_sunset.jpg"
     ><IMG SRC="gradient_sunset.jpg"          WIDTH=10 HEIGHT=120
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="gradient_snow_scape.jpg"
     ><IMG SRC="gradient_snow_scape.jpg"      WIDTH=10 HEIGHT=120
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=1 ALT="[IM Output]"></A>
</NOBR></TD></TR></TABLE></P>

<A NAME="gradient_perfect"></A>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/warning.gif"  WIDTH=28 HEIGHT=28
    ><IMG SRC="../img_www/space.gif"   WIDTH=12 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  As of IM v6.3.1 the algorithm used to generate gradients now produce
  a horizontally uniform colors, such that all the pixels of each row in an
  image being assigned the same color. That is one color per row. </P>

  Before this version the "<CODE>gradient:</CODE>" operator worked by ignoring
  the width of the image, and just assigning the next increment of color,
  going row-by-row from top-left corner to the bottom-right of the image. </P>

  As a result the gradient was a predominately vertical gradient, just as it
  is now, but not a perfect one.  Usually this fact was only important in
  special case such as test images, and for use in <A HREF="../mapping/index.html#intro"
  >Image Mapping</A>.  </P>

</I></FONT></TD></TR></TABLE></P>

<A NAME="radial-gradient"></A>
<H2>Radial Gradients</H2>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

As of IM v6.4.4 you can also generate radial gradient images in a similar way.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 100x100 radial-gradient:  rgradient.jpg
</CODE></PRE></TD></TR></TABLE>
</TD><TD>
  <A HREF="rgradient.jpg"
     ><IMG SRC="rgradient.jpg"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Note that the gradient is centered in the middle of the generated image, and
has a diameter set to fit the larger of the X or Y size of the image.  So if
the size of the image isn't square you will get a 'clipped' radial gradient.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 100x60 radial-gradient:  rgradient_clip.jpg
</CODE></PRE></TD></TR></TABLE>
</TD><TD>
  <A HREF="rgradient_clip.jpg"
     ><IMG SRC="rgradient_clip.jpg"       WIDTH=100 HEIGHT=60
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

This lets you easily generate a square radial gradient from the center to a
corner by making one edge 1.42 (square root of 2) times larger, and crop it.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 100x142 radial-gradient: \
          -gravity center -crop 100x100+0+0 rgradient_crop.jpg
</CODE></PRE></TD></TR></TABLE>
</TD><TD>
  <A HREF="rgradient_crop.jpg"
     ><IMG SRC="rgradient_crop.jpg"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

The colors of the gradient itself follow the same conventions as the much
older linear "<CODE><A HREF="index.html#gradient" >gradient:</A></CODE>" image
generator.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 100x100  radial-gradient:blue              rgradient_range1.jpg
  convert -size 100x100  radial-gradient:yellow            rgradient_range2.jpg
  convert -size 100x100  radial-gradient:green-yellow      rgradient_range3.jpg
  convert -size 100x100  radial-gradient:red-blue          rgradient_range4.jpg
  convert -size 100x100  radial-gradient:tomato-steelblue  rgradient_range5.jpg
</CODE></PRE></TD></TR></TABLE>
  <A HREF="rgradient_range1.jpg"
     ><IMG SRC="rgradient_range1.jpg"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="rgradient_range2.jpg"
     ><IMG SRC="rgradient_range2.jpg"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="rgradient_range3.jpg"
     ><IMG SRC="rgradient_range3.jpg"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="rgradient_range4.jpg"
     ><IMG SRC="rgradient_range4.jpg"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="rgradient_range5.jpg"
     ><IMG SRC="rgradient_range5.jpg"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>


<A NAME="gradient_transparent"></A>
<H3>Gradients with Transparency</H3>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

As of IM v6.2.9-8 the "<CODE>gradient:</CODE>" (and later
"<CODE>radial-gradient:</CODE>") image creation operator understands the use
of transparent and semi-transparent colors.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 100x100 gradient:none-firebrick gradient_transparent.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="gradient_transparent.png"
     ><IMG SRC="gradient_transparent.png"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/warning.gif"  WIDTH=28 HEIGHT=28
    ><IMG SRC="../img_www/space.gif"   WIDTH=12 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  Before ImageMagick 6.5.4-7 gradients involving a full transparency (such as
  the last example) would generally produce a black halo. </P>

  What was happening is that the gradient generated was from the given color
  to the special color '<CODE>none</CODE>'  or  transparent-black.  As
  a result colors would shade toward a semi-transparent black, before
  becoming fully-transparent. </P>

  The solution to this problem was to generate a transparency gradient
  and then <A HREF="../color_mods/index.html#colorize" >Colorize</A> it with the desired
  color.

</I></FONT></TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 100x100 gradient:none-black \
          -fill firebrick -colorize 100% gradient_trans_colorize.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="gradient_trans_colorize.png"
     ><IMG SRC="gradient_trans_colorize.png"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>


<A NAME="gradient_histogram"></A>
<H3>Gradients by Histogram Adjustment</H3>

You can create a non-linear gradient by applying some form of histogram
adjustment to a linear gradient. </P>

For example you can use a <A HREF="../color_mods/index.html#sigmoidal" >Sigmoidal
Contrast</A> function to create a more natural looking gradient.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 100x100 gradient: -sigmoidal-contrast 6,50% \
            gradient_sigmoidal.jpg
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="gradient_sigmoidal.jpg"
     ><IMG SRC="gradient_sigmoidal.jpg"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE>

This type of gradient is especially good for generating <A
HREF="../photos/index.html#overlap" >Overlapping Photos</A>, as it removed the sharp
gradient changes at the beginning of the overlapping region. </P>



<A NAME="gradient_functions"></A>
<H3>Evaluate/Function Gradients</H3>

You can also use the <A HREF="http://legacy.imagemagick.org/Usage/transform/#evaluate" >Evaluate Operator</A>
and related <A HREF="http://legacy.imagemagick.org/Usage/transform/#function" >Function Operator</A>
to modify a simple linear gradient.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 100x100 gradient: -evaluate cos 0.5 -negate \
            gradient_cosine.jpg
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="gradient_cosine.jpg"
     ><IMG SRC="gradient_cosine.jpg"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE>

Or take it a step further and make a smooth parabolic peek in the center of
the linear gradient.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 100x100 gradient: -function Polynomial -4,4,0 \
            gradient_peak.jpg
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="gradient_peak.jpg"
     ><IMG SRC="gradient_peak.jpg"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE>

Or band or a rippled pattern...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 100x100 gradient: -function sinusoid 4,-90  \
            gradient_bands.jpg
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="gradient_bands.jpg"
     ><IMG SRC="gradient_bands.jpg"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE>

Both of these closely related operators allow you to modify images and
gradients based on  Sine Curves,  Polynomials, Logarithmic and Power-of
mathematical functions. See <A HREF="http://legacy.imagemagick.org/Usage/transform/#evaluate" >Evaluate Math
Functions</A> and <A HREF="http://legacy.imagemagick.org/Usage/transform/#function" >Function, Multi-Argument
Evaluate</A> for more examples. </P>


<A NAME="gradient_distort"></A>
<H3>Distorted Gradients</H3>

<A NAME="gradient_rotate"></A>
<H4>Rotated Gradient</H4>

While the <A HREF="index.html#sparse-color" >Sparse Color</A> method '<CODE><A
HREF="index.html#barycentric" >Barycentric</A></CODE>' (see below), provides a
convenient way to generate gradients at any angle, if your IM is older than
version 6.4.3-0 then you may need to use other methods to generate a diagonal
or rotated gradient.  </P>

For example, by increasing the size of the gradient image (multiply by the
square root of 2 or 1.42), then rotate it 45 degrees, and crop the image to
its final size, you can make a diagonal gradient.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 142x142 gradient: -rotate -45 \
          -gravity center -crop 100x100+0+0 +repage \
          gradient_diagonal.jpg
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="gradient_diagonal.jpg"
     ><IMG SRC="gradient_diagonal.jpg"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE>

As of IM v6.3.5 you have a much faster and simpler way of generating a
rotated gradient by using a <A HREF="../distorts/index.html#srt" >SRT Distortion</A>.
For example, here is a 100 pixel gradient rotated 60 degrees, in a 100x100
pixel image.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 100x100 gradient: -distort SRT 60 gradient_srt.jpg
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="gradient_srt.jpg"
     ><IMG SRC="gradient_srt.jpg"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE>

This uses the default <A HREF="../misc/index.html#virtual-pixel" >Virtual Pixel,
Edge</A> setting to ensure the whole image is covered by the requested
gradient.  You can also use the expert <A HREF="../distorts/index.html#distort_viewport"
>Distort Viewport</A> setting, to map a gradient onto a larger image, such as
for an use in <A HREF="../photos/index.html#overlap" >Overlapping Photos</A>. </P>

<A NAME="gradient_warping"></A>
<H4>Warping Gradients</H4>

But you can use the same distortion methods to do a lot more than simple
rotations. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>

The gradient can also be twisted up...

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 100x100 gradient: -swirl 180 gradient_swirl.jpg
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="gradient_swirl.jpg"
     ><IMG SRC="gradient_swirl.jpg"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

You can re-map the gradient into a trapezoidal shape.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 100x100 gradient: -rotate -90 \
          -distort Perspective '0,0 40,0  99,0 59,0  0,99 -10,99 99,99 109,99' 
\
          gradient_trapezoid.jpg
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="gradient_trapezoid.jpg"
     ><IMG SRC="gradient_trapezoid.jpg"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE>

Or wrap the gradient into an arcs and circles using the <A 
HREF="../distorts/index.html#distort" >General Distortion Operator</A>...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 100x100 gradient: -distort Arc '180 0 50 0' \
          gradient_arc.jpg
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="gradient_arc.jpg"
     ><IMG SRC="gradient_arc.jpg"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 100x100 gradient: -distort Arc '360 0 50 0' \
          gradient_circle.jpg
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="gradient_circle.jpg"
     ><IMG SRC="gradient_circle.jpg"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE>

Though the new "<CODE><A HREF="index.html#radial-gradient" >radial-gradient:</A></CODE>"
is probably the more simpler method for generating these gradients. </P>

A very useful but harder to generate gradient is a polar angle gradient. </P>

The exact form of this gradient depends on if the gradient should be centered
on an even sized image, or an odd sized image. For example an <A
HREF="../distorts/index.html#arc" >Arc Distort</A> can be used to generate images with
an even number of pixel dimensions, 76 pixels in this case.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 1x1000 gradient: -rotate 90 \
          -distort Arc '360 -90 50 0' +repage \
          -gravity center -crop 76x76+0+0 +repage  gradient_angle_even.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="gradient_angle_even.png"
     ><IMG SRC="gradient_angle_even.png"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

The '<CODE>-90</CODE>' in the above sets the angle for the 'discontinuity'
where 'zero' and 'maximum' wraps around to the same value. The value
'<CODE>50</CODE>' should be at more than 1/2 the size of the final cropped
image.  Note how I used a much longer gradient to generate the smaller image.
This improves the overall correctness of the result, especially as the image
gets larger </P>

The closely related <A HREF="../distorts/index.html#polar" >Polar Distort</A> can also
generate such a gradient, but as it has a control over the exact position of
the 'center' of the distortion you can ensure it correctly generates an odd
pixel size polar gradient image.  In this case a 75 pixel image (radius
= '<CODE>36.5</CODE>' )

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 1x1000 gradient: -rotate 90 \
          +distort Polar '36.5,0,.5,.5' +repage \
          -transverse  gradient_angle_odd.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="gradient_angle_odd.png"
     ><IMG SRC="gradient_angle_odd.png"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

The last two images may seem very similar, except for their size, but the
handling of the center-most pixels is slightly different.  If you look closely
you will see that the last example has a perfect grey center pixel, where the
previous example does not have a single center pixel, but four of them. </P>

The final size of the image was determined by the value '<CODE>36.5</CODE>'
which is half of the '<CODE>75</CODE>' pixels wanted. The '<CODE>.5</CODE>'
offsets is the important aspect for correct handling of the polar center. </P>

Note that by default the distortion places the discontinuity at the top of the
image, as such the <A HREF="../warping/index.html#transverse" >Transverse Warp</A>
corrects the angle and location of the discontinuity to match that produced by
the <A HREF="../distorts/index.html#arc" >Arc Distort</A>. </P>

Here is a slightly different variant that generates an angular gradient but
with a transparent circular mask.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 50x1000 gradient: -rotate 90 -alpha set \
          -virtual-pixel Transparent +distort Polar 49 +repage \
          -transverse  gradient_angle_masked.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="gradient_angle_masked.png"
     ><IMG SRC="gradient_angle_masked.png"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

The value '<CODE>49</CODE>' is the radius minus 1 as by default a distort adds
a 1 pixel anti-aliasing buffer around the resulting image. As such final image
is 100x100 pixels.</P>

<BR>

Circular shapes and gradients can be warped to produce some interesting
non-linear gradients.  For example arcing it using a <A
HREF="../warping/index.html#wave" >Wave Distortion</A> can generate roughly triangular
shaped gradient.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 100x100 radial-gradient: \
          -background black -wave -28x200 -crop 100x100+0+0 +repage \
          gradient_triangle.jpg
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="gradient_triangle.jpg"
     ><IMG SRC="gradient_triangle.jpg"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE>

Or a very odd looking bird like shape, generated by polar distortion along
the top edge of the circular shape.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 100x100 radial-gradient: \
          +distort Polar '49' +repage \
          gradient_bird.jpg
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="gradient_bird.jpg"
     ><IMG SRC="gradient_bird.jpg"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE>

<A NAME="gradient_compose"></A>
<H3>Gradients by Composition</H3>

You can also modify gradients by combining them using various composition
methods.  For example  you can use the <A HREF="../compose/index.html#modulus_add"
>Modulus_Add</A> compose method to produce Venetian blind types of gradients.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 100x100 gradient: \( +clone +clone \) \
          -background gray50 -compose ModulusAdd -flatten \
          gradient_venetian.jpg
</CODE></PRE></TD></TR></TABLE></TD><TD ALIGN=center>
  <A HREF="gradient_venetian.jpg"
     ><IMG SRC="gradient_venetian.jpg"  WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

And even do this diagonally.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 100x100 gradient: \( gradient: -rotate -90 \) \
          \( -clone 0--1 -clone 0--1 \) \
          -background gray50 -compose ModulusAdd -flatten \
          gradient_vent_diag.jpg
</CODE></PRE></TD></TR></TABLE></TD><TD ALIGN=center>
  <A HREF="gradient_vent_diag.jpg"
     ><IMG SRC="gradient_vent_diag.jpg"  WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Or by blending two plain color gradients using either <A
HREF="../compose/index.html#channel" >Channel Copying</A>, or <A HREF="../compose/index.html#math"
>Mathematical Blending</A> composition methods, you can generate colorful 2
dimensional colormap gradients.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 100x100 gradient:yellow-blue \
          \( gradient:black-lime -rotate -90 \) \
          -compose CopyGreen -composite  gradient_colormap.jpg
</CODE></PRE></TD></TR></TABLE></TD><TD ALIGN=center>
  <A HREF="gradient_colormap.jpg"
     ><IMG SRC="gradient_colormap.jpg"  WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<A NAME="gradient_colorspace"></A>
<H3>Gradients in other Colorspaces</H3>

While "<CODE>gradient:</CODE>" generator currently cannot generate gradients
directly in some another <A HREF="../color_basics/index.html#colorspace" >Color
Spaces</A>, (only non-linear sRGB gradient images are created) you can
transfer gradients into a different color space to generate interesting
effects.  For example...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 30x600 xc:red -colorspace HSB \
          gradient: -compose CopyRed -composite \
          -colorspace RGB -rotate 90  gradient_rainbow.jpg
</CODE></PRE></TD></TR></TABLE>
  <A HREF="gradient_rainbow.jpg"
     ><IMG SRC="gradient_rainbow.jpg"       WIDTH=600 HEIGHT=30
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

This first converts a highly saturated color ('<CODE>red</CODE>') into HSL
colorspace, any saturated color can be used.  This correctly sets the images
saturation and brightness channels to the appropriate values.  After this
a gradient is generated and copied into the 'Hue' (equivalent to the 'red')
channel of this HSL colorspace image.  And hey presto when we convert the HSL
image back to RGB, we get a full rainbow gradient of fully-saturated colors.
</P>

Another method is to generate a gradient of just the right values for one of
these colorspaces, then change the images colorspace (using "<CODE><A
HREF="../../../html/www/command-line-options.html#set" >-set</A></CODE>").  This changes the colorspace
without changing the color values that we created in the image.  Now when we
convert back to RGB we get the same rainbow of values.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 30x600 gradient:'#FFF-#0FF' -rotate 90 \
          -set colorspace HSB -colorspace RGB \
          gradient_rainbow_2.jpg
</CODE></PRE></TD></TR></TABLE>
  <A HREF="gradient_rainbow_2.jpg"
     ><IMG SRC="gradient_rainbow_2.jpg"       WIDTH=600 HEIGHT=30
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

The result is actually exactly the same as the previous method, just a little
more direct, in that we generate the right values for the desired colorspace,
then set the colorspace those values belong to.  </P>

Here we take the masked angular gradient (see above) and re-map it into the
HSB color space to generate a circular hue of colors.  Red (hue=0) is rotated
toward to the right, where it is traditionally placed (polar coordinates angle
0).

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 100x300 gradient:'#FFF-#0FF' -rotate 90 \
          -alpha set -virtual-pixel Transparent +distort Polar 49 +repage \
          -rotate 90 -set colorspace HSB -colorspace RGB \
          gradient_hue_polar.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="gradient_hue_polar.png"
     ><IMG SRC="gradient_hue_polar.png"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

A similar example to the above is <A HREF="../color_basics/index.html#colorwheel" >Color
Wheel</A>, which is generated by <A HREF="../color_basics/index.html#combine" >Combining
Channel Images</A> with both a Hue and a Lightness gradient.  </P>


<A NAME="gradient_resize"></A>
<H3>Resized Gradient</H3>

One trick that was brought up on the by Glenn Randers-Pehrson,  was to create a very small image, two
pixels across, then expand that to the image size needed using "<CODE><A
HREF="../../../html/www/command-line-options.html#resize" >-resize</A></CODE>". </P>

The <A HREF="../resize/index.html#resize" >Resize Operator</A> tries to smooth out
enlarged images, to make them look better at the larger scale. It is this
smoothing that we use to generate a non-linear gradient.  </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

For example here we generate the small image using a 'portable bitmap' (or
PBM format) image and feed it into IM for enlargement.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  echo "P1 1 2   0  1 " | \
  convert - -resize 100x100\!   gradient_resize.jpg
</CODE></PRE></TD></TR></TABLE>
</TD><TD>
  <A HREF="gradient_resize.jpg"
     ><IMG SRC="gradient_resize.jpg"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  Some shells like 'csh' and variants, cannot handle the '<CODE>!</CODE>'
  character in the above resize geometry setting very well -- not even in
  quotes.  Hence the backslash '<CODE>\</CODE>' character may be needed.
  Caution is advised.
</I></FONT></TD></TR></TABLE></P>

The gradient produced is not linear, with a smooth start and finish to the
colors given, making those colors much more pronounced, than you would get
using a normal gradient. The actual function the gradient follows depends on
(and is close to) the exact <A HREF="../filter/index.html" >Resampling Filter</A> that
was used by resize. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

A simple way to generate that initial two-pixel image is actually with
gradient itself!  This lets you specify the colors directly.  Of course that
will limit you to a vertical gradient, unless you rotate the result as well.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 1x2  gradient:khaki-tomato \
          -resize 100x100\!   gradient_resize2.jpg
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="gradient_resize2.jpg"
     ><IMG SRC="gradient_resize2.jpg"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

Of course you are not limited to just a single dimension, with this technique.
Here I use a four pixel 'portable greymap' (or PGM image format) to generate a
2-dimensional gradient.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  echo "P2 2 2 2   2 1 1 0 " | \
  convert - -resize 100x100\!   gradient_resize3.jpg
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="gradient_resize3.jpg"
     ><IMG SRC="gradient_resize3.jpg"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

As you can see this diagonal gradient is not very linear when compared to
the <A HREF="index.html#gradient_rotate" >Rotated Gradient</A> above. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  The <A HREF="http://netpbm.sourceforge.net/" >Network Portable Bitmap</A>
  image formats, are very versatile for generating images from scripts.
  It is a format that is well worth knowing as a means of generating or
  manipulating image data.

</I></FONT></TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

If you look carefully you will also see that the gradient also starts from the
center of the enlarged pixel, and does not cover the whole image from edge to
edge.  This becomes more clear if we use a <A HREF="../filter/index.html#triangle"
>Triangle Resize Filter</A>.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert \( xc:red xc:blue +append \) \
          \( xc:yellow xc:cyan +append \) -append \
          -filter triangle -resize 100x100\!   gradient_resize4.jpg
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="gradient_resize4.jpg"
     ><IMG SRC="gradient_resize4.jpg"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>


<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

The <A HREF="../resize/index.html#resize" >Resize Operator</A> smoothes the color
between these pixels according to the "<CODE><A HREF="../filter/index.html#filter"
>Resampling Filter</A></CODE>" setings. By adjusting the filter you can have
the resize gradient generate a more edge to edge effect.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 1x2  gradient: \
          -filter Cubic  -resize 100x100\!    gradient_resize5.jpg
</CODE></PRE></TD></TR></TABLE>
</TD><TD>
  <A HREF="gradient_resize5.jpg"
     ><IMG SRC="gradient_resize5.jpg"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Here is rough "Rainbow Gradient" created using the 'resize' technique.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert xc:black xc:red xc:yellow xc:green1 xc:cyan xc:blue xc:black \
          +append -filter Cubic -resize 600x30\! gradient_rs_rainbow.jpg
</CODE></PRE></TD></TR></TABLE>
  <A HREF="gradient_rs_rainbow.jpg"
     ><IMG SRC="gradient_rs_rainbow.jpg"       WIDTH=600 HEIGHT=30
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

With this method you can use any color combination and order for the gradients
generation. This makes it very well suited to generating <A
HREF="../color_mods/index.html#color_lut" >Color Lookup Tables</A>. </P>


<A NAME="gradient_interpolate"></A>
<H3>Interpolated Lookup Gradients</H3>

For more information on the "<CODE><A HREF="../../../html/www/command-line-options.html#interpolate"
>-interpolate</A></CODE>" setting see <A HREF="../misc/index.html#interpolate"
>Interpolation Setting</A>.  </P>

Another method of generating gradients is to use the special  <A
HREF="../misc/index.html#interpolate" >Interpolation Setting</A>.  This setting is used
to determine the pixel color returned when the pixel lookup is not an integer,
and thus does not exactly match a specific pixel. Interpolation then 
determines
the color based on the pixels that surround the lookup point. </P>

The default setting of '<CODE>bilinear</CODE>' for example will linearly
determine the color for a lookup that falls between two pixels.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 600x30 xc:   \( +size xc:gold xc:firebrick +append \)  \
          -fx 'v.p{i/(w-1),0}'    gradient_interpolated.jpg
</CODE></PRE></TD></TR></TABLE>
  <A HREF="gradient_interpolated.jpg"
     ><IMG SRC="gradient_interpolated.jpg"      WIDTH=600 HEIGHT=30
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

Here the lookup X position '<CODE>i/(w-1)</CODE>' goes from '<CODE>0.0</CODE>'
to '<CODE>1.0</CODE>' over the second two-pixel image. The floating point
number produces a perfect linear gradient, much like "<CODE><A
HREF="index.html#gradient" >gradient:</A></CODE>" does.  </P>

The above is actually almost equivalent (see <A HREF="index.html#perfect_gradients"
>Perfect Gradients</A> for difference) to using a <A
HREF="../color_mods/index.html#clut" >Clut Recolored Images</A></CODE>" to recolor
a gradient image, using interpolated lookup of the two color image.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 30x600 gradient: -rotate 90 \
          \( +size xc:gold xc:firebrick +append \) -clut \
          gradient_clut_recolored.jpg
</CODE></PRE></TD></TR></TABLE>
  <A HREF="gradient_clut_recolored.jpg"
     ><IMG SRC="gradient_clut_recolored.jpg"      WIDTH=600 HEIGHT=30
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

Using this method also allows you to generate multi-colored gradients.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 30x600 gradient: -rotate 90  -interpolate Bicubic \
          \( +size xc:black xc:tomato xc:wheat +append \) -clut \
          gradient_clut.jpg
</CODE></PRE></TD></TR></TABLE>
  <A HREF="gradient_clut.jpg"
     ><IMG SRC="gradient_clut.jpg"      WIDTH=600 HEIGHT=30
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

The limitation however is that the colors can only be defined with equal
spacing.  You can not simply shift the position of the middle color, except by
roughly modifying the input gradient to some non-linear form, so as to shift
that center.  For more than three color is situation becomes worse. </P>

The above is also a good technique for coloring greyscale images using <A
HREF="../color_mods/index.html#duotone" >Duotones</A>, with a guarantee on exactly
defining the mid-tone color (unlike using the <A HREF="../color_mods/index.html#tint"
>Tint Operator</A>). </P>

<BR>

Interpolated lookup gradients can also be expanded to 2 dimensions, and
generate square linear gradients (<A HREF="../misc/index.html#bilinear" >Bilinear
Interpolation</A>), just as easily as purely one dimensions gradients.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert \( xc:red xc:blue +append \) \
          \( xc:yellow xc:cyan +append \) -append \
          -size 100x100 xc: +swap  -fx 'v.p{i/(w-1),j/(h-1)}' \
          gradient_bilinear.jpg
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="gradient_bilinear.jpg"
     ><IMG SRC="gradient_bilinear.jpg"      WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Here is the same example but using <A HREF="../misc/index.html#catrom" >Catrom
Interpolation</A>, and generating using the <A HREF="../distorts/index.html#distort"
>Distort Operator</A> instead of the very slow FX operator.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert \( xc:red xc:blue +append \) \
          \( xc:yellow xc:cyan +append \) -append \
          -filter point -interpolate catrom \
          -define distort:viewport=100x100 \
          -distort Affine '.5,.5 .5,.5   1.5,1.5 99.5,99.5' \
          gradient_catrom.jpg
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="gradient_catrom.jpg"
     ><IMG SRC="gradient_catrom.jpg"      WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

The key point to understanding the above is that we are enlarging the small
image based on the centers of its pixels.  See <A
HREF="../distorts/index.html#control_coordinates" >Image Coordinates vs Pixel
Coordinates</A> for details. </P>

Note that most interpolation methods have equivalent <A
HREF="../filter/index.html#interpolate" >Interpolated Resize Filters</A>.  But
the use of the viewport and pixel coordinates removes the edge effects that is
shown in the previous <A HREF="index.html#gradient_resize" >Resize Gradients</A> caused
by extreme upscaling of the very small image.  </P>

<BR>

The <A HREF="../misc/index.html#mesh" >Mesh Interpolation</A> setting however is not
available as a <A HREF="../filter/index.html#filter" >Resize Filter</A>.  It is
a special 2 dimensional interpolation that divides the intra-pixel area into
two flat linear triangles, hinged along the diagonal connecting the corners
with the minimal color difference. </P>

So by making two colors the same color, and using "<CODE>-interpolate
mesh</CODE>" you can generate a very different 2D gradient.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert \( xc:red xc:gold +append \) \
          \( xc:gold xc:green +append \) -append \
          -filter point -interpolate mesh \
          -define distort:viewport=100x100 \
          -distort Affine '.5,.5 .5,.5   1.5,1.5 99.5,99.5' \
          gradient_mesh.jpg
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="gradient_mesh.jpg"
     ><IMG SRC="gradient_mesh.jpg"      WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

As the two diagonally opposite yellow corners are the same, a diagonal of
yellow was used to join them. With the other colors linearly mapped to those
triangles.  If the two diagonal colors are not the same, you may get
a different diagonal division. </P>


<A NAME="gradient_fx"></A>
<H3>Roll your own gradient</H3>

The <A HREF="http://legacy.imagemagick.org/Usage/transform/#fx" >FX DIY Operator</A>, lets you define your own
gradients or other image generation, based on the current pixel position.
</P>

As this operator requires an image to work with, you can generate your
gradients or other images to match that image.  That is you don't have to know
the size of the image to generate a gradient for it! </P>

For example you can easily generate a linear gradient, sized correctly for
the image you may be working on.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert  rose:  -channel G -fx 'i/w' -separate   gradient_fx_linear.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="gradient_fx_linear.gif"
     ><IMG SRC="gradient_fx_linear.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  When generating gray-scale gradients, you can make the -fx operator 3 times
  faster, simply by asking it to only generate one color channel only, such as
  the '<CODE>G</CODE>' or green channel in the above example.  This channel
  can then be <A HREF="../color_basics/index.html#separate" >Separated</A> to form the
  required gray-scale image.  This can represent a very large speed boost,
  especially when using a very complex "<CODE><A HREF="../../../html/www/command-line-options.html#fx"
  >-fx</A></CODE>" formula.
</I></FONT></TD></TR></TABLE></P>

You can even generate some neat non-linear gradients.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert  rose:  -channel G -fx '(i/w)^4' -separate   gradient_fx_x4.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="gradient_fx_x4.gif"
     ><IMG SRC="gradient_fx_x4.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR>
<TR><TD>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert  rose:  -channel G -fx 'cos(pi*(i/w-.5))' \
           -separate   gradient_fx_cos.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="gradient_fx_cos.gif"
     ><IMG SRC="gradient_fx_cos.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

How about a 2-dimensional circular linear radial gradient (a cone).

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 100x100 xc: -channel G \
          -fx 'rr=hypot(i/w-.5, j/h-.5); 1-rr*1.42' \
          -separate gradient_fx_radial.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="gradient_fx_radial.gif"
     ><IMG SRC="gradient_fx_radial.gif"      WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/warning.gif"  WIDTH=28 HEIGHT=28
    ><IMG SRC="../img_www/space.gif"   WIDTH=12 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  The "<CODE><A HREF="../../../html/www/command-line-options.html#fx" >-fx</A></CODE>" function
  '<CODE>rr=hypot(xx,yy)</CODE>' was added to IM v6.3.6 to speed up the very
  commonly used expression '<CODE>rr=sqrt(xx*xx+yy*yy)</CODE>'. It also meant
  that we no longer need to make extra assignments such as
  '<CODE>xx=i/w-.5</CODE>' when creating a radial gradient.
</I></FONT></TD></TR></TABLE></P>

The value '<CODE>1.42</CODE>' (or <CODE>sqrt(2)</CODE>) in the above controls
the overall size of the gradient relative to the images dimensions. In this
way the radius of the gradient (how far black is from center) is diagonal
distance to the corner. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

You can even remove the '<CODE>sqrt()</CODE>' (built into the
'<CODE>hypot()</CODE>' function) from the expression to make a more
interesting spherical gradient, which can be useful for <A
HREF="http://legacy.imagemagick.org/Usage/transform/#shade" >3D Shading Effects</A>.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 100x100 xc: -channel G \
          -fx 'xx=i/w-.5; yy=j/h-.5; rr=xx*xx+yy*yy; 1-rr*4' \
          -separate gradient_fx_spherical.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="gradient_fx_spherical.gif"
     ><IMG SRC="gradient_fx_spherical.gif"      WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Note how I use some assignment expressions to simplify the calculation of the
distance from center of the image, then convert it to a gradient.  This
feature was added in IM v6.3.0.  </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

Using a high power function, you can give photos a fade off effect around the
rectangular edges of the image.  Adjust the power value '<CODE>4</CODE>' to
control the amount of fading.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 100x100 xc: -channel G \
          -fx '(1-(2*i/w-1)^4)*(1-(2*j/h-1)^4)' \
          -separate  gradient_fx_quad2.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="gradient_fx_quad2.gif"
     ><IMG SRC="gradient_fx_quad2.gif"      WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

Here is an angular gradient, generated using direct mathematics.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 100x100 xc:  -channel G \
          -fx '.5 - atan2(j-h/2,w/2-i)/pi/2' \
          -separate  gradient_fx_angular.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="gradient_fx_angular.gif"
     ><IMG SRC="gradient_fx_angular.gif"      WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Note that the '<CODE>atan2(y,x)</CODE>' function returns an angle in radians
from -PI to +PI (see its manpage), so its output needs to be be scaled and
translated to correctly fit a 0.0 to 1.0 color range. This is why the above
looks so much more complex than it really is.</P>

This last example can be generated faster by <A HREF="index.html#gradient_distort"
>Distorting a Gradient</A>. </P>


<A NAME="gradient_complex"></A>
<H3>More Complex DIY Gradients</H3>

<I>ASIDE: This section was created before the addition of <A
HREF="index.html#sparse-color" >Sparse Points of Color</A>, and the had a direct
influence on its creation.</I> </P>

Of course an FX function can generate color gradients.  For example here is a
gradient based on distance ratios, using an extremely complex FX expression.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE SCRIPT>
  convert -size 100x100 xc: +size xc:red xc:yellow -colorspace RGB \
          -fx 'ar=hypot( i/w-.8, j/h-.3 )*4;
               br=hypot( i/w-.3, j/h-.7 )*4;
               u[1]*br/(ar+br) + u[2]*ar/(ar+br)' \
          -colorspace RGB gradient_dist_ratio.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="gradient_dist_ratio.gif"
     ><IMG SRC="gradient_dist_ratio.gif"      WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  The image processing was performed in a linear color space (RGB) to avoid
  'sRGB darken' during the blending of such strong primary colors.  See <A
  HREF="../color_basics/index.html#processing" >Processing Real Images</A> for more
  details.
</I></FONT></TD></TR></TABLE></P>

When going from two points to three points the ratio of how much color each
'control point' provides, is a bit more complex, and uses a technique called
Inverse Distance Weighted (IDW) Interpolation.  You can see more details math
for this in <A HREF="http://en.wikipedia.org/wiki/Inverse_distance_weighting"
>Wikipedia, IDW</A> </P>

Here is an inverse distance example for three points.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE SCRIPT>
  convert -size 100x100 xc: +size xc:red xc:yellow xc:lime -colorspace RGB \
          -fx 'ar=1/max(1, hypot(i-50,j-10)  );
               br=1/max(1, hypot(i-10,j-70)  );
               cr=1/max(1, hypot(i-90,j-90)  );
               ( u[1]*ar + u[2]*br + u[3]*cr )/( ar+br+cr )' \
          -colorspace sRGB gradient_inverse.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="gradient_inverse.gif"
     ><IMG SRC="gradient_inverse.gif"      WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

And here I use an inverse distance squared which is the more normal method used
for an IDW interpolation. This is also known as Shepard's Interpolation method.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE SCRIPT>
  convert -size 100x100 xc: +size xc:red xc:yellow xc:lime -colorspace RGB \
          -fx 'ar=1/max(1,  (i-50)*(i-50)+(j-10)*(j-10)  );
               br=1/max(1,  (i-10)*(i-10)+(j-70)*(j-70)  );
               cr=1/max(1,  (i-90)*(i-90)+(j-90)*(j-90)  );
               ( u[1]*ar + u[2]*br + u[3]*cr )/( ar+br+cr )' \
          -colorspace sRGB gradient_shepards.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="gradient_shepards.gif"
     ><IMG SRC="gradient_shepards.gif"      WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Note that the '<CODE>hypot()</CODE>' function was not used in the above
as there is no need to generate a square root of the distance. </P>

The above has now been implemented using the <A HREF="index.html#sparse-color" >Sparse
Color</A> methods '<CODE><A HREF="index.html#inverse" >Inverse</A></CODE>' and '<CODE><A
HREF="index.html#shepards" >Shepard's</A></CODE>'.  As such the above can now be done 
far
more simply using...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 100x100 xc: -colorspace RGB \
          -sparse-color  Inverse '50,10 red  10,70 yellow  90,90 lime' \
          -colorspace sRGB  gradient_inverse_alt.gif
  convert -size 100x100 xc: -colorspace RGB \
          -sparse-color  Shepards '50,10 red  10,70 yellow  90,90 lime' \
          -colorspace sRGB  gradient_shepards_alt.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="gradient_inverse_alt.gif"
     ><IMG SRC="gradient_inverse_alt.gif"      WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=25 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="gradient_shepards_alt.gif"
     ><IMG SRC="gradient_shepards_alt.gif"      WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=25 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

The problem with using either 'Inverse Distance' or 'Shepard's Method'
(inverse squared distance) is that all the 'control points' has a global
effect over the whole image.  As a result you get a sort of underlying
'average color' in between the points, and especially at a large distance from
all control points.  This, in turn, produces 'spots' of color rather than
a smooth gradient of color. </P>

<A NAME="gradient_complex_hues"></A>
<H3>DIY Gradients and Hues
<BR><FONT SIZE=-1>-- (Hues are hard to deal with)</FONT></H3>

<I>ASIDE: This was a sort of failed attempt to generate an interesting rainbow
effect.  It was a failure, but I learned a lot from that failure, which
I present to you here.</I> </P>

The above works well but I wanted to try and to do better. I thought perhaps
I could generate a bright rainbow gradient of colors between the points,
rather than generating spots that merges into an average color. </P>

So to generate a hue gradient, I tried to do the <A
HREF="http://en.wikipedia.org/wiki/Inverse_distance_weighting" >Inverse
Distance Weighted Interpolation</A> in HSB colorspace, though I switched the
yellow to blue, to make the colors more equally spaced around the hue, and
hopefully provide another way of generating a color wheel (see <A
HREF="index.html#gradient_colorspace" >Gradients in Other Colorspaces</A> above).

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE SCRIPT>
  convert -size 100x100 xc: +size xc:red xc:blue xc:lime -colorspace HSB \
          -fx 'ar=1/max(1,  (i-50)*(i-50)+(j-10)*(j-10)  );
               br=1/max(1,  (i-10)*(i-10)+(j-70)*(j-70)  );
               cr=1/max(1,  (i-90)*(i-90)+(j-90)*(j-90)  );
               ( u[1]*ar + u[2]*br + u[3]*cr )/( ar+br+cr )' \
          -colorspace sRGB   gradient_shepards_HSB.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="gradient_shepards_HSB.gif"
     ><IMG SRC="gradient_shepards_HSB.gif"      WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

As you can see all the colors were nice an bright as we are only generating
a hue gradient.  However it also appears very strange, which is caused by the
'cyclic' nature of the 'Hue' color channel. As a consequence the area between
the blue and the red goes the long way round though a green hue, rather than
that the shorter 'modulus' path via a purple hue. </P>

After much research I finally discovered how to do the modulus mathematics
needed to do the above correctly by using a <A
HREF="http://en.wikipedia.org/wiki/Circular_mean" >Circular Mean</A> for the
weighted average of distances. </P> This involves converting the Hue as
a polar angle, into X and Y rectangular coordinates. That allows you to
perform linear mathematics, letting us perform a linear weighting of the
values, appropriately. The result is then then converting back into an angular
Hue. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE SCRIPT>
  convert -size 100x100 xc: +size xc:red xc:blue xc:lime \
          -colorspace HSB -channel R \
          -fx 'aa=u[1]*2*pi; ba=u[2]*2*pi; ca=u[3]*2*pi;
               ar=1/max(1, hypot(i-50,j-10) );
               br=1/max(1, hypot(i-10,j-70) );
               cr=1/max(1, hypot(i-90,j-90) );
               nr=ar+br+cr;
               mod(atan2( ( sin(aa)*ar + sin(ba)*br + sin(ca)*cr )/nr,
                         ( cos(aa)*ar + cos(ba)*br + cos(ca)*cr )/nr
                       )/(2*pi)+1, 1)' \
          -separate -background white -combine +channel \
          -set colorspace HSB -colorspace sRGB  gradient_circular_mean_hue.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="gradient_circular_mean_hue.gif"
     ><IMG SRC="gradient_circular_mean_hue.gif"      WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

NOTE: The above only performed its operations on the hue channel only.  For
real image, we would still need to operate (as normal) on saturation and
brilliance channels. </P>

As you can see we now get a correct gradient between the red and blue, though
the method when applied to just primary colors that have a high angular
separation, tends to generate very sudden gradient changes in the middle.
That is while the result is correct the angular hue variation is not linear
for very large changes in hue effects.  It would work well for averaging lots
of near hues, but not for these widely spaced primaries.  </P>

I even switched to using a stronger 'Inverse Weighting' rather than the more
usual 'Inverse Squared' or 'Shepard's' method (see above) and while it 
improved
things, the hue changes were still compressing in the center due to the
non-linear effects. </P>

As the input colors are constant, pre-converting them into hue-x, and hue-y
coordinates, doing the shepard's weighting on those channels, then converting
back again would actually make the process even faster.  That is convert
colors from a HSB colorspace to a Hx,Hy,S,B colorspace, to apply the
technique.  </P>

If this is done, then central point and even gradient between the points,
would shade to white (the center point of a HSB colorspace).  If this was
performed in HSL colorspace that area would shade toward a mid-tone gray.
</P>

<BR>

This conversion from a polar Hue to X-Y coordinates would in some ways be
similar to just doing the calculations in a non-polar RGB space, which shows
that same shade toward gray effects (see previous examples). </P>

So if by using a <A HREF="http://en.wikipedia.org/wiki/Circular_mean"
>Circular Mean</A> we are in fact simply converting a HSB colorspace into
a highly distorted variant RGB, why not just do the task in a linear RGB
colorspace, and saturate the colors, to generate the hue!

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 100x100 xc: -colorspace RGB \
          -sparse-color  Inverse '50,10 red  10,70 blue  90,90 lime' \
           -colorspace sRGB gradient_inverse_RGB.png
  convert gradient_inverse_RGB.png -colorspace HSB \
          -channel GB -evaluate set 100% +channel \
          -colorspace sRGB gradient_inverse_RGB_Hue.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="gradient_inverse_RGB.png"
     ><IMG SRC="gradient_inverse_RGB.png"      WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=25 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="=>">
  <A HREF="gradient_inverse_RGB_Hue.gif"
     ><IMG SRC="gradient_inverse_RGB_Hue.gif"      WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=25 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  The image processing was performed in a linear color space (RGB) to avoid
  'sRGB darken' during the blending of such strong primary colors.  See <A
  HREF="../color_basics/index.html#processing" >Processing Real Images</A> for more
  details.
</I></FONT></TD></TR></TABLE></P>


As you can see we get practically exactly the same result as before, but with
all the complex 'modulus mathematics' removed.  However I am still no closer
to getting a more linear spread of hues between the starting points of color.
</P>

The moral of all this is that working with Hues is hard, not only due to the
'red discontinuity', but also because of non-linear effects that happen when
colors are very widely spaced.  And in the end the result was the same as if
I have done the task directly linear RGB space and saturating the colors.
</P>

Essentially while HSB and HSL colorspaces are fun, they are not linear,
realistic, or practical colorspaces to work with.  This is also probably why
very few operations actually work with hue directly. </P>


<A NAME="perfect_gradients"></A>
<H3>Generating the Perfect Gradient (mathematically)</H3>

Generating perfect mathematical gradient, such as for <A HREF="../fourier/index.html"
>Fourier Transforms</A> (which is cyclic), <A HREF="../mapping/index.html#distort"
>Image Mapping</A>, or even <A HREF="http://legacy.imagemagick.org/Usage/transform/#gradient_math" >Gradient
Mathematics</A>; requires special gradients that is different to the gradients
we have so far looked at. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>

What do I mean by this?  Well here is a small 1x5 pixel 
"<CODE>gradient:</CODE>"
image, that I have <A HREF="../resize/index.html#scale" >Scaled</A> so you can see
the individual pixel colors.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert  -size 1x5 gradient:  -scale 2000% gradient.png
</CODE></PRE></TD></TR></TABLE>
</TD><TD>
  <A HREF="gradient.png"
     ><IMG SRC="gradient.png"       WIDTH=20 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

This image creates a gradient that goes from an exact 'white' color along the
very top row, to an exact 'black' color along the bottom most row. It is an
'idealized' gradient, and typically exactly what an user wants, as it actually
contains the actual colors the user specified. </P>

However while this is what an user expects, it is not a mathematically correct
gradient.  As discussed in <A HREF="../distorts/index.html#control_coordinates" >Image
Coordinates vs Pixel Coordinates</A> pixels actually have an area, and as such
the white pixel at the top of the image represents the center of that pixel,
while the black represents the center of he bottom most pixel.  That is not
the edge of the image but 1/2 pixel away from the edge.

Mathematically images start at the edge.  As such to generate a perfect
mathematical gradient, you need to specify the color locations at the edge of
the image, in pixel coordinates.  As such in image coordinates, the positions
are displaced by 1/2 a pixel, and the image size is exactly the number of
pixels in the image (a distance), rather than a location that is 1 pixel
smaller that the images size. </P>

One way to generate a mathematically perfect gradient is to use
<A HREF="index.html#barycentric" >Barycentric Sparse Color</A> (looked at in detail in
the next section) to generate a perfect edge-to-edge gradient...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 1x5 xc: \
          -sparse-color Barycentric '0,-0.5 white  0,%[fx:h-.5] black' \
          -scale 2000%  gradient_math.png
</CODE></PRE></TD></TR></TABLE>
</TD><TD>
  <A HREF="gradient_math.png"
     ><IMG SRC="gradient_math.png"       WIDTH=20 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Note that the coordinates used go from <CODE>-0.5</CODE> to the images height
minus <CODE>0.5</CODE>, That the pixel coordinates of the actual edges of the
image.  And if you were to look closely at the results you will find that the
top and bottom most pixels are <I>not white or black in color</I>.  The pixel
is the color of the gradient at the pixels center. </P>

Because this gradient is mathematically correct, this gradient will 'tile'
correctly when used in special 'tiling' or 'cyclic' situations. </P>

The previous gradient image will not 'tile' correctly.  You get a pure-white
pixel, next to, the pure-black pixel, so as to generate an one pixel gap or
'disjunction' in the mathematical cycle, in situations where pure white and
pure black are typically regarded as equivalent values.  </P>

A simpler way is to generate a "<CODE><A HREF="index.html#gradient"
>gradient:</A></CODE>" image that is one pixel longer, and chop one pixel,
from either end (according to the current "<CODE><A
HREF="../../../html/www/command-line-options.html#gravity" >-gravity</A></CODE>" setting). </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>

For example here chopped the top-most white pixel, as having a black pixel (or
zero value) is often more desirable in the final result.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 1x6 gradient: -chop 0x1 -scale 2000%  gradient_chopped.png
</CODE></PRE></TD></TR></TABLE>
</TD><TD>
  <A HREF="gradient_chopped.png"
     ><IMG SRC="gradient_chopped.png"       WIDTH=20 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

The resulting gradient image can then be <A HREF="../warping/index.html#rect_rotates"
>Rotated</A> as needed, to then generate the required image for later image
processing. </P>

However while this gradient will 'cycle' correctly, the actual position of the
color is not exactly correct.  But in many cases this is good enough.  If you
need a 'perfect gradient' I recommend you use a sparse color gradient. </P>

<B>In Summery...</B> A little thought about exactly what you want from your
gradient can make a big difference in the accuracy of your final results.  But
if it does not matter, than don't worry about it, use whatever is simplest for
the task at hand. </P>


<BR>

<HR><!-- ---------------------------------------------------------------- -->

<A NAME="sparse-color"></A>
<H2>Sparse Points of Color</H2>

The "<B><CODE><A HREF="../../../html/www/command-line-options.html#sparse-color"
>-sparse-color</A></CODE></B>" operator was added to IM v6.4.3-0 will take an
image and set the color given at each of the given floating point
'<CODE>x,y</CODE>' coordinates.  That is of the form...

<DIV ALIGN=center>
<PRE>-sparse-color {method}  'x,y color   x,y color   x,y color ...' </PRE>
</DIV></P>

The rest of the pixels (limited according to the "<CODE><A
HREF="../../../html/www/command-line-options.html#channel" >-channel</A></CODE>" setting) will then be
mapped according to there relation to these isolated points of color, so as to
smooth out the colors between those points. The <I>method</I> defines what
that relationship will be.  </P>

Naturally there are lots of ways to define what the intervening color should
be, and which method you choose really depends on what you are attempting to
achieve. </P>

It can also actually be classed as a completely free-form version of
2-dimensional interpolation (See <A
HREF="http://en.wikipedia.org/wiki/Interpolation" >Interpolation,
Wikipedia</A>). </P>

Image enlargement, or <A HREF="../resize/index.html#resize" >Resize</A> is actually
a specialized sub-set of this, but one where you start with a complete fixed
grid of pixels to be enlarged.  Unfortunately few of the <A
HREF="../filter/index.html#filter" >Resize Filters</A> or <A HREF="../misc/index.html#interpolate"
>Interpolate Methods</A> that are specifically designed to dealing with a grid
of points, will translate directly into a free form set of sparsely separated
points of color. </P>

That is to say resize involving incomplete grid just does not work. </P>

This is also related to "Geographical Information System (GIS)" methods where
landscapes are measured using sparsely separated points of height (which are
rarely in a strict grid), with the rest of the landscape being determined
from those isolated points.  In a similar situation meteorology often has
isolated points of air pressure and temperature, which then needs to be
interpolated.  Typically after interpolation the maps are further processed to
generate 'iso-lines' showing points of equal value (height, pressure,
temperature), producing the various weather maps almost everyone are familiar
with. </P>

In this case you would think of the generated image as being a simple
gray-scale 'height map' of the input data, or perhaps even of all three
variables simultaneously, each to a separate image 'channel'. </P>


<A NAME="barycentric"></A>
<H3>Barycentric <FONT SIZE=-1>(triangle gradient)</FONT></H3>

The "<CODE>Barycentric</CODE>" method, will map three and only three points
into a linear triangle of color. The colors outside this triangle continue as
before.  I have marked the input points with a small circle, so that the
colors you see are all the interpolated values that were generated by the <A
HREF="index.html#sparse-color" >Sparse Color Operator</A>.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 100x100 xc: -colorspace RGB \
          -sparse-color  Barycentric '30,10 red   10,80 blue   90,90 lime' \
          -colorspace sRGB  -fill white -stroke black \
          -draw 'circle 30,10 30,12  circle 10,80 10,82  circle 90,90 90,92' \
          sparse_barycentric.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="sparse_barycentric.png"
     ><IMG SRC="sparse_barycentric.png"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  The image processing was performed in a linear color space (RGB) to avoid
  'sRGB darken' during the blending of such strong primary colors.  See <A
  HREF="../color_basics/index.html#processing" >Processing Real Images</A> for more
  details.
</I></FONT></TD></TR></TABLE></P>

If four or more points are given a 'best fit' will be performed, over all
the points given, and as a result the actual points may not get the exact
color specified for those points. </P>

However be warned that the gradient does not just 'stop' but continues to
change beyond those points.  Traditionally a barycentric gradient will be
limited to within the enveloping triangle of the points used to generate it.
</P>

For example..

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 100x100 xc: -colorspace RGB \
          -sparse-color Barycentric '30,10 red   10,80 blue   90,90 lime' \
          -colorspace sRGB  -fill white -stroke black \
          \( -size 100x100 xc:black -draw 'polygon 30,10  10,80  90,90' \) \
          +matte -compose CopyOpacity -composite \
          -draw 'circle 30,10 30,12  circle 10,80 10,82  circle 90,90 90,92' \
          sparse_bary_triangle.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="sparse_bary_triangle.png"
     ><IMG SRC="sparse_bary_triangle.png"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

This is a faster version from Fred Weinhaus, that creates a triangle mask in
the alpha channel, which by default, the <A HREF="index.html#sparse-color" >Sparse Color
Operator</A> will not update (due to the default channel settings). All the
colors including fully transparent pixels are however still filled with color,
just alpha masked.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 100x100 xc:none -draw "polygon 30,10  10,80  90,90" \
          -colorspace RGB \
          -sparse-color Barycentric '30,10 red   10,80 blue   90,90 lime' \
          -colorspace sRGB   sparse_bary_triangle_2.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="sparse_bary_triangle_2.png"
     ><IMG SRC="sparse_bary_triangle_2.png"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/expert.gif"   WIDTH=23 HEIGHT=26
    ><IMG SRC="../img_www/space.gif"   WIDTH=17 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  The triangular masks used above are 1/2 pixel too big due to the way draw
  draws an extra line around its shapes. See <A HREF="../draw/index.html#bounds"" >Draw
  Fill Bounds</A> for details.  This could be a problem when generating
  a generating a triangular mesh of gradients.

</I></FONT></TD></TR></TABLE></P>

The '<CODE>barycentric</CODE>' method is in reality a mapping of a linear
affine equation to each of the three color channels separately.  As such if I
separate each of the color channels of the above three point example, you get
three simple linear gradients in each color channel.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert sparse_barycentric.png -separate sparse_bary_%d.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="sparse_barycentric.png"
     ><IMG SRC="sparse_barycentric.png"
           ALIGN=middle VSPACE=1 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="=>">
  <A HREF="sparse_bary_0.gif"
     ><IMG SRC="sparse_bary_0.gif"
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="sparse_bary_1.gif"
     ><IMG SRC="sparse_bary_1.gif"
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="sparse_bary_2.gif"
     ><IMG SRC="sparse_bary_2.gif"
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

It is only because of the use of primary colors that the above gradients all
were mapped parallel to one of the edges of the triangle. That is not
typically the case. But you will always get a simple linear gradient in each
separate channel of the image, and a flat plane of values in 3D color space.
</P>

<A NAME="two_color_gradients"></A>
<H4>Barycentric and Two Color Gradients</H4>

This parallel effect of the triangular barycentric gradient is actually very
useful.  If two of the points were set to the same color, then those to
points will define the 'angle' of the gradient between them and the other
colored point. </P>

For example by making two of the points '<CODE>red</CODE>' the gradient will
be made parallel to the two '<CODE>red</CODE>' points...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 100x100 xc: -colorspace RGB \
          -sparse-color  Barycentric '30,10 red   10,80 red   90,90 lime' \
          -colorspace sRGB  -fill white -stroke black \
          -draw 'circle 30,10 30,12  circle 10,80 10,82  circle 90,90 90,92' \
          sparse_bary_gradient.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="sparse_bary_gradient.png"
     ><IMG SRC="sparse_bary_gradient.png"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Here is the same example but with one of the angle control points moved
to show how it sets the gradient angle.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 100x100 xc: -colorspace RGB \
          -sparse-color  Barycentric '50,70 red   10,80 red   90,90 lime' \
          -colorspace sRGB  -fill white -stroke black \
          -draw 'circle 50,70 50,72  circle 10,80 10,82  circle 90,90 90,92' \
          sparse_bary_gradient_2.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="sparse_bary_gradient_2.png"
     ><IMG SRC="sparse_bary_gradient_2.png"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<A NAME="diagonal_gradients"></A>
<H4>Diagonal Gradients</H4>

This provides a simple way of generating any linear diagonal gradient using
just two colors. </P>

For example here is a particularly nice way of creating a diagonal gradient,
going from one corner to another corner, for ANY sized input image.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 600x60 xc: -colorspace RGB \
          -sparse-color barycentric '0,0 skyblue  -%w,%h skyblue  %w,%h black' \
          -colorspace sRGB diagonal_gradient.jpg
</CODE></PRE></TD></TR></TABLE>
  <A HREF="diagonal_gradient.jpg"
     ><IMG SRC="diagonal_gradient.jpg" WIDTH=600 HEIGHT=60
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

And to align with the other two corners...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 600x60 xc: -colorspace RGB \
          -sparse-color barycentric '0,%h black  -%w,0 black  %w,0 skyblue' \
          -colorspace sRGB diagonal_gradient_2.jpg
</CODE></PRE></TD></TR></TABLE>
  <A HREF="diagonal_gradient_2.jpg"
     ><IMG SRC="diagonal_gradient_2.jpg" WIDTH=600 HEIGHT=60
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

These 'diagonal gradients' produce a natural looking gradient even with long
images such as the above.  Study the locations of the three color points,
especially the two points of equal color that define the angle of the gradient
between the two corners.  Notice that in both cases one of the those points is
not even located within the image itself! </P>

Also note the use of  <A HREF="../basics/index.html#arg_percent" >Percent Escapes</A> to
make the positions automatically adjust to the size of the images on which the
gradient is being drawn. </P>


<A NAME="two_point_gradients"></A>
<H4>Two Point Gradients</H4>

If only two color points are given, IM will generate the third point for you,
so that the angle is perpendicular between the two original points.  The
result is a simple linear gradient over which you have a lot of control.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 100x100 xc:  -colorspace RGB \
          -sparse-color  Barycentric '30,10 red  90,90 lime' \
          -colorspace sRGB  -fill white -stroke black \
          -draw 'circle 30,10 30,12  circle 90,90 90,92' \
          sparse_bary_two_point.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="sparse_bary_two_point.png"
     ><IMG SRC="sparse_bary_two_point.png"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Two point gradients however do not work very well when applied to
the corners of very 'wide' or 'tall' images (high-aspect ratio).  Basically
the gradient is not diagonally aligned, unlike the three point gradients
above.  It is angled, just not angled enough to make it 'interesting'.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 600x60 xc: -colorspace RGB \
          -sparse-color barycentric '0,0 skyblue  %w,%h black' \
          -colorspace sRGB  sparse_bary_two_point_wide.jpg
</CODE></PRE></TD></TR></TABLE>
  <A HREF="sparse_bary_two_point_wide.jpg"
     ><IMG SRC="sparse_bary_two_point_wide.jpg" WIDTH=600 HEIGHT=60
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>


<A NAME="bilinear"></A>
<H3>Bilinear <FONT SIZE=-1>(4 point gradient)</FONT></H3>

This method fits an equation to 4 points, over all three color channels to
produce an uniform color gradient between the points, and beyond.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 100x100 xc:  -colorspace RGB \
    -sparse-color Bilinear '30,10 red  10,80 blue  70,60 lime  80,20 yellow' \
    -colorspace sRGB  -fill white -stroke black \
    -draw 'circle 30,10 30,12  circle 10,80 10,82' \
    -draw 'circle 70,60 70,62  circle 80,20 80,22' \
    sparse_bilinear.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="sparse_bilinear.png"
     ><IMG SRC="sparse_bilinear.png"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

You can see this '4 point fit' by taking the above image and separating out
the individual color channel gradients.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert sparse_bilinear.png -separate sparse_bilin_%d.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="sparse_bilinear.png"
     ><IMG SRC="sparse_bilinear.png"
           ALIGN=middle VSPACE=1 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="=>">
  <A HREF="sparse_bilin_0.gif"
     ><IMG SRC="sparse_bilin_0.gif"
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="sparse_bilin_1.gif"
     ><IMG SRC="sparse_bilin_1.gif"
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="sparse_bilin_2.gif"
     ><IMG SRC="sparse_bilin_2.gif"
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

Note how the equation produces curves (quadratic curves actually).  However if
the 4 points form parallel lines, the gradient generated will become linear.
This method is actually equivalent to the <A HREF="../misc/index.html#bilinear"
>Bilinear Interpolation</A> method (see <A HREF="index.html#gradient_interpolate"
>Interpolated Lookup Gradients</A> below), when the 4 points are aligned to a
orthogonal (rectangular) grid. </P>

If less than 4 points are given the above function will be replaced by
a 3 point '<CODE><A HREF="index.html#barycentric" >Barycentric</A></CODE>' method (see
above).  If more than four points are given it will do a best fit of all the
points, and thus may not actually match the given color at the point
specified. This is not recommended. </P>


<A NAME="voronoi"></A>
<H3>Voronoi <FONT SIZE=-1>(nearest color)</FONT></H3>

The "<CODE>Voronoi</CODE>" method, just maps each pixel to the closest
color point you have provided.  This basically divides the image into a set of
polygonal 'cells' around each point. For example..

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 100x100 xc:  -colorspace RGB \
    -sparse-color  Voronoi '30,10 red  10,80 blue  70,60 lime  80,20 yellow' \
    -colorspace sRGB  -fill white -stroke black \
    -draw 'circle 30,10 30,12  circle 10,80 10,82' \
    -draw 'circle 70,60 70,62  circle 80,20 80,22' \
    sparse_voronoi.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="sparse_voronoi.gif"
     ><IMG SRC="sparse_voronoi.gif"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

As you can see no attempt is made to provide anti-aliasing of the colored
'cells' around each point. The edge of each cell actually falls exactly
midway between each point's nearest neighbours.  </P>

This can be used for example to generate masks to cut up the image in various
ways. Just assign one point as white and all the rest as black to extract one
single 'cell' from the image. </P>

If you want to smooth (anti-alias) the result you can either use some form of
<A HREF="../distorts/index.html#super_sampling" >Super Sampling</A>  to smooth the
image.  For example generate one 4 times as big, and "<CODE><A
HREF="../../../html/www/command-line-options.html#scale" >-scale</A></CODE>" it back to the desired
size.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 400x400 xc: -colorspace RGB \
    -sparse-color Voronoi '120,40 red 40,320 blue 270,240 lime 320,80 yellow' 
\
    -scale 25%  -colorspace sRGB -fill white -stroke black \
    -draw 'circle 30,10 30,12  circle 10,80 10,82' \
    -draw 'circle 70,60 70,62  circle 80,20 80,22' \
    sparse_voronoi_ssampled.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="sparse_voronoi_ssampled.png"
     ><IMG SRC="sparse_voronoi_ssampled.png"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  All the image processing was performed in a linear color space (RGB) to
  avoid 'sRGB darken' during the blending of such strong primary colors.  See
  <A HREF="../color_basics/index.html#processing" >Processing Real Images</A> for more
  details.
</I></FONT></TD></TR></TABLE></P>


The simpler way (though not very nice) is to just simply blur the image very
slightly...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 100x100 xc: -colorspace RGB \
    -sparse-color Voronoi '30,10 red  10,80 blue  70,60 lime  80,20 yellow' \
    -blur 1x0.7  -colorspace sRGB  -fill white -stroke black \
    -draw 'circle 30,10 30,12  circle 10,80 10,82' \
    -draw 'circle 70,60 70,62  circle 80,20 80,22' \
    sparse_voronoi_smoothed.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="sparse_voronoi_smoothed.png"
     ><IMG SRC="sparse_voronoi_smoothed.png"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

By blurring generated image by a large amount you can set up some non-linear
gradients between the 'cells' that was generated.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 100x100 xc:  -colorspace RGB \
    -sparse-color  Voronoi '30,10 red  10,80 blue  70,60 lime  80,20 yellow' \
    -blur 0x15  -colorspace sRGB  -fill white -stroke black \
    -draw 'circle 30,10 30,12  circle 10,80 10,82' \
    -draw 'circle 70,60 70,62  circle 80,20 80,22' \
    sparse_voronoi_blur.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="sparse_voronoi_blur.png"
     ><IMG SRC="sparse_voronoi_blur.png"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

The larger the "<CODE><A HREF="../../../html/www/command-line-options.html#blur" >-blur</A></CODE>", 
the
larger the gradient between the various 'cells'. However be warned that this
may not preserve small colored cells, or ensure the original point remains the
color that was given, if it is close to the edge (and another point) of a
different color. </P>

By using a special 'linear blur' technique, developed by Fred Weinhaus, you 
can
produce a fixed width linear gradient between the cells.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 100x100 xc: -colorspace RGB \
    -sparse-color  Voronoi '30,10 red  10,80 blue  70,60 lime  80,20 yellow' \
    -blur 10x65535  -colorspace sRGB  -fill white -stroke black \
    -draw 'circle 30,10 30,12  circle 10,80 10,82' \
    -draw 'circle 70,60 70,62  circle 80,20 80,22' \
    sparse_voronoi_gradient.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="sparse_voronoi_gradient.png"
     ><IMG SRC="sparse_voronoi_gradient.png"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

The unblurred output could also passed to various <A HREF="http://legacy.imagemagick.org/Usage/transform/#edge"
>Edge Detection</A> techniques to generate various bounded edges. </P>

You can remap the image via a <A HREF="http://legacy.imagemagick.org/Usage/transform/#edge_vector" >Raster to
Vector Convertor</A> to generate vector lines.  However I found the default
'<CODE>autotrace</CODE>' settings may need to be adjusted with
"<CODE>-corner-threshold 120</CODE>" so it will detect the corners better.
</P>


<A NAME="shepards"></A>
<H3>Shepards <FONT SIZE=-1>(spots of color)</FONT></H3>

The "<CODE>Shepards</CODE>" method uses a ratio of the inverse squares of the
distances to each of the given points to determine the color of the canvas at
each point.  See <A HREF="index.html#gradient_complex" >More Complex DIY Gradients</A>
above for examples of how the mathematics is performed. </P>

It is a bit like having spotlights of color at each point which interacts
with each other, as the light spreads out to an uniform average of all the
given colors at infinity.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 100x100 xc: -colorspace RGB \
    -sparse-color  Shepards '30,10 red  10,80 blue  70,60 lime  80,20 yellow' 
\
    -colorspace sRGB  -fill white -stroke black \
    -draw 'circle 30,10 30,12  circle 10,80 10,82' \
    -draw 'circle 70,60 70,62  circle 80,20 80,22' \
    sparse_shepards.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="sparse_shepards.png"
     ><IMG SRC="sparse_shepards.png"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  The image processing was performed in a linear color space (RGB) to avoid
  'sRGB darken' during the blending of such strong primary colors.  See <A
  HREF="../color_basics/index.html#processing" >Processing Real Images</A> for more
  details.
</I></FONT></TD></TR></TABLE></P>

By surrounding a specific area with a similar color you can generate a plateau
of that specific color, though the boundaries between the edging points may
'leak', and the center of the 'plateau' may sag to form shallow bowl
(depending on distance to other color points). </P>

This method is also what is used to generate a displacement field, such as
what is used in <A HREF="../distorts/index.html#shepards" >Shepards Image
Distortions</A>. In that case X and Y displacement vectors is what is being
mapped rather than color R,G,B values. </P>


<A NAME="inverse"></A>
<H3>Inverse <FONT SIZE=-1>(sharp points of color)</FONT></H3>

The "<CODE>Inverse</CODE>" method is practically identical to
"<CODE>Shepards</CODE>", except that it uses a more direct inverse distance
weighting of the points given.  See <A HREF="index.html#gradient_complex" >More Complex
DIY Gradients</A> above for examples of how the mathematics is performed. </P>

This was a much later addition to ImageMagick version 6.6.9-7. </P>

For example...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 100x100 xc: -colorspace RGB \
    -sparse-color  Inverse '30,10 red  10,80 blue  70,60 lime  80,20 yellow' \
    -colorspace sRGB  -fill white -stroke black \
    -draw 'circle 30,10 30,12  circle 10,80 10,82' \
    -draw 'circle 70,60 70,62  circle 80,20 80,22' \
    sparse_inverse.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="sparse_inverse.png"
     ><IMG SRC="sparse_inverse.png"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

As you can see it generates sharp points of color, that quickly merges into
the background 'average color'. In comparison to <A HREF="index.html#shepards"
>Shepards Method</A> which generates rounded spots, with a 'flat' color around
the color points. </P>

It does however work better when generating linear gradients where all
the control points form a line.  That is for generating 1 dimensional
gradients along a specific line in the image. </P>

However there is one more point to be made. The speed of how fast these points
of color drops to a near 'average' level is controlled my how close they are.
Placing two point sources close together, and they drop quickly, the further
apart they are and the larger individual colors influence results.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 100x100 xc: -colorspace RGB \
          -sparse-color Inverse '45,45 red  55,55 lime' \
          -colorspace sRGB  -fill white -stroke black \
          -draw 'circle 45,45 45,47  circle 55,55 55,57' \
          sparse_inverse_near.png
  convert -size 100x100 xc: -colorspace RGB \
          -sparse-color Inverse '30,30 red  70,70 lime' \
          -colorspace sRGB  -fill white -stroke black \
          -draw 'circle 30,30 30,32  circle 70,70 70,72' \
          sparse_inverse_far.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="sparse_inverse_near.png"
     ><IMG SRC="sparse_inverse_near.png"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=25 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="sparse_inverse_far.png"
     ><IMG SRC="sparse_inverse_far.png"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=25 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

Also if you 'double up' a specific point (exactly on, or just near each other)
with the same or similar color, you will make that color point, twice as
strong.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 100x100 xc: -colorspace RGB \
          -sparse-color Inverse '30,30 red  75,65 lime  65,75 lime' \
          -colorspace sRGB -fill white -stroke black \
          -draw 'circle 30,30 30,32  circle 75,65 75,67  circle 65,75 65,77 ' 
\
          sparse_inverse_stronger.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="sparse_inverse_stronger.png"
     ><IMG SRC="sparse_inverse_stronger.png"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

These effects also applies to '<CODE><A HREF="index.html#shepards" >Shepards</A></CODE>'
method too!  </P>

<A NAME="shepards_power"></A>
<H3>Shepards Power Factor</H3>

Both the <A HREF="index.html#shepards" >Shepards</A> and <A HREF="index.html#inverse" >Inverse</A>
sparse color methods are actually the same but with different 'power levels'
applied to the inverse distance weights. (2.0 and 1.0 respectiavally).  As of
IM v6.8.0-10, you can set this power level using an operational <A
HREF="../basics/index.html#define" >define</A>, '<CODE>shepards:power</CODE>', which
will be used by the '<CODE><A HREF="index.html#shepards" >Shepards</A></CODE>' method.
</P>

For example

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 100x100 xc: -colorspace RGB -define shepards:power=0.5 \
     -sparse-color Shepards '30,10 red  10,80 blue  70,60 lime  80,20 yellow' 
\
     -colorspace sRGB -fill white -stroke black \
     -draw 'circle 30,10 30,12  circle 10,80 10,82' \
     -draw 'circle 70,60 70,62  circle 80,20 80,22' \
     sparse_shepards_pow0.5.png
  convert -size 100x100 xc: -colorspace RGB -define shepards:power=1 \
     -sparse-color Shepards '30,10 red  10,80 blue  70,60 lime  80,20 yellow' 
\
     -colorspace sRGB -fill white -stroke black \
     -draw 'circle 30,10 30,12  circle 10,80 10,82' \
     -draw 'circle 70,60 70,62  circle 80,20 80,22' \
     sparse_shepards_pow1.png
  convert -size 100x100 xc: -colorspace RGB -define shepards:power=2 \
     -sparse-color Shepards '30,10 red  10,80 blue  70,60 lime  80,20 yellow' 
\
     -colorspace sRGB -fill white -stroke black \
     -draw 'circle 30,10 30,12  circle 10,80 10,82' \
     -draw 'circle 70,60 70,62  circle 80,20 80,22' \
     sparse_shepards_pow2.png
  convert -size 100x100 xc: -colorspace RGB -define shepards:power=3 \
     -sparse-color Shepards '30,10 red  10,80 blue  70,60 lime  80,20 yellow' 
\
     -colorspace sRGB -fill white -stroke black \
     -draw 'circle 30,10 30,12  circle 10,80 10,82' \
     -draw 'circle 70,60 70,62  circle 80,20 80,22' \
     sparse_shepards_pow3.png
convert -size 100x100 xc: -colorspace RGB -define shepards:power=8 \
     -sparse-color Shepards '30,10 red  10,80 blue  70,60 lime  80,20 yellow' 
\
     -colorspace sRGB -fill white -stroke black \
     -draw 'circle 30,10 30,12  circle 10,80 10,82' \
     -draw 'circle 70,60 70,62  circle 80,20 80,22' \
     sparse_shepards_pow8.png
</CODE></PRE></TD></TR></TABLE>
<TABLE><TR VALIGN=top>
<TD ALIGN=center>
  <A HREF="sparse_shepards_pow0.5.png"
     ><IMG SRC="sparse_shepards_pow0.5.png"   WIDTH=100  HEIGHT=100
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR><FONT SIZE=-1>power 0.5</FONT>
</TD><TD ALIGN=center>
  <A HREF="sparse_shepards_pow1.png"
     ><IMG SRC="sparse_shepards_pow1.png"   WIDTH=100  HEIGHT=100
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR><FONT SIZE=-1>power 1.0<BR>(inverse)</FONT>
</TD><TD ALIGN=center>
  <A HREF="sparse_shepards_pow2.png"
     ><IMG SRC="sparse_shepards_pow2.png"   WIDTH=100  HEIGHT=100
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR><FONT SIZE=-1>power 2.0<BR>(shepards)</FONT>
</TD><TD ALIGN=center>
  <A HREF="sparse_shepards_pow3.png"
     ><IMG SRC="sparse_shepards_pow3.png"   WIDTH=100  HEIGHT=100
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR><FONT SIZE=-1>power 3.0</FONT>
</TD><TD ALIGN=center>
  <A HREF="sparse_shepards_pow8.png"
     ><IMG SRC="sparse_shepards_pow8.png"   WIDTH=100  HEIGHT=100
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR><FONT SIZE=-1>power 8.0</FONT>
</TD></TR></TABLE>
</DIV></P>

As you can see the 'spots of color' expand from very sharp points, to rounded
spots, and on to large areas of color.  At very high power levels it will
eventually reproduce the same pattern as a <A HREF="index.html#voronoi" >Voronoi Sparse
Color Method</A>. </P>

This <A HREF="../basics/index.html#define" >-define</A> not only effects <A
HREF="index.html#shepards" >Shepards Sparse Color</A>, but also will have similar
effects on <A HREF="../distorts/index.html#shepards" >Shepards Distortion Method</A>
which is based on calculated displacement maps generated by the sparse color
method.  However it does not effect the <A HREF="index.html#inverse" >Inverse</A> sparse
color method, which always uses a power-level of 1.0. </P>


<A NAME="sparse_summery"></A>
<H3>Summery of Sparse Color Methods</H3>

Here is a repeat of the various, 4 point "<CODE><A
HREF="../../../html/www/command-line-options.html#sparse-color" >-sparse-color</A></CODE>" images, for
comparison.

<TABLE ALIGN=center WIDTH=80%>
<TR><TD ALIGN=center>
  <A HREF="sparse_voronoi.gif"
     ><IMG SRC="sparse_voronoi.gif"
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
 <BR><FONT SIZE=-1>Voronoi</FONT>
</TD><TD ALIGN=center>
  <A HREF="sparse_voronoi_blur.png"
     ><IMG SRC="sparse_voronoi_blur.png"
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
 <BR><FONT SIZE=-1>Voronoi (blurred)</FONT>
</TD><TD ALIGN=center>
 <A HREF="sparse_shepards.png"
    ><IMG SRC="sparse_shepards.png"
          ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
 <BR><FONT SIZE=-1>Shepards</FONT>
</TD><TD ALIGN=center>
 <A HREF="sparse_inverse.png"
    ><IMG SRC="sparse_inverse.png"
          ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
 <BR><FONT SIZE=-1>Inverse</FONT>
</TD><TD ALIGN=center>
 <A HREF="sparse_bilinear.png"
    ><IMG SRC="sparse_bilinear.png"
          ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
 <BR><FONT SIZE=-1>Bilinear</FONT>
</TD></TR></TABLE></P>

And here is a summery of the various, 3 point methods.

<!--<CODE EXECUTE>
  convert -size 100x100 xc: -colorspace RGB \
          -sparse-color  Voronoi '30,10 red   10,80 blue   90,90 lime' \
          -colorspace sRGB -fill white -stroke black \
          -draw 'circle 30,10 30,12  circle 10,80 10,82  circle 90,90 90,92' \
          sparse_voronoi_3pt.gif
  convert -size 100x100 xc: -colorspace RGB \
          -sparse-color  Voronoi '30,10 red   10,80 blue   90,90 lime' \
          -blur 0x15  -colorspace sRGB  -fill white -stroke black \
          -draw 'circle 30,10 30,12  circle 10,80 10,82  circle 90,90 90,92' \
          sparse_voronoi_blur_3pt.png
  convert -size 100x100 xc: -colorspace RGB \
          -sparse-color  Shepards '30,10 red   10,80 blue   90,90 lime' \
          -colorspace sRGB -fill white -stroke black \
          -draw 'circle 30,10 30,12  circle 10,80 10,82  circle 90,90 90,92' \
          sparse_shepards_3pt.png
  convert -size 100x100 xc: -colorspace RGB \
          -sparse-color  Inverse '30,10 red   10,80 blue   90,90 lime' \
          -colorspace sRGB -fill white -stroke black \
          -draw 'circle 30,10 30,12  circle 10,80 10,82  circle 90,90 90,92' \
          sparse_inverse_3pt.png
</CODE>-->
<TABLE ALIGN=center WIDTH=80%>
<TR><TD ALIGN=center>
  <A HREF="sparse_voronoi_3pt.gif"
     ><IMG SRC="sparse_voronoi_3pt.gif"
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
 <BR><FONT SIZE=-1>Voronoi</FONT>
</TD><TD ALIGN=center>
  <A HREF="sparse_voronoi_blur_3pt.png"
     ><IMG SRC="sparse_voronoi_blur_3pt.png"
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
 <BR><FONT SIZE=-1>Voronoi (blurred)</FONT>
</TD><TD ALIGN=center>
 <A HREF="sparse_shepards_3pt.png"
    ><IMG SRC="sparse_shepards_3pt.png"
          ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
 <BR><FONT SIZE=-1>Shepards</FONT>
</TD><TD ALIGN=center>
 <A HREF="sparse_inverse_3pt.png"
    ><IMG SRC="sparse_inverse_3pt.png"
          ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
 <BR><FONT SIZE=-1>Inverse</FONT>
</TD><TD ALIGN=center>
 <A HREF="sparse_barycentric.png"
    ><IMG SRC="sparse_barycentric.png"
          ALIGN=middle VSPACE=2 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
 <BR><FONT SIZE=-1>Barycentric</FONT>
</TD></TR></TABLE></P>

At this time only '<CODE><A HREF="index.html#voronoi" >Voronoi</A></CODE>', '<CODE><A
HREF="index.html#shepards" >Shepards</A></CODE>' and '<CODE><A HREF="index.html#inverse"
>Inverse</A></CODE>' methods are suitable for more than four points. </P>

<I>More "<CODE><A HREF="../../../html/www/command-line-options.html#sparse-color"
>-sparse-color</A></CODE>" methods are planned. If you have any ideas
mail them to me.  </I></P>


<A NAME="sparse_channel"></A>
<H3>Channel and Sparse Color</H3>

The "<CODE><A HREF="../../../html/www/command-line-options.html#sparse-color" 
>-sparse-color</A></CODE>"
operator is effected by the "<CODE><A HREF="../../../html/www/command-line-options.html#channel"
>-channel</A></CODE>" setting which means you can use that setting to limit 
its
effects to just a single channel, or expand it to the transparency channel.
</P>

You can also use the  "<CODE><A HREF="../../../html/www/command-line-options.html#channel"
>-channel</A></CODE>" setting to speed up processing of gray-scale images by
only operating on one channel, then "<CODE><A
HREF="../../../html/www/command-line-options.html#separate" >-separate</A></CODE>" that channel (see <A
HREF="../color_basics/index.html#channel" >Channel Handling</A> for more detail). For
example..

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 100x100 xc: -channel G -sparse-color Shepards \
              '30,10 gray70  10,80 black  70,60 white  80,20 gray(33.3333%)' \
          -separate +channel    -fill white -stroke black \
          -draw 'circle 30,10 30,12  circle 10,80 10,82' \
          -draw 'circle 70,60 70,62  circle 80,20 80,22' \
          sparse_shepards_gray.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="sparse_shepards_gray.gif"
     ><IMG SRC="sparse_shepards_gray.gif"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

As of IM v6.6.8-5 unmodified channels is preserved, as such
you can now use <A HREF="index.html#sparse-color" >Sparse Color</A> with the
"<CODE><A HREF="../../../html/www/command-line-options.html#channel" >-channel</A></CODE>" setting to
add a transparent gradient to any image, quickly and easily. </P>

For example here I add a transparent <A HREF="index.html#diagonal_gradient" >Diagonal
Gradient</A>, that is aligned so that 50% transparency is along the diagonal
of the built-in "<CODE>rose:</CODE> image.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rose: -alpha set -channel A \
          -sparse-color Barycentric \
                 '0,0 opaque   %w,-%h opaque    %w,%h transparent' \
          rose_alpha_gradient.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="rose_alpha_gradient.png"
     ><IMG SRC="rose_alpha_gradient.png"       WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>


<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  The color '<CODE>Opaque</CODE>' is just another name for
  '<CODE>Black</CODE>'.  Basically it is used when you are really only
  interested in specifying a fully-opaque color, but the actual color itself
  unimportant.  Similarly with the color '<CODE>Transparent</CODE>'.  I could
  have just as easily used '<CODE>White</CODE>' and '<CODE>None</CODE>'
  respectively.
</I></FONT></TD></TR></TABLE></P>


<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/warning.gif"  WIDTH=28 HEIGHT=28
    ><IMG SRC="../img_www/space.gif"   WIDTH=12 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  Before IM v6.6.8-5 any channels not selected by the "<CODE><A
  HREF="../../../html/www/command-line-options.html#channel" >-channel</A></CODE>" setting was reset to
  zero (black) values.  This severely limited its effective usefulness
</I></FONT></TD></TR></TABLE></P>


<A HREF="index.html#sparse-color" >Sparse Color</A> also accepts normalized floating
point values instead of a color name.  Exactly how many values need to be
provided to replace the color name depends on the current "<CODE><A
HREF="../../../html/www/command-line-options.html#channel" >-channel</A></CODE>" setting, and
whether that channel is 'active' in the image being processed.  The easiest
way is to limited the processing to a single channel.  Also note that when
using raw numbers, rather than color names, transparency values are 'matte'
values (0=opaque) and not 'alpha' values (1=opaque) (for IMv6). </P>

As such in the above I could have used numbers instead of color names...
<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE DO_NOT_EXECUTE>
  -channel A  -sparse-color Bilinear '0,0 1.0   -%w,%h 1.0    %w,%h 0.0'
</CODE></PRE></TD></TR></TABLE>
</DIV></P>

This may be easier to handle in programmed scripts, and in API's, which may
not have access to the 'colorname' translator. </P>


<A NAME="sparse_fill"></A>
<H3>Sparse Color as a Fill Operator</H3>

One of the original reasons for creating the <A HREF="index.html#sparse-color" >Sparse
Color Operator</A>, was so that you could give an image containing just a small
number of fixed points of color, and from this 'fill-in' the rest of the
undefined colors.  </P>

For example here I have drawn a small number of pixels.  The "<CODE><A
HREF="../../../html/www/command-line-options.html#antialias" >+antialias</A></CODE>" setting was
specifically turned off so no semi-transparent, or mixed colors have been
drawn, as such the image only contains the four exact colors specified an no
others.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 100x100 xc:none +antialias -fill none -strokewidth 0.5 \
          -stroke Gold        -draw "path 'M 20,70  A 1,1 0 0,1 80,50'" \
          -stroke DodgerBlue  -draw "line 30,10  50,80" \
          -stroke Red         -draw "circle 80,60  82,60" \
          sparse_source.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="sparse_source.gif"
     ><IMG SRC="sparse_source.gif"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Now we can extract the few non-transparent pixels that are present in this
image, then fill in all the other colors using the multi-point sparse color
method, '<CODE><A HREF="index.html#shepards" >Shepards</A></CODE>'.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert sparse_source.gif txt:- |\
    sed '1d; / 0) /d; s/:.* /,/;' |\
      convert sparse_source.gif -alpha off \
              -sparse-color shepards '@-' sparse_fill.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="sparse_fill.png"
     ><IMG SRC="sparse_fill.png"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

The "<CODE>sed</CODE>" command in the above takes the <A HREF="../files/index.html#txt"
>Enumerated Text File Format</A>, deletes the first header line and any line
containing transparency, before re-formatting it into a list of pixel
coordinates and colors.  That list is then 'pipelined' into the <A
HREF="index.html#sparse-color" >Sparse Color Operator</A> using the
special "<CODE>@-</CODE>" argument. </P>

Yes the above is very tricky, but works.  At least for a very small number of
points.  However the more points that are provided, the slower the operation
becomes. This is because <A HREF="index.html#sparse-color" >Sparse Color</A> is 'point'
orientated in its processing, rather than image or <A HREF="../morphology.html"
>Morphology</A> orientated. </P>

Eventually I hope to be able to provide a set of morphology orientated,
'hole-filling' methods, where you can just give the above image as-is and have
it fill in the transparent areas automatically. </P>

This point-extraction technique can be combined with the <A
HREF="../morphology/index.html#edge-in" >EdgeIn Morphology Method</A> to extract the
pixels around the edges of objects or holes, so that you can then 'fill-in'
the missing background or holes (as shown in <A HREF="../morphology/index.html#channels"
>Morphology and Channels</A>).  For example...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert figure.gif -channel A -morphology EdgeIn Diamond 
shape_edge_pixels.gif
  convert shape_edge_pixels.gif txt:- |\
    sed '1d; / 0) /d; s/:.* /,/;' | \
     convert shape_edge_pixels.gif -alpha off \
             -sparse-color shepards '@-' shape_edge_in_lights.png
  convert shape_edge_in_lights.png figure.gif -composite shape_in_lights.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="http://legacy.imagemagick.org/Usage/canvas/figure.gif"
     ><IMG SRC="http://legacy.imagemagick.org/Usage/canvas/figure.gif"       WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="=>">
  <A HREF="shape_edge_pixels.gif"
     ><IMG SRC="shape_edge_pixels.gif"       WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="=>">
  <A HREF="shape_edge_in_lights.png"
     ><IMG SRC="shape_edge_in_lights.png"       WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="=>">
  <A HREF="shape_in_lights.png"
     ><IMG SRC="shape_in_lights.png"       WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

Note that the resulting image is exactly the same as the input, but with the
transparent background replaced with a distance blurred 'edge colors'.  This
is why the edges of the image have become in-distinct. </P>

This image was specifically developed to try and generate better 'edge
feathering' techniques. See <A HREF="../blur/index.html#feathering" >Blur Feathering</A>
and <a HREF="../morphology/index.html#distance_feather" >Distance Feathering</A> for
other feathering techniques. </P>

<A NAME="sparse_blur"></A>
<H3>Sparse Color Shepards, a Blur Alternative</H3>

One alternative to using "<CODE><A HREF="../../../html/www/command-line-options.html#sparse-color"
>-sparse-color</A></CODE>" is to take the image of pixels on a transparent
background, and <A HREF="../blur/index.html#blur" >Blur</A> it.  Afterward the
transparency is junked.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert sparse_source.gif   -channel RGBA -blur 0x15 \
          -alpha off  sparse_blur_simple.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="sparse_source.gif"
     ><IMG SRC="sparse_source.gif"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="=>">
  <A HREF="sparse_blur_simple.png"
     ><IMG SRC="sparse_blur_simple.png"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

The problem with this is that the original colors not preserved, and you also
have the problem of exact what '<I>sigma</I>' value should be used. </P>

Also it does not take into account just now 'near' each color is, as such two
colored pixels close together (less than the '<I>sigma</I>' value) will swamp
each other, and become blurred together. </P>

<BR>

A better method is to generate multiple layers of blurred images with
progressively smaller '<I>sigma</I>' values, and the original unblurred image
on top.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE SCRIPT sparse_blur_layered.png>
  for sigma in  64 32 16 8 4 2 1 0;  do
    convert sparse_source.gif -depth 16 \
            -channel RGBA -blur 0x$sigma miff:-
  done |
    convert - -background none -flatten -alpha off sparse_blur_layered.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="sparse_source.gif"
     ><IMG SRC="sparse_source.gif"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="=>">
  <A HREF="sparse_blur_layered.png"
     ><IMG SRC="sparse_blur_layered.png"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

This layered blurring technique is equivalent to the result of a '<CODE><A
HREF="index.html#shepards" >Shepards</A></CODE>' method on the same image, though not as
exact, it is very close.  However it is likely to be much faster when a lot of
input pixels are involved, as it is image (morphology) oriented, rather than
calculating using individual points. </P>

An other layered blur method is to use <A HREF="../resize/index.html#resize" >Resize</A>
to generate a 'pyramid' of blurred images.  This technique is detailed in <A
HREF="../blur/index.html#blur_resize" >Large Blurs using Resize</A>.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert sparse_source.gif \
          \( +clone -resize 50% \) \
          \( +clone -resize 50% \) \
          \( +clone -resize 50% \) \
          \( +clone -resize 50% \) \
          \( +clone -resize 50% \) \
          \( +clone -resize 50% \) \
          \( +clone -resize 50% \) \
          -layers RemoveDups -filter Gaussian -resize 100x100\! -reverse \
          -background None -flatten -alpha off    sparse_blur_pyramid.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="sparse_blur_pyramid.png"
     ><IMG SRC="sparse_blur_pyramid.png"  WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

This will work very fast with very large images without needing large
'<I>sigma</I>' values (and thus very slow) for each of the blurring steps.
</P>

Essentially it is using a faster image resizing technique to generate the
blurred layers of the previous example.  It is not as exact, but will generate
a good approximation of the correct result.  However it works best for images
which are a square, and a power of two in size, or it will be less accurate.
</P>

The special operator "<CODE><A HREF="../../../html/www/command-line-options.html#layers" >-layers</A>
RemoveDups</CODE>" in the above will remove any extra 'single average pixel'
images that was generated, by the multiple 'clone-resize' operations.  The
images are then resize back to the original size using a <A
HREF="../filter/index.html#gaussian" >Gaussian Resize Filter</A> (the equivalent to
a blur). The image order is then reversed so as to place the original on top,
and the more blurry layers underneath, before flattening together as before.
</P>

It has the advantage of only needing to read the image once, doing all the
work in a single command.  It also works very quickly even for large images,
especially as the resize only halves the image at each step, and thus avoids
the slow blurring with a very large sigma. </P>

The only disadvantage with this method is that you will need to have a rough
idea of the original size of the image to restore the 'blurred' images, and to
get at least a rough idea of how many resized clones to generate
(Log<SUB><SUB>2</SUB></SUB> of the largest dimension, plus 1).  However
overdoing the resize clones is not a major performance hit as the resize
simply becomes a 'no-op' when the input image has already been resized down to
the minimal 1 pixel image. The extra and useless 'resized image layers' are
then dealt with automatically using "<CODE><A HREF="../../../html/www/command-line-options.html#layers"
>-layers</A> RemoveDups</CODE>".</P>

The only real problem is the possibility of the resized images becoming 'out of
sync' when handling an image that is not a power-of-two in size.  How severe
this problem is is not known, but shouldn't be too great, as those images are
also the most blurred. </P>

Of course it still has the 'leakage' problem of the '<CODE><A HREF="index.html#shepards"
>Shepards</A></CODE>' method, so lets look at this problem in more detail.
</P>

<A NAME="shepards_leakage"></A>
<H3>Shepards Method 'Leaks'</H3>

The '<CODE><A HREF="index.html#shepards" >Shepards</A></CODE>' method does not have any
understanding of 'boundaries', and as such colors on the far side of some
'line of color' will leak, or 'bleed thru' past that line.  Eventually at
a large distance you will get a pure average color of all the pixels. </P>

This is not always a desirable outcome (though is desirable in some cases).
</P>

In this example, the closer the '<CODE>Red</CODE>' curve approaches the
'<CODE>White</CODE>' line, the more the color will 'leak' though the two lines
to the far side producing a pink color.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 100x100 xc:none +antialias -fill none -strokewidth 0.5 \
          -stroke Red    -draw "path 'M 26,0  A 55,61 0 0,1 26,100'" \
          -stroke White  -draw "line 50,0  50,100" \
          sparse_lines_near_source.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="sparse_lines_near_source.gif"
     ><IMG SRC="sparse_lines_near_source.gif"  WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert sparse_lines_near_source.gif txt:- |\
    sed '1d; / 0) /d; s/:.* /,/;' |\
      convert -size 100x100 xc: -sparse-color shepards '@-' \
              sparse_lines_near.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="sparse_lines_near.png"
     ><IMG SRC="sparse_lines_near.png"  WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

This leakage of colors is the main problem with using <A HREF="index.html#shepards"
>Shepards Method</A> for 'hole filling' especially when multiple holes are
involved, as the colors involved with one hole, can and will leak into and
effect the colors in a completely different hole. And visa-versa. </P>

It is an understanding of boundaries that forms the difference between <A
HREF="index.html#shepards" >Shepards Method</A>, and another form of color
'hole-filling' known as '<I>Color Diffusion</I>'. </P>

Basically with '<I>Color Diffusion</I>', colors can not pass though a line of
some other defined color.  It is achieved by limiting the effect to only
colors in 'line of sight', or to those that leak, around the outside of an
edge.  This requires using distance to the nearest colors to limit what colors
influence a pixel.  </P>

One major use of '<I>Color Diffusion</I>' is presented on the <A
HREF="http://artis.imag.fr/Publications/2008/OBWBTS08/" >Diffusion Curves</A>
web site. This not only makes heavy use of color diffusion, but also includes
information on techniques for generating diffusions very quickly.  I hope to
implement this into ImageMagick at some point in the future. </P>

<HR><!-- ---------------------------------------------------------------- -->

<A NAME="plasma"></A>
<H2>Plasma Images</H2>

<A NAME="plasma_gradients"></A>
<H3>Plasma Gradients</H3>

While gradients provide a smooth range of colors, another image creation
operator "<CODE>plasma:</CODE>" provides a different sort of gradient. One
that is ideally suited to generating a random backdrop of color for your
images. </P>

First of all I should point out that "<CODE>plasma:</CODE>" is a randomized
image. As such it can and will produce a different image every time it is run.
For example here we generate three separate 'standard' plasma images, and each
image is different from each other, even though the same command was used to
generate them.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE RANDOM>
  convert -size 100x100  plasma:  plasma1.jpg
  convert -size 100x100  plasma:  plasma2.jpg
  convert -size 100x100  plasma:  plasma3.jpg
</CODE></PRE></TD></TR></TABLE>
  <A HREF="plasma1.jpg"
     ><IMG SRC="plasma1.jpg"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="plasma2.jpg"
     ><IMG SRC="plasma2.jpg"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="plasma3.jpg"
     ><IMG SRC="plasma3.jpg"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

You can also see that plasma images are also a type of randomized gradient
of colors, and like "<CODE>gradient:</CODE>" started with white at the top and
black at the bottom. </P>

What isn't well document is that you can specify color for the plasma gradient
in the exact same way as you can for linear gradients above.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE RANDOM>
  convert -size 100x100  plasma:blue              plasma_range1.jpg
  convert -size 100x100  plasma:yellow            plasma_range2.jpg
  convert -size 100x100  plasma:green-yellow      plasma_range3.jpg
  convert -size 100x100  plasma:red-blue          plasma_range4.jpg
  convert -size 100x100  plasma:tomato-steelblue  plasma_range5.jpg
</CODE></PRE></TD></TR></TABLE>
<NOBR>
  <A HREF="plasma_range1.jpg"
     ><IMG SRC="plasma_range1.jpg"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="plasma_range2.jpg"
     ><IMG SRC="plasma_range2.jpg"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="plasma_range3.jpg"
     ><IMG SRC="plasma_range3.jpg"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="plasma_range4.jpg"
     ><IMG SRC="plasma_range4.jpg"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="plasma_range5.jpg"
     ><IMG SRC="plasma_range5.jpg"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
</NOBR>
</DIV></P>

You can also see that mid-tone colors like '<CODE>tomato</CODE>' and
'<CODE>steelblue</CODE>' tend to work better than pure colors like
'<CODE>red</CODE>' and '<CODE>blue</CODE>'. </P>

By using the same color twice with plasma you can produce a background that is
predominantly that color, but with random splotches of colors close to those
of the original colors.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE RANDOM>
  convert -size 100x100  plasma:black-black          plasma_black.jpg
  convert -size 100x100  plasma:grey-grey            plasma_grey.jpg
  convert -size 100x100  plasma:white-white          plasma_white.jpg
  convert -size 100x100  plasma:yellow-yellow        plasma_yellow.jpg
  convert -size 100x100  plasma:tomato-tomato        plasma_tomato.jpg
  convert -size 100x100  plasma:steelblue-steelblue  plasma_steelblue.jpg
</CODE></PRE></TD></TR></TABLE>
<NOBR>
  <A HREF="plasma_black.jpg"
     ><IMG SRC="plasma_black.jpg"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="plasma_grey.jpg"
     ><IMG SRC="plasma_grey.jpg"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="plasma_white.jpg"
     ><IMG SRC="plasma_white.jpg"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="plasma_yellow.jpg"
     ><IMG SRC="plasma_yellow.jpg"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="plasma_tomato.jpg"
     ><IMG SRC="plasma_tomato.jpg"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="plasma_steelblue.jpg"
     ><IMG SRC="plasma_steelblue.jpg"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</NOBR>
</DIV></P>

Again as you can see, mid-tone colors will generate more varieties of color in
the resulting image, than an extreme color, like black, white, or yellow.
</P>

The '<CODE>grey</CODE>' plasma in the above is particularly nice giving a
iridescent 'mother-of-pearl' like effect, basically as grey has total freedom
in the colors that the "<CODE>plasma:</CODE>" will generate. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

Normalizing a prefect 50% grey plasma will produce a particularly uniform
multi-color plasma image, over the full range of colors, including white and
black.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE RANDOM>
  convert -size 100x100  plasma:grey50-grey50 -auto-level plasma_grey_norm.jpg
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="plasma_grey_norm.jpg"
     ><IMG SRC="plasma_grey_norm.jpg"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

Alternatively you can just spread the contrast of the colors to just make
them bolder, but without going to extremes.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE RANDOM>
  convert -size 100x100  plasma:grey50-grey50 \
                       -sigmoidal-contrast 8x50%   plasma_grey_contrast.jpg
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="plasma_grey_contrast.jpg"
     ><IMG SRC="plasma_grey_contrast.jpg"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Compare this image with the 'fractal plasma' images below. </P>

<A NAME="plasma_fractal"></A>
<H3>Fractal Plasma</H3>

The plasma generator also has a special fractal mode, which produces highly
colorful effects.  The colors generated are enhanced to produce more
exaggerated color changes. </P>

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE RANDOM>
  convert -size 100x100  plasma:fractal  plasma_fractal1.jpg
  convert -size 100x100  plasma:fractal  plasma_fractal2.jpg
  convert -size 100x100  plasma:fractal  plasma_fractal3.jpg
</CODE></PRE></TD></TR></TABLE>
  <A HREF="plasma_fractal1.jpg"
     ><IMG SRC="plasma_fractal1.jpg"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="plasma_fractal2.jpg"
     ><IMG SRC="plasma_fractal2.jpg"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="plasma_fractal3.jpg"
     ><IMG SRC="plasma_fractal3.jpg"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

In fact this is very similar to the constant color plasma images we have
already seen, and in fact these are generated in the same way but with more
pronounced color changes. </P>

<BR>

I often find that plasma images are a little 'noisy'. As such they usually
will benefit from a little smoothing using "<CODE><A
HREF="../../../html/www/command-line-options.html#blur" >-blur</A></CODE>". </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>

Here I have have smoothed out the noise from the middle plasma image above.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert plasma_fractal2.jpg  -blur 0x2  plasma_smooth.jpg
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="plasma_smooth.jpg"
     ><IMG SRC="plasma_smooth.jpg"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>

You can use "<CODE><A HREF="../../../html/www/command-line-options.html#paint" >-paint</A></CODE>" to
create random blotches of color.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert plasma_fractal2.jpg  -blur 0x1 -paint 8  plasma_paint.jpg
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="plasma_paint.jpg"
     ><IMG SRC="plasma_paint.jpg"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>

Or make the colors more pronounced and circular using the "<CODE><A
HREF="../../../html/www/command-line-options.html#emboss" >-emboss</A></CODE>" image operator, after
using "<CODE><A HREF="../../../html/www/command-line-options.html#blur" >-blur</A></CODE>" to remove
the low level noise.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert plasma_fractal2.jpg  -blur 0x5 -emboss 2 plasma_emboss.jpg
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="plasma_emboss.jpg"
     ><IMG SRC="plasma_emboss.jpg"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>

By using a "<CODE><A HREF="../../../html/www/command-line-options.html#blur" >-blur</A></CODE>"
followed by a "<CODE><A HREF="../../../html/www/command-line-options.html#sharpen"
>-sharpen</A></CODE>" you can produce a more pastel color pattern than we
produced with "<CODE><A HREF="../../../html/www/command-line-options.html#emboss" >-emboss</A></CODE>".

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert plasma_fractal2.jpg  -blur 0x5 -sharpen 0x15 plasma_sharp.jpg
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="plasma_sharp.jpg"
     ><IMG SRC="plasma_sharp.jpg"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>


<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

I actually find generating a swirled plasma gradient to be particularly nice,
as a background pattern.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE RANDOM>
  convert -size 160x140  plasma:fractal \
          -blur 0x2  -swirl 180  -shave 20x20  plasma_swirl.jpg
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="plasma_swirl.jpg"
     ><IMG SRC="plasma_swirl.jpg"       WIDTH=120 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>


<A NAME="plasma_greyscale"></A>
<H3>Greyscale Plasma</H3>

Now the plasma generator will always generate color, even on a pure black
solid color. However it is often useful to generate a pure grey-scale plasma.
Well there are two simple ways of doing this. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>
The simplest way is to take the plasma image and converted it to grey scale.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE RANDOM>
  convert -size 100x100 plasma:fractal -blur 0x2 \
          -colorspace Gray   plasma_greyscale.jpg
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="plasma_greyscale.jpg"
     ><IMG SRC="plasma_greyscale.jpg"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR>

<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>
Another way is to copy one of the color channel over the other two, for a
stronger, single layer, effect.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE RANDOM>
  convert -size 100x100 plasma:fractal -blur 0x2 \
          -channel G -separate   plasma_grey_copy.jpg
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="plasma_grey_copy.jpg"
     ><IMG SRC="plasma_grey_copy.jpg"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR>

<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>
A final technique is to use "<CODE><A HREF="../../../html/www/command-line-options.html#shade"
>-shade</A></CODE>" on the plasma.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE RANDOM>
  convert -size 100x100 plasma:fractal -blur 0x5 \
          -shade 120x45  -auto-level  plasma_grey_shade.jpg
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="plasma_grey_shade.jpg"
     ><IMG SRC="plasma_grey_shade.jpg"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR>
</TABLE></P>

You'd probably think you would get a lot of light and shadow effects, but the
raw plasma is so random, that "<CODE><A HREF="../../../html/www/command-line-options.html#shade"
>-shade</A></CODE>" only seems to produce a more 'mottled plasma' effect. </P>

Instead of using a fractal plasma, with its highly exaggerated color changes,
you can create a grey-scale plasma using the constant color plasma method.  As
a side effect, this method also allows you to control the overall brightness
of the grey-scale plasma image generated.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE RANDOM>
  convert -size 100x100 plasma:black-black \
           -blur 0x2 -colorspace Gray plasma_grey0.jpg
  convert -size 100x100 plasma:grey25-grey25 \
           -blur 0x2 -colorspace Gray plasma_grey1.jpg
  convert -size 100x100 plasma:grey50-grey50 \
           -blur 0x2 -colorspace Gray plasma_grey2.jpg
  convert -size 100x100 plasma:grey75-grey75 \
           -blur 0x2 -colorspace Gray plasma_grey3.jpg
  convert -size 100x100 plasma:white-white   \
           -blur 0x2 -colorspace Gray plasma_grey4.jpg
</CODE></PRE></TD></TR></TABLE>
  <A HREF="plasma_grey0.jpg"
     ><IMG SRC="plasma_grey0.jpg"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="plasma_grey1.jpg"
     ><IMG SRC="plasma_grey1.jpg"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="plasma_grey2.jpg"
     ><IMG SRC="plasma_grey2.jpg"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="plasma_grey3.jpg"
     ><IMG SRC="plasma_grey3.jpg"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="plasma_grey4.jpg"
     ><IMG SRC="plasma_grey4.jpg"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

If this is not quite bold enough, use the channel copy method of grey-scaling
the plasma image.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE RANDOM>
  convert -size 100x100 plasma:black-black   \
          -blur 0x2  -channel G  -separate   plasma_grey5.jpg
  convert -size 100x100 plasma:grey25-grey25 \
          -blur 0x2  -channel G  -separate   plasma_grey6.jpg
  convert -size 100x100 plasma:grey50-grey50 \
          -blur 0x2  -channel G  -separate   plasma_grey7.jpg
  convert -size 100x100 plasma:grey75-grey75 \
          -blur 0x2  -channel G  -separate   plasma_grey8.jpg
  convert -size 100x100 plasma:white-white   \
          -blur 0x2  -channel G  -separate   plasma_grey9.jpg
</CODE></PRE></TD></TR></TABLE>
  <A HREF="plasma_grey5.jpg"
     ><IMG SRC="plasma_grey5.jpg"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="plasma_grey6.jpg"
     ><IMG SRC="plasma_grey6.jpg"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="plasma_grey7.jpg"
     ><IMG SRC="plasma_grey7.jpg"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="plasma_grey8.jpg"
     ><IMG SRC="plasma_grey8.jpg"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="plasma_grey9.jpg"
     ><IMG SRC="plasma_grey9.jpg"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

These grey-scale plasma images are very useful for further processing,
allowing you to generate other image effects. </P>

For example, look at the page on <A HREF="../backgrounds/index.html" >Background
Images</A> for a huge number of examples where the plasma fractal was used
to produce lots of interesting effects. </P>

<A NAME="plasma_seeded"></A>
<H3>Seeding or Repeating a Plasma Image</H3>

Remember "<CODE>plasma:</CODE>" can produce areas of near pure black or pure
white, or any other color (though it isn't likely to be pure).  And while it
is unlikely you will get an image that is all in one color, it is also a
possible outcome.  So when you get a good result you may like to save it, for
later re-use. </P>

Because of this, scripts using plasma images, may like to include options to
generate and re-use such randomized images.  That is you may like to separate
the plasma image generation from other parts that use that image, to allow
re-use.  </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

A simpler technique however is to 'seed' or initialize the IM random number
generator so that '<CODE>plasma:</CODE>' will generate the same 'randomized'
image.  That way you can tune a script or program to produce a good or
interesting coloration or effect, over and over.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 100x100 -seed 4321  plasma:    plasma_seeded.jpg
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="plasma_seeded.jpg"
     ><IMG SRC="plasma_seeded.jpg"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>
<!-- <CODE EXECUTE ASSERT>
  [ "`compare -metric PAE plasma_seeded.jpg \
                ../images/plasma_seeded.jpg null: 2>&1 |\
         sed 's/ .*//'`" != '0' ] &&  echo >&2 \
    "ASSERTION FAILURE: Seeded Plasma Image Changed\!"
  [ "`convert -size 100x100 -seed 1 plasma: -seed 1 plasma: miff:- | \
      compare -metric PAE - null: 2>&1 | sed 's/ .*//'`" != '0' ] && echo >&2 
\
    "ASSERTION FAILURE: Repeated Seeded Plasmas do not match\!"
</CODE> -->

The above image will never change, so unless I change the "<CODE><A
HREF="../../../html/www/command-line-options.html#seed" >-seed</A></CODE>" number I will always have a
'red' area in the bottom-right corner. </P>

Interestingly using the same seed with different initializing color gradients
can produce a set of images, which while random, are similar in their internal
pattern.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 100x100 -seed 4321 plasma:grey-grey         plasma_rnd1.jpg
  convert -size 100x100 -seed 4321 plasma:white-blue        plasma_rnd2.jpg
  convert -size 100x100 -seed 4321 plasma:green-yellow      plasma_rnd3.jpg
  convert -size 100x100 -seed 4321 plasma:red-blue          plasma_rnd4.jpg
  convert -size 100x100 -seed 4321 plasma:tomato-steelblue  plasma_rnd5.jpg
</CODE></PRE></TD></TR></TABLE>
<NOBR>
  <A HREF="plasma_rnd1.jpg"
     ><IMG SRC="plasma_rnd1.jpg"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="plasma_rnd2.jpg"
     ><IMG SRC="plasma_rnd2.jpg"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="plasma_rnd3.jpg"
     ><IMG SRC="plasma_rnd3.jpg"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="plasma_rnd4.jpg"
     ><IMG SRC="plasma_rnd4.jpg"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="plasma_rnd5.jpg"
     ><IMG SRC="plasma_rnd5.jpg"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</NOBR>
</DIV></P>

As you can see the same pattern of colors is present in all the above images,
though the underlying color base can highlight or obscure parts of the
shared pattern. </P>

Just one final word of warning. Other IM operators can also use the random
number generator, such as the "<CODE><A HREF="../../../html/www/command-line-options.html#fx"
>-fx</A></CODE>" '<CODE>rand()</CODE>' function, the "<CODE><A
HREF="../../../html/www/command-line-options.html#virtual-pixel" >-virtual-pixel</A></CODE>"
'<CODE>random</CODE>' setting the "<CODE><A
HREF="../../../html/www/command-line-options.html#random-threshold" >-random-threshold</A></CODE>"
dither operator, and the "<CODE><A HREF="../../../html/www/command-line-options.html#noise"
>-noise</A></CODE>" operator.  As such is a good idea to seed the generator
immediately before your specific use of the random number generator. </P>

As of IM v6.3.4-3, you can also re-randomize the generator using "<CODE><A
HREF="../../../html/www/command-line-options.html#seed" >+seed</A></CODE>".  So placing this setting
after your 'seeded plasma' will ensure that any later operators
correctly generate a randomized result if desired. </P>

By default the seed is randomized when IM starts, so you normally do not need
to randomize it yourself using "<CODE><A HREF="../../../html/www/command-line-options.html#seed"
>+seed</A></CODE>" to get a random result. </P>


<A NAME="plasma_problems"></A>
<H3>Problems using Plasma</H3>

One problem that you should avoid with "<CODE>plasma:</CODE>" images is 
generating
them with a high aspect ratio.  It tends to distort the normal plasma color
effects, pulling the colors out into needle-like streaks.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE RANDOM>
  convert -size 200x50 plasma:  plasma_high_aspect.jpg
</CODE></PRE></TD></TR></TABLE>
  <A HREF="plasma_high_aspect.jpg"
     ><IMG SRC="plasma_high_aspect.jpg"       WIDTH=200 HEIGHT=50
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>
There is no simple solution to this, so unless this is what you are wanting,
caution is advised. </P>

There is also a definite top-left to bottom-right diagonal warp in the plasma
image that should not exist.  That is there is some sort of 'spatial bias'
flaw in the algorithm. </P>

For example as Thomas Maus &lt;thomas.maus_AT_alumni.uni-karlsruhe.de&gt;
pointed out if you mirror and append the same plasma image, you will always
see a distinct 'V' in the resulting image...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE RANDOM>
  convert -size 60x60 plasma: \( +clone -flop \) +append plasma_flaw.jpg
</CODE></PRE></TD></TR></TABLE>
  <A HREF="plasma_flaw.jpg"
     ><IMG SRC="plasma_flaw.jpg"       WIDTH=120 HEIGHT=60
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

This should not happen. But the problem seems to be too deep to be able to fix
without basically completely re-writing the whole plasma generator function.
</P>

<HR><!-- ---------------------------------------------------------------- -->

<A NAME="random"></A>
<H2>Random Images</H2>


<A NAME="random_noise"></A>
<H3>Raw Random Noise</H3>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

As of IM v6.3.5 you can generate a purely random image from an existing image
using Noise Generator, "<CODE><A HREF="../../../html/www/command-line-options.html#noise"
>+noise</A></CODE>" method '<CODE>Random</CODE>'.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE RANDOM>
  convert -size 100x100 xc:   +noise Random   random.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="random.png"
     ><IMG SRC="random.png"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

If your IM is older than this you can still generate a pure random noise image
using the slower <A HREF="http://legacy.imagemagick.org/Usage/transform/#fx" >DIY FX Operator</A>, "<CODE><A
HREF="../../../html/www/command-line-options.html#fx" >-fx</A></CODE>".

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE RANDOM>
  convert -size 100x100 xc: -fx 'rand()'   random_fx.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="random_fx.png"
     ><IMG SRC="random_fx.png"       WIDTH=100 HEIGHT=100
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

Or for speed you can use the "<CODE><A HREF="../../../html/www/command-line-options.html#spread"
>-spread</A></CODE>" operator to randomize a gradient (separatally for the
three color channels) or by using some other image.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE RANDOM>
  convert -size 100x100 gradient: -separate \
          -virtual-pixel tile   -spread 200   -combine  random_spread.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="random_spread.png"
     ><IMG SRC="random_spread.png"       WIDTH=100 HEIGHT=100
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

The result may seem very random, but it will produce a more controlled range
of colors, (or just color values). </P>


<A NAME="random_specks"></A>
<H3>Random Specks (pixel dust)</H3>

Generating images of scattered random pixels can also be very useful. </P>.

just remember that each of the three <A HREF="../color_basics/index.html#channels"
>Color Channels</A> of a random image can be thought of as separate random
gray-scale image and these channels can be merged together in various ways.
</P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

For example you generate a mask of random dots by first  <A
HREF="../quantize/index.html#threshold" >Thresholding</A> a color channel
('<CODE>G</CODE>' or the green channel), and separating it out as a gray-scale
image.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert random.png  -channel G -threshold 5% -separate \
          +channel -negate    random_mask.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="random_mask.png"
     ><IMG SRC="random_mask.png"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

As each color is a linearly random value, the threshold percentage used in the
above directly defines the density of pixels selected. </P>

You can go further and use one color color channel ('<CODE>G</CODE>' or green
channel) to select random values from another color channel channel
('<CODE>R</CODE>' or red channel), by using various <A
HREF="../compose/index.html#compose" >Image Composition</A> methods.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert random.png   -channel G -threshold 5% -negate \
          -channel RG -separate +channel \
          -compose Multiply    -composite   random_black.png
  convert random.png   -channel G -threshold 5% \
          -channel RG -separate +channel \
          -compose Screen      -composite   random_white.png
  convert random.png   -channel G -threshold 5% -negate \
          -channel RG -separate +channel \
          -compose CopyOpacity -composite   random_trans.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="random.png"
     ><IMG SRC="random.png"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="=>">
  <A HREF="random_black.png"
     ><IMG SRC="random_black.png"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="random_white.png"
     ><IMG SRC="random_white.png"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="random_trans.png"
     ><IMG SRC="random_trans.png"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

These types of images are directly usable to generate <A
HREF="../anim_mods/index.html#glitter" >Glitter Animations</A>.  But further processing,
particularly on the black background version, will let you enlarge the dots
based on their gray-scale intensity or generate streaks and or star flares
from those dots.  For examples see <A HREF="../advanced/index.html#stars" >Star
Generators</A>. </P>

<!-- <CODE EXECUTE ASSERT>
  [ "`convert -size 100x100 xc: -seed 11 +noise Random \
                      \( +clone -seed 11 +noise Random \) miff:- | \
      compare -metric PAE - null: 2>&1 | sed 's/ .*//'`" != '0' ] && echo >&2 
\
    "ASSERTION FAILURE: Seeded Random Images do not match"
</CODE> -->

Like <A HREF="index.html#plasma_seeded" >Seeded Plasma Images</A> you can also use the
"<CODE><A HREF="../../../html/www/command-line-options.html#seed" >-seed</A></CODE>" setting to
pre-initialise the random number generator.  This allows you to generate the
same random image(s) repeatably for a particular machine, just as you can for
plasma images. </P>

<A NAME="random_blur"></A>
<H3>Blurred Random Images (random blobs)</H3>

Now while you can make direct use of random images to create speckled effects,
purely random images are generally not very useful. But by <A
HREF="../blur/index.html#blur" >Blurring</A> a purely random image you will introduce
some 'neighbourhood' order, such that nearby pixels become related. </P>

For example, here I blur just one random image, causing the random values to
produce larger 'blobs' or mottled colors.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert random.png -virtual-pixel tile  -blur 0x1  -auto-level  random_1.png
  convert random.png -virtual-pixel tile  -blur 0x3  -auto-level  random_3.png
  convert random.png -virtual-pixel tile  -blur 0x5  -auto-level  random_5.png
  convert random.png -virtual-pixel tile  -blur 0x10 -auto-level  
random_10.png
  convert random.png -virtual-pixel tile  -blur 0x20 -auto-level  
random_20.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="random.png"
     ><IMG SRC="random.png"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="=>">
  <A HREF="random_1.png"
     ><IMG SRC="random_1.png"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="random_3.png"
     ><IMG SRC="random_3.png"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="random_5.png"
     ><IMG SRC="random_5.png"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="random_10.png"
     ><IMG SRC="random_10.png"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="random_20.png"
     ><IMG SRC="random_20.png"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

Note however without the <A HREF="../misc/index.html#virtual-pixel" >Virtual Pixel
Setting</A> the "<CODE><A HREF="../../../html/www/command-line-options.html#blur" >-blur</A></CODE>"
operator will have strong edge effects, which are best avoided. </P>

As a bonus by changing the "<CODE><A HREF="../../../html/www/command-line-options.html#virtual-pixel"
>-virtual-pixel</A></CODE>" setting to '<CODE>tile</CODE>', the randomised
image remains tilable, with the colors wrapping across the image boundaries.
This tiling ability is something that currently not possible with a random  <A
HREF="index.html#plasma" >Plasma Images</A> and is an inherent result of pure random
images being so random to start with. </P>

<A NAME="random_hue"></A>
<B>Blurred Random Hues</B></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

One particular conversion of a blurred random noise image that I found
particularly pleasing is to map the values into HSB color hues.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE RANDOM>
  convert random_10.png -set colorspace HSB \
          -channel GB -evaluate set 100% +channel \
          -colorspace RGB random_hues_cyan.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="random_hues_cyan.png"
     ><IMG SRC="random_hues_cyan.png"       WIDTH=100 HEIGHT=100
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

The problem with the above is that the blur will tend to create spots of
red-yellow (low values) and red-magenta (high values), with bands of green,
cyan and blues, in between them. This is simply a consequence of the way the
hue values were blurred and leveled. </P>

The ideal solution to this would be a type of modulus-blur, that would take
into account the cyclic nature of the Hue values.  However such an operator is
not currently available, and perhaps never will. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

The best solution I know of is to simply add all three random channels in the
image (using <A HREF="../compose/index.html#modulusadd" >Modulus-Add Composition</A>) so
as to extend the range of values.  This also have a side effect of making the
blurred spots smaller, but at least you now get a more dynamic range rainbow
colors. <I>Anyone got a better idea?</I>

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE RANDOM>
  convert random_10.png -separate -background white \
          -compose ModulusAdd -flatten -channel R -combine +channel \
          -set colorspace HSB -colorspace RGB random_hues.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="random_hues.png"
     ><IMG SRC="random_hues.png"       WIDTH=100 HEIGHT=100
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

For more methods of processing a random images, see <A HREF="index.html#plasma" >Plasma
Images</A> above, as well as <A HREF="../backgrounds/index.html" >Generating
Backgrounds</A>. </P>

<A NAME="random_grayscale"></A>
<B>Blurred Random Grays</B></P>

As you can see from the above you get an image with various blobs of primary
colors.  That is because each channel is being processed completely
separately to each other as gray-scale images. </P>

Lets extract one of the channels of each of the above image so you can see the
structure of the blurred image...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert random.png     -channel G  -separate   random_0_gray.png
  convert random_1.png   -channel G  -separate   random_1_gray.png
  convert random_3.png   -channel G  -separate   random_3_gray.png
  convert random_5.png   -channel G  -separate   random_5_gray.png
  convert random_10.png  -channel G  -separate   random_10_gray.png
  convert random_20.png  -channel G  -separate   random_20_gray.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="random_0_gray.png"
     ><IMG SRC="random_0_gray.png"      WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="random_1_gray.png"
     ><IMG SRC="random_1_gray.png"      WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="random_3_gray.png"
     ><IMG SRC="random_3_gray.png"      WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="random_5_gray.png"
     ><IMG SRC="random_5_gray.png"      WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="random_10_gray.png"
     ><IMG SRC="random_10_gray.png"     WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="random_20_gray.png"
     ><IMG SRC="random_20_gray.png"     WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

The first thing that you should notice is that the image will generally (but
not always) contain roughly equal amounts of both black and white areas.  You
can see this if we <A HREF="../quantize/index.html#threshold" >Threshold</A> the random
images at 50%

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert random_0_gray.png   -threshold 50%   random_0_thres.png
  convert random_1_gray.png   -threshold 50%   random_1_thres.png
  convert random_3_gray.png   -threshold 50%   random_3_thres.png
  convert random_5_gray.png   -threshold 50%   random_5_thres.png
  convert random_10_gray.png  -threshold 50%   random_10_thres.png
  convert random_20_gray.png  -threshold 50%   random_20_thres.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="random_0_thres.png"
     ><IMG SRC="random_0_thres.png"      WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="random_1_thres.png"
     ><IMG SRC="random_1_thres.png"      WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="random_3_thres.png"
     ><IMG SRC="random_3_thres.png"      WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="random_5_thres.png"
     ><IMG SRC="random_5_thres.png"      WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="random_10_thres.png"
     ><IMG SRC="random_10_thres.png"     WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="random_20_thres.png"
     ><IMG SRC="random_20_thres.png"     WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

As you can see you get approximately 50% white and 50% black areas, separated
by a curvy line.  Also the curve of this line varies according to the
'<I>sigma</I>' value used for the blurring of the purely random image.  From
individual pixels generating a black and white 'snow' until you get a very
uniform (though still random) separation of the image into two black and white
areas. </P>

For more examples of using random images, see  <A HREF="../backgrounds/index.html"
>Background Images</A> or to have a look at generating randomised canvases,
see <A HREF="../misc/index.html#spots" >Random Spots of Solid Color</A>. </P>


<A NAME="granularity"></A>
<H3>Random Granularity (order in the chaos)</H3>

Now remember all the blurred random images were generated from the same
initial random image, thus they are all related. But every new random image
generated will have a completely different pattern, though the patterns will
more or less look similar in structure. </P>


<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>

But first lets give a full example of generating a 'blured random image'
from scratch...

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE ALREADY_EXECUTED>
  convert -size 100x100 xc:  -channel G +noise Random \
         -virtual-pixel Tile -blur 0x5 -auto-level \
          -separate +channel   random_5_gray.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="random_5_gray.png"
     ><IMG SRC="random_5_gray.png"       WIDTH=100 HEIGHT=100
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

The heavy use of the "<CODE><A HREF="../../../html/www/command-line-options.html#channel"
>-channel</A></CODE>"
setting to limit operations to the 'Green' channel of the image is important
as it speeds up the overall generation of the image by a factor of 3.
The <A HREF="http://legacy.imagemagick.org/Usage/channel/#separate" >Channel separate</A> will then ensure we
get a pure grayscale result. </P>

If you want you could leave out both "<CODE><A
HREF="../../../html/www/command-line-options.html#channel" >-channel</A></CODE>" settings, which will
result in the generation of 3 completely separate and different 'Blurred
Random Images'. </P>

The image has some important characteristics, which we can see more clearly if
we divide the image up into three  equal sets of colors (using a technique
called <A HREF="../quantize/index.html#posterize" >Posterization</A>), you can see that
inside each of the black and white zones you get more circle blobs or
'granules'.  </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>

For example...

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert random_5_gray.png  -ordered-dither threshold,3  random_5_blobs.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="random_5_blobs.png"
     ><IMG SRC="random_5_blobs.png"       WIDTH=100 HEIGHT=100
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

First I would like to point out how we get roughly equal amounts of light and
dark areas within the image, but that those areas are interconnected by the
grey 'middle' colors of the gradient that forms between the light and dark
areas. </P>

Now the individual blobs or 'granules' varies from area to area across the
image, but they all roughy average at about a diameter of about <I>three to
four times</I> the value used to blur the initial random image. </P>

This blur value is known as the '<I>granularity</I>' of the image is a very
important value, as it basically represents the average size of the circular
structures the random image produces. </P>

Some times it is called the 'curviness' of the image.  The larger the value
the larger and slower these curves are within the image.  </P>

This is the most important factor describing a Blurred Random image, so lets
make it very clear...

<DIV ALIGN=center><B>
    The '<I>Granularity</I>' of a random image (or blur factor)
<BR>   determines the size of the circular structures within
</B></DIV></P>

Of course the smaller the 'blur factor' or '<I>Granularity</I>', the smaller
or tighter the curves become, until you reach a value of '<CODE>0</CODE>', at
which point, all the clumping or 'blobs' within the image vanishes, and you
are least with a purely random 'noise', 'snow', or 'pixel dust' type of
effect. </P>

<BR>

ASIDE: Actually the size of the actual 'granules' themselves can vary
depending on the threshold factor used to generate them.  What the factor
really describes is the average distance between centers of the white and
black areas.  The larger the value the larger the distance, and the larger and
more spread out the spots have to be to accomidate that increased distance.
</P>

This becomes more obvious when we start looking at <A HREF="index.html#random_ripples"
>Random Ripples</A> below. </P>

<BR>

You may also like to try using a 50% <A HREF="../color_mods/index.html#solarize"
>Solarize</A> operation with some extra <A HREF="../color_mods/index.html#levels"
>Level Adjustments</A> to extract both the well separated black and white
granules from the image. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

For example, here is a full example with a granularity of '<CODE>8</CODE>' and
a blob threshold of '<CODE>25%</CODE>' generating white spots from both black
and white parts of the image.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE RANDOM>
  convert -size 100x100 xc: -channel G +noise random \
          -virtual-pixel tile -blur 0x8 -auto-level  \
          -solarize 50% -separate +channel \
          -threshold 25% -negate   random_granules.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="random_granules.png"
     ><IMG SRC="random_granules.png"       WIDTH=100 HEIGHT=100
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Be warned that as the value gets larger, the time to generate the blurred
random image also gets much much longer.  Also when the value reaches about
half that of the size of the smallest image dimension, the effect stops
growing as the random image settles into a single white and black spot. Large
values are not recommended. </P>

  <A HREF="animated_granularity.gif"
     ><IMG SRC="animated_granularity.gif"       WIDTH=150 HEIGHT=150
            ALIGN=left VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>

To finish with, to the left is shown a <A HREF="../anim_mods/index.html#patrol" >Patrol
Cycle Animation</A> resulting from varying the 'granularity' (random blurring)
of a single random image. The animation was generated using the shell script
"<CODE><A HREF="animate_granularity" >animate_granularity</A></CODE>", which
you can download, study and play with.  </P>

Note that as the same random image is used as a source the 'granules' or spots
do not really move, but just sort of grow together, or fade away, so as to
produce larger 'granules' with increasing granularity.  </P>

Also remember that while I have reduced the number of colors in the animation,
the structure of the full random image is actually smooth gradient between two
sets of white and black granules.  This gradient is what makes the image
useful in other techniques. </P>

<A NAME="random_flux"></A>
<H3>Random Flux (animation cycles)</H3>

Now as you saw above the granules or spots do not actually move all that much.
But for animation effects you want a pattern that moves smoothly in time.
Also you don't want that pattern to just simply move back and forth.  And
finally, you do not want that pattern of movements to suddenly jump or jerk as
the animation loops. </P>

So what we need is some way to generate a smoothly repeating random pattern. A
tall order. Also as you need it to be smooth, you will need to generate all
the patterns from the same single random image.  </P>

Here is an idea that allows you to generate such a random pattern. </P>

Rather than think of each random pixel value as being a random intensity, we
instead think of that value being a 'time' value defining when that pixel is
at its maximum or minimum intensity.  That is, we convert that value into
a position on a 'wave'. Thus each pixel represents some 'phase' of a sine
curve. </P>

This sounds complicated, but in reality it isn't.  We just use the <A
HREF="index.html#random" >Random Image</A> as a source image for a <A
HREF="http://legacy.imagemagick.org/Usage/transform/#function_sinusoid" >Sinusoid Function</A>.  Now for each
image in the time sequence we set the time '<I>phase</I>' for that particular
point in the time cycle.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE DO_NOT_EXECUTE>
  convert random.png   -function Sinusoid 1,<I>{time}</I> \
          ... do granular blurring,  and other processing ...
</CODE></PRE></TD></TR></TABLE>
</DIV>

Where '<CODE><I>{time}</I></CODE>' goes from '<CODE>0</CODE>' to
'<CODE>360</CODE>' over the complete animation cycle. </P>

The result is that instead of each pixel having a 'static' random value, we
now have one that cycles in a loop between black and white over a period of
time.  Each pixel will follow this same cycle, but as each pixel has
a completely different 'phase', and will cycle independently of all the other
pixels.  That is, the image is still random, but smoothly changing with the
provided 'time' value. </P>

For the scientifically minded this is a bit like looking at the 'quantum flux'
that exists at sub-atomic level, where space is far from the 'static' state we
see at normal scales.  Hence the name '<B>Random Flux</B>'. </P>

For example lets generate a time sequence of 12 images...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE SCRIPT>
  for i in `seq 0 30 359`; do
    convert random.png  -channel G  -function Sinusoid 1,${i} \
            -virtual-pixel tile -blur 0x8 -auto-level \
            -separate flux_${i}.png
  done
</CODE></PRE></TD></TR></TABLE>
<TABLE CELLSPACING=0 CELLPADDING=0>
<TR VALIGN=middle><TD>
  <A HREF="flux_0.png"
     ><IMG SRC="flux_0.png"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
</TD><TD><NOBR>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="=>">
  <A HREF="flux_30.png"
     ><IMG SRC="flux_30.png"      WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="flux_60.png"
     ><IMG SRC="flux_60.png"      WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="flux_90.png"
     ><IMG SRC="flux_90.png"      WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="flux_120.png"
     ><IMG SRC="flux_120.png"     WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
</NOBR></TD><TD>
  <A HREF="flux_150.png"
     ><IMG SRC="flux_150.png"     WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
</TD></TR>
<TR><TD ALIGN=center>
  <IMG SRC="../img_www/up.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="=>">
</TD><TD></TD><TD ALIGN=center>
  <IMG SRC="../img_www/down.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="=>">
</TD></TR>
<TR VALIGN=middle><TD><NOBR>
  <A HREF="flux_330.png"
     ><IMG SRC="flux_330.png"      WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
<TD>
  <A HREF="flux_300.png"
     ><IMG SRC="flux_300.png"      WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="flux_270.png"
     ><IMG SRC="flux_270.png"      WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="flux_240.png"
     ><IMG SRC="flux_240.png"      WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="flux_210.png"
     ><IMG SRC="flux_210.png"      WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/left.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="=>">
</NOBR></TD><TD>
  <A HREF="flux_180.png"
     ><IMG SRC="flux_180.png"      WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE>
</DIV>
And your one random image can now generates a whole sequence images forming a
cycle. </P>

Note that the 'time' extraction has to happen before any other processing such
as blurring, which is probably the slowest part of the whole generation
process. </P>

The other thing to notice is that at phase '<CODE>180</CODE>' (bottom right),
you actually get the exact negative of the first image (top-left).  That is
'white' granules has become 'black' granules, and visa-versa.  In fact the
whole second half of the animation is actually the negative of the first half.
This can be used to cut down the generation time of a simple 'Random Flux'
animation. </P>

Because the image is a negative at a 180 degree phase, you will find that each
'white' granule slowly moves so as to swap places with a neighbouring 'black'
granule.  But as the whole second half is a negative of the first the it can't
just simply shuffle back-and-forth, but must continue move forward to return
to the original image, or circle around in a loop, or simply fade and appear
appropriatally. </P>

In other words the white and black granules move in far more complex cycle.
</P>


<!-- <CODE EXECUTE>
  convert flux_{?,??,???}.png -set delay 20 -loop 0 flux_anim.gif
</CODE> -->
  <A HREF="flux_anim.gif"
     ><IMG SRC="flux_anim.gif"      WIDTH=100 HEIGHT=100
           ALIGN=right VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>

To the right is an animation of the above frames... </P>

The fluctuating pattern is completely random, but smoothly changing from frame
to frame, and when the animation loops.  You can see no beginning or end to
the result.  Sometimes you will get a swirling of movement, other times it
looks like all the 'gas' like blobs are being sucked into a dark zone, or just
appearing and fading away again.  You also get periods of very fast movements,
as well as very slow movements.  It is totally random. </P>

<B>In summary</B>: The same properties present in <A HREF="index.html#random" >Blurred
Random Images</A> are also present in this animation.  The image remains a
roughly equal division between white and black segments, and it forms blobs of
about <I>three times</I> the size of the blur or <A HREF="index.html#granularity"
>Granularity</A> of the image.  But on top of this you are guarantied that all
parts of the image will form some cycle between both lighter and darker
colors, as half the cycle is the negative of the other half.  </P>

One thing you may not have noticed is that due to the conversion of a random
linear value into a sinusoid waveform, you will get a sharper white and black
separation of colors (contrast).  As such you may like to use the
de-contrasting aspect of <A HREF="../color_mods/index.html#sigmoidal" >Sigmoidal
Contrast</A> operator to make the resulting image less 'blob' like, and
enhance the gradient between the granules, rather than the granules
themselves. </P>

Now this is only a starting point for what you can do with a cyclic random
animation.  Everything that you can do with a <A HREF="index.html#random" >Random
Image</A>, such as described in  <A HREF="../backgrounds/index.html"
>Generating Backgrounds</A>, can also be applied to '<I>Random Flux
Animation</I>' </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>

For example, lets just show the movement of just the 'white' granules...

<!-- <CODE EXECUTE>
  convert flux_{?,??,???}.png -threshold 70% \
          -set delay 20 -loop 0 flux_thres_anim.gif
</CODE> -->
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTED_ABOVE>
  convert flux_anim.gif -threshold 70% flux_thres_anim.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="flux_thres_anim.gif"
     ><IMG SRC="flux_thres_anim.gif"       WIDTH=100 HEIGHT=100
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Or generate changing electrical filaments that slowly flow over the image.

<!-- <CODE EXECUTE>
  convert flux_{?,??,???}.png \
          -sigmoidal-contrast 30x50% -solarize 50% -auto-level \
          -set delay 20 -loop 0 filaments_anim.gif
</CODE> -->
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTED_ABOVE>
  convert flux_anim.gif  \
          -sigmoidal-contrast 30x50% -solarize 50% -auto-level \
          -set delay 20 filaments_anim.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="filaments_anim.gif"
     ><IMG SRC="filaments_anim.gif"       WIDTH=100 HEIGHT=100
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Note that due to fact that half the cycle is a negation of the first half and
we use a <A HREF="../color_mods/index.html#solarize" >Solarize</A> to fold the white and
black colors in half, the cycle is actually repeating twice over one animation
cycle.  It really needs a lot more frames to remove some of very fast changes
that is taking place. </P>

<BR>

To make the motion less predictable for a longer cyclic sequence, you can also
use some <A HREF="http://legacy.imagemagick.org/Usage/transform/#gradient_math" >Gradient Math</A> to combine
multiple Sinusoidal Cycles, from multiple random images, or even just using
the other color channels of the same random image. </P>

<PRE>FUTURE: Create even less predictable, long time 'harmonic' cycles. </PRE>

<A NAME="random_ripples"></A>
<A NAME="frequency"></A>
<H3>Random Ripples</H3>

By adding another variation to a <A HREF="index.html#random_blur" >Blurred Random
Image</A> we can add another level of complexity that makes these images
far more useful, and gives use another control variable beyond its <A
HREF="index.html#granularity" >Granularity</A>. </P>

But first you need to remember that the random image does not consist of just
bright and dark areas, but also contains a slope between those areas. Using
that slope as into to the <A HREF="http://legacy.imagemagick.org/Usage/transform/#function_sinusoid" >Sinusoid
Function</A>, you can generate ripples between the spots in the image. </P>

Note that key difference to this use of the <A
HREF="http://legacy.imagemagick.org/Usage/transform/#function_sinusoid" >Sinusoid Function</A> to the previous
<A HREF="index.html#random_flux" >Random Flux</A> examples was that this time the
function is being applied to the image AFTER it was smoothed using blur,
instead of before.  Also in this case it is the '<I>Frequency</I>' value, and
not the second '<I>Phase</I>' value that is more important. </P>

For example...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert random_10_gray.png  -function Sinusoid 1,90   ripples_1.png
  convert random_10_gray.png  -function Sinusoid 2,90   ripples_2.png
  convert random_10_gray.png  -function Sinusoid 3,90   ripples_3.png
  convert random_10_gray.png  -function Sinusoid 4,90   ripples_4.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="random_10_gray.png"
     ><IMG SRC="random_10_gray.png"      WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="=>">
  <A HREF="ripples_1.png"
     ><IMG SRC="ripples_1.png"     WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="ripples_2.png"
     ><IMG SRC="ripples_2.png"     WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="ripples_3.png"
     ><IMG SRC="ripples_3.png"     WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="ripples_4.png"
     ><IMG SRC="ripples_4.png"     WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

As you can see the larger the '<I>Frequency</I>' of the <A
HREF="http://legacy.imagemagick.org/Usage/transform/#function_sinusoid" >Sinusoid Function</A>, the more
ripples are being added into the gradient between the 'granules'. </P>

A '<I>Frequency</I>' of '<CODE>1</CODE>' will basically convert both the Light
and Dark 'blobs' in the source image to white, and leave a dark gap between
them.  A '<I>Frequency</I>' of '<CODE>2</CODE>' squeezes an extra 'ridge' or
'ripple' in that dark gap.  As the frequency increases you get more and more
'ripples' between the lightest and darkest areas of the original image, making
it more an more complex. </P>

As the number of ridges increases, you can lose sight of the original 'blobs'
or 'granules' in the image. You can fix this by modifying the gradient before
adding the ripples, either by 'clipping' the gradient using a <A
HREF="../color_mods/index.html#level" >Level Adjustment</A>, or compress the midtones
using <A HREF="../color_mods/index.html#sigmoidal-contrast" >Sigmoidal Contrast</A>.
This will give the 'granules' some mass or area, providing areas of 'calm'
between the ripples. </P>

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert random_10_gray.png        -level 25%            random_enhanced.png
  convert random_enhanced.png  -function Sinusoid 4,90    ripples_4e.png
  convert random_10_gray.png   -sigmoidal-contrast 10,50% random_sigmoidal.png
  convert random_sigmoidal.png -function Sinusoid 4,90    ripples_4s.png
</CODE></PRE></TD></TR></TABLE>
<TABLE CELLSPACING=0 CELLPADDING=0><TR>
<TD ROWSPAN=2>
  <A HREF="random_10_gray.png"
     ><IMG SRC="random_10_gray.png"      WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="=>">
</TD><TD>
  <A HREF="random_enhanced.png"
     ><IMG SRC="random_enhanced.png"     WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="=>">
  <A HREF="ripples_4e.png"
     ><IMG SRC="ripples_4e.png"     WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
</TD></TR><TR><TD>
  <A HREF="random_sigmoidal.png"
     ><IMG SRC="random_sigmoidal.png"     WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="=>">
  <A HREF="ripples_4s.png"
     ><IMG SRC="ripples_4s.png"     WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE>
</DIV></P>

Both methods have advantages and disadvantages, but in essence they will
enlarge granules, though not the distance between the white and black sets of
granules.  The side effect of this is of course a compression the ripples
between the two sets of granules. </P>

<BR>

The second value '<CODE>90</CODE>' used above examples is the '<I>Phase</I>'
of the <A HREF="http://legacy.imagemagick.org/Usage/transform/#function_sinusoid" >Sinusoid Function</A>.  It
will determine the color that the 'black' granule in the source image will
become in the 'rippled' image. </P>

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert random_enhanced.png  -function Sinusoid 3,0     ripples_3e000.png
  convert random_enhanced.png  -function Sinusoid 3,90    ripples_3e090.png
  convert random_enhanced.png  -function Sinusoid 3,180   ripples_3e180.png
  convert random_enhanced.png  -function Sinusoid 3,270   ripples_3e270.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="random_enhanced.png"
     ><IMG SRC="random_enhanced.png"      WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="=>">
  <A HREF="ripples_3e000.png"
     ><IMG SRC="ripples_3e000.png"     WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="ripples_3e090.png"
     ><IMG SRC="ripples_3e090.png"     WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="ripples_3e180.png"
     ><IMG SRC="ripples_3e180.png"     WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="ripples_3e270.png"
     ><IMG SRC="ripples_3e270.png"     WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

The color of the 'white' granule, will depend on both the '<I>Phase</I>', and
the fraction of the '<I>Frequency</I>' that use applied. An integer
'<I>Frequency</I>' value will cause both white and black granules to vary in
color together (according to the '<I>Phase</I>').  as such with a pahse of
'<CODE>90</CODE>' both will be white. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR ALIGN=bottom><TD WIDTH=100% ALIGN=justify>

However if you apply a fractional '<I>Frequency</I>' value of say
'<CODE>0.5</CODE>', the 'white source' granule, will be the negative of the
'black source' granule (as determined by the '<I>Phase</I>').

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert random_enhanced.png  -function Sinusoid 3.5,90    ripples_3.5e.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="ripples_3.5e.png"
     ><IMG SRC="ripples_3.5e.png"       WIDTH=100 HEIGHT=100
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Note for the 'gray' '<I>Phase</I> angles, one of granules is surrounded by
a white ring, while the other is surrounded by a black ring.  If
a '<I>Frequency</I>' value with a '<CODE>0.5</CODE>' fraction is used, the
first ripple around each spot will be all white or all black, depending on the
'<I>Phase</I>' used. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  Other 'Frequencies' other than integers, or '<CODE>0.5</CODE>' are not
  recommended as the two sets of granules will not be synchronized in some
  way. </P>

  Similarly Phases other multiple of 90 degrees are not recommended unless
  generating a 'ripple animation' (see below). </P>

  A Phase value of '<CODE>0</CODE>' is recommended when generating
  a 'Dispersion Maps' (see below) as this will cause minimal distortions
  within the enhanced 'granule' areas.

</I></FONT></TD></TR></TABLE></P>

As previously in <A HREF="index.html#random_flux" >Random Flux</A>, you can modify the
'<I>Phase</I>' with time so as to generate an animation of the ripples moving
from one set of granules to the other.  This works particularly well without
any contrast enhancement.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE SCRIPT IMAGE=ripples_anim.gif>
  for i in `seq 0 30 359`; do
    convert random_10_gray.png -function Sinusoid 3.5,${i} miff:-
  done |
    convert miff:- -set delay 15 -loop 0 ripples_anim.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="ripples_anim.gif"
     ><IMG SRC="ripples_anim.gif"       WIDTH=100 HEIGHT=100
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

ASIDE: the technique used in the above is known as a "Pipelined <A
HREF="../files/index.html#miff" >MIFF:</A>" and is possible as the <A
HREF="../files/index.html#miff" >MIFF:</A>" file format can simply 'concatenate' images
to generate a multiple image file. </P>

One point is that the animation seem to change much much slower than a
<A HREF="index.html#random_flux" >Flux Animation</A> we created above. That is because
over the one animation cycle a ripple will only travel a short distance, where
in a 'flux' animation thge change will travel from the large scale white to
black granules in just half the cycle and back again. </P>


Now you can combine the above ripple animation with an underlying 'flux'
animation from the same random image source to generate a much more dynamic
and flowing form, but be warned of that animation speed difference. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>

For example here I just take the previous <A HREF="index.html#random_flux" >Flux
Animation</A> created above, and add ripples to it.  The ripples will in this
case move only because the gradient in the flux animation moves.

<!-- <CODE EXECUTE>
  convert flux_{?,??,???}.png -function Sinusoid 3.5,0 \
          -set delay 20 -loop 0  flux_rippled_anim.gif
</CODE> -->
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTED_ABOVE>
  convert flux_anim.gif -function Sinusoid 3.5,0 flux_rippled_anim.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="flux_rippled_anim.gif"
     ><IMG SRC="flux_rippled_anim.gif"       WIDTH=100 HEIGHT=100
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

You can also animate the ripples within the animation. Though you may need to
use a much larger 'phase cycle rate' (the 'j = 5 * i' expression) for the
ripples themselves.  Also as you are generating a cycle within a cycle, you
will need to generate a much longer animation 60 frames in this case. However
that has the benefit of slowing the larger 'flux' movements down too.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE SCRIPT IMAGE=ripples_flux_anim.gif>
  for i in `seq 0 10 359`; do
    j=`expr $i \* 5`
    convert random.png -channel G \
            -function Sinusoid 1,${i} \
            -virtual-pixel tile -blur 0x8 -auto-level \
            -function Sinusoid 2.5,${j} \
            -separate +channel miff:-
  done |
    convert miff:- -set delay 15 -loop 0 ripples_flux_anim.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="ripples_flux_anim.gif"
     ><IMG SRC="ripples_flux_anim.gif"       WIDTH=100 HEIGHT=100
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Note in the second image how ripples seem to first come out from one point,
then later they start back going into the same point, though they never just
simply reverse direction. A better multi-cycled flux cycle generator should
remove this slight weirdness by removing the 'negative' effect in the flux
underlying flux animation.  </P>

<BR>

<I>FUTURE: Use of Rippled Random Images for Dispersion Mapped Distortions</I>.
</P>


<HR><!-- ---------------------------------------------------------------- -->

<A NAME="tile"></A>
<H2>Tiled Canvases</H2>

Tile images can be very large or very small, are designed to fit together
side-by-side and vertically to cover large areas of space. </P>

Thanks to the World Wide Web, there as been an explosion of tile images
available for use (finding what you want is another matter).  Below are a set
of tiled images which I copied from <A
HREF="http://www.ict.griffith.edu.au/anthony/icons/" >Anthony's Icon 
Library</A>
for use through out these example pages.

<TABLE ALIGN=center>
<TR VALIGN=bottom>
<TD ALIGN=center>
  <A HREF="../images/bg.gif"
     ><IMG SRC="../images/bg.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR>bg.gif
<TD ALIGN=center>
  <A HREF="../images/tile_aqua.jpg"
     ><IMG SRC="../images/tile_aqua.jpg"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR>tile_aqua.jpg
<TD ALIGN=center>
  <A HREF="../images/tile_water.jpg"
     ><IMG SRC="../images/tile_water.jpg"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR>tile_water.jpg
<TD ALIGN=center>
  <A HREF="http://legacy.imagemagick.org/Usage/canvas/rings.jpg"
     ><IMG SRC="http://legacy.imagemagick.org/Usage/canvas/rings.jpg"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR>rings.jpg
<TD ALIGN=center>
  <A HREF="../images/tile_disks.jpg"
     ><IMG SRC="../images/tile_disks.jpg"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR>tile_disks.jpg
<TD ALIGN=center>
  <A HREF="../images/tile_weave.gif"
     ><IMG SRC="../images/tile_weave.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR>tile_weave.gif
</TR></TABLE></P>

Currently there are quite a number of way in which you can tile an image, over
a large area. </P>

You can "<CODE><A HREF="../../../html/www/command-line-options.html#tile" >-tile</A></CODE>" any image 
so
as to completely replace the original background image (using the
"<CODE>Copy</CODE>" compose operator).  (For more details see <A
HREF="../compose/index.html#tile" >Tile Compositing</A>).

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  composite -tile tile_weave.gif -size 60x60  xc:none   tile_copy.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="tile_copy.gif"
     ><IMG SRC="tile_copy.gif"       WIDTH=60 HEIGHT=60
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>


<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>
Another way is to read in the tile image using the "<CODE>tile:</CODE>" coder,
and tile it to a specific size.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 60x60 tile:bg.gif  tile_size.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="tile_size.gif"
     ><IMG SRC="tile_size.gif"       WIDTH=60 HEIGHT=60
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  Note that the "<CODE>tile:</CODE>" coder will replace any transparency
  in the image with the current background color.  That is because internally
  it generates a canvas of the size requested and 'overlays' the tiling image
  onto that canvas. </P>

  If you want to preserve transparency either set "<CODE>-background
  none</CODE>" or "<CODE>-compose SRC</CODE>" (see <A HREF="../compose/index.html#src"
  >Src Compose Method</A> for details).

</I></FONT></TD></TR></TABLE></P>

You can use this to generate a tiled image much larger than you need, then use
"<CODE><A HREF="../../../html/www/command-line-options.html#composite" >-composite</A></CODE>" to 
overlay
it over the original image.  If the tile image is partially transparent then
a '<CODE><A HREF="../compose/index.html#over" >Over</A></CODE>' "<CODE><A
HREF="../../../html/www/command-line-options.html#compose" >-compose</A></CODE>" method will need to be
specified.  It is a very slow method of tiling, particularly for large images,
and you have the problem of determining just how big an image you need to
create for the overlay.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert test.png -size 200x200 tile:tile_disks.jpg \
          -composite  tile_over.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="tile_over.gif"
     ><IMG SRC="tile_over.gif"       WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE>


By specify a tile as 'tile fill pattern' for the "<CODE><A
HREF="../../../html/www/command-line-options.html#draw" >-draw</A></CODE>" operator, you can draw the
tile image over another image, to create any shape or figure you like. </P>

This is because the "<CODE><A HREF="../../../html/www/command-line-options.html#tile"
>-tile</A></CODE>" setting will override any of the "<CODE><A
HREF="../../../html/www/command-line-options.html#fill" >-fill</A></CODE>" color setting used by draw.
See <A HREF="../draw/index.html#settings" >MVG Drawing Settings</A>.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 60x60 xc: -tile tile_aqua.jpg \
          -draw "circle 30,30 2,30"   tile_draw.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="tile_draw.gif"
     ><IMG SRC="tile_draw.gif"       WIDTH=60 HEIGHT=60
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

This only works for "<CODE><A HREF="../../../html/www/command-line-options.html#draw"
>-draw</A></CODE>" and operators like "<CODE><A
HREF="../../../html/www/command-line-options.html#annotate" >-annotate</A></CODE>" that also make use
of "<CODE><A HREF="../../../html/www/command-line-options.html#draw" >-draw</A></CODE>" to perform
their function.  It will not work for image operators that use "<CODE><A
HREF="../../../html/www/command-line-options.html#fill" >-fill</A></CODE>" color directly, like
"<CODE><A HREF="../text/index.html#label" >label:</A></CODE>", "<CODE><A
HREF="../text/index.html#caption" >caption:</A></CODE>", and "<CODE><A
HREF="../text/index.html#text" >text:</A></CODE>".  </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

However "<CODE><A HREF="../../../html/www/command-line-options.html#draw" >-draw</A></CODE>" has
built in to it some special <A HREF="../draw/index.html#color" >color primitives</A>,
such as completely resetting all the pixels in the image to the fill color or
tile pattern (if set).

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR VALIGN=bottom><TD><PRE><CODE EXECUTE>
  convert test.png   -tile tile_water.jpg  -draw "color 0,0 reset" \
          tile_reset.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="tile_reset.gif"
     ><IMG SRC="tile_reset.gif"       WIDTH=150 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

This is actually exactly the same method as used by some <A HREF="index.html#solid"
>Solid Color Canvases</A> methods using a <A HREF="index.html#specific" >Specific
Color</A>. Only here we used "<CODE><A HREF="../../../html/www/command-line-options.html#tile"
>-tile</A></CODE>" instead of a "<CODE><A HREF="../../../html/www/command-line-options.html#fill"
>-fill</A></CODE>" color.  </P>

<BR>

A more advanced method is to use a <A HREF="../distorts/index.html#distort" >Distort
Operator</A> with a special <A HREF="../distorts/index.html#distort_viewport" >Distort
Viewport</A> setting, that was set to the size of the original image (using
a <A HREF="../basics/index.html#define" >Defined Global Artifact</A> and <A
HREF="../basics/index.html#arg_percent" >Percent Escapes</A>). </P>

This basically maps the smaller tiles <A HREF="../misc/index.html#virtual" >Virtual
Pixels</A>, that surrounds the small tile image, to generate the larger tiled
canvas.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rose: -set option:distort:viewport '%g' +delete  \
          tree.gif -virtual-pixel tile -filter point -distort SRT 0 \
          tile_distort_sized.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="tile_distort_sized.gif"
     ><IMG SRC="tile_distort_sized.gif"    WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

See <A HREF="index.html#tile_distort" >Tiling via Distort</A> (below) where we will look
at this same technique to tile an image that is already in memory. </P>


<A NAME="tile-offset"></A>
<H3>Offset Tiling Canvases</H3>

Sometimes you need a little more control over the exact positioning of a
background texture, either for aligning a tile pattern with some other image,
or to avoid a bad correlation with some other part of the final image. For
many of the standard tiling methods this can be achieved using the "<CODE><A
HREF="../../../html/www/command-line-options.html#tile-offset" >-tile-offset</A></CODE>" setting. </P>

For example, here I roll the tile image being used to directly create a tiled
canvas image using "<CODE>tile:</CODE>" or "<CODE>pattern:</CODE>".

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 80x80 -tile-offset +30+30 tile:rose:  offset_tile.gif
  convert -size 80x80 -tile-offset +20+20 \
                                 pattern:checkerboard offset_pattern.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="offset_tile.gif"
     ><IMG SRC="offset_tile.gif"     WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=5 HSPACE=20 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="offset_pattern.gif"
     ><IMG SRC="offset_pattern.gif"     WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=5 HSPACE=20 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/warning.gif"  WIDTH=28 HEIGHT=28
    ><IMG SRC="../img_www/space.gif"   WIDTH=12 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  <A HREF="../crop/index.html#tile-offset" >Tile Offset</A> setting was broken before IM
  version 6.3.9-9 in that the 'X' offset was being used for both 'X' and 'Y'
  offset values (the given 'Y' value was ignored).  This means that while the
  above examples would have worked (both X and Y offsets are the same) you may
  not get the expected results when the two values differ.
</I></FONT></TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

This also works for the "<CODE>montage</CODE>" background
"<CODE><A HREF="../../../html/www/command-line-options.html#texture" >-texture</A></CODE>"
setting.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  montage tree.gif     -geometry +24+24 \
          -tile-offset +30+30 -texture rose: offset_texture.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="offset_texture.gif"
     ><IMG SRC="offset_texture.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE>
</P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

You can also use the setting by defining it before the "<CODE><A
HREF="../../../html/www/command-line-options.html#tile" >-tile</A></CODE>" or "<CODE><A
HREF="../../../html/www/command-line-options.html#fill" >-fill</A></CODE>" setting.  For example...

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -tile-offset +30+30  -tile rose: \
          -size 80x80 xc: -draw 'color 30,20 reset'    offset_tile_fill.gif
</CODE></PRE></TD></TR></TABLE></TD><TD ALIGN=center>
  <A HREF="offset_tile_fill.gif"
     ><IMG SRC="offset_tile_fill.gif"     WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

However there is one major problem with offset tiling. </P>

The problem is that due to the use of <A HREF="../basics/index.html#legacy" >Legacy
Command Line Style</A>, the above will fail when using built-in
"<CODE>pattern:</CODE>" tiles.  For example here I tried the same thing as the
above using a '<CODE>checkerboard</CODE>' tile pattern.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -tile-offset +20+20 -tile pattern:checkerboard \
          -size 80x80  xc: -draw 'color 30,20 reset'  offset_pattern_fail.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="offset_pattern_fail.gif"
     ><IMG SRC="offset_pattern_fail.gif"     WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

What is happening is that the first real 'operator' in the above is
'<CODE>xc:</CODE>', all the other options given before this are simply
'settings' that is used by that and later operators. Because of the <A
HREF="../basics/index.html#legacy" >Legacy Command Line Style</A> reads in all the
'settings' and applies them before actually processing the command line in the
correct order. </P>

Because of this 'legacy problem' the "<CODE><A
HREF="../../../html/www/command-line-options.html#size" >-size</A></CODE>" setting gets set BEFORE
the "<CODE><A HREF="../../../html/www/command-line-options.html#tile" >-tile</A></CODE>" setting
applies the "<CODE>pattern:</CODE>" operator.  As a consequence a 80 by 80
pixel 'tile' was generated.  This pre-sized tile is then rolled by the
"<CODE><A HREF="../../../html/www/command-line-options.html#tile-offset" >-tile-offset</A></CODE>"
option, when it is applied by the '<CODE>xc:</CODE>' operator.  </P>

In other words the "<CODE><A HREF="../../../html/www/command-line-options.html#tile"
>-tile</A></CODE>" setting will create a 80x80 pixel tile, AFTER the -size
setting has been defined, and as such the 'tile' is no longer tilable, when
used by the draw command.  </P>

This is probably one of the few examples where this legacy handling is
detrimental to normal IM 'do it as you see it' option handling by IM commands.
</P>

The solution to all this is to ensure that the "<CODE><A
HREF="../../../html/www/command-line-options.html#size" >-size</A></CODE>" setting is reset before
defining the "<CODE><A HREF="../../../html/www/command-line-options.html#tile" >-tile</A></CODE>"
image, but after any other image has been read in, and thus satisfying IM
legacy option handling.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 80x80  xc: \
          -tile-offset +20+20 +size -tile pattern:checkerboard \
          -draw 'color 30,20 reset'  offset_pattern_good.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="offset_pattern_good.gif"
     ><IMG SRC="offset_pattern_good.gif"     WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

In any case it is probably best to define the tile offset and tile image just
before its first use, which has the same result as the above solution.  </P>


<A NAME="tile_memory"></A>
<H3>Tiling with an Image already In Memory</H3><P>

Tiling an image you have in memory (created or modified) is not
straight forward, and only a few indirect methods are available. </P>

<A NAME="tile_clone"></A>
<H4>Clone and Append the Tile Image</H4>

If you are not worried about the exact size of the tiled image, you can
just append the image together multiple times. </P>

For example here we tile the image in a 3x3 array.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert tree.gif \
          \( +clone +clone \) +append \
          \( +clone +clone \) -append \
          tile_clone.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="tile_clone.gif"
     ><IMG SRC="tile_clone.gif"       WIDTH=96 HEIGHT=96
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

This method of tiling has the advantage of allowing you to flip-tile
(mirror tile) the image.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert tree.gif \
          \( +clone -flop +clone \) +append \
          \( +clone -flip +clone \) -append \
          tile_clone_flip.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="tile_clone_flip.gif"
     ><IMG SRC="tile_clone_flip.gif"       WIDTH=96 HEIGHT=96
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

In general this method is only practical when you have some idea of how
big the image being tiled is.  Also as clones are actually very fast and
efficient it is a fairly simple and fast tiling method, especially if you
use the results to further tile the larger image. </P>

<A NAME="tile_mpr"></A>
<H4>Tile using MPR: (Memory Program Register)</H4>

A better method is to save the image into a special 'In Memory' file format
"<CODE><A HREF="../files/index.html#mpr" >mpr:</A></CODE>", or named 'memory program
register'. </P>

From this register you can then either use a "<CODE><A
HREF="../../../html/www/command-line-options.html#tile" >-tile</A></CODE>" setting, or use the special
"<CODE>tile:</CODE>" image file reader, both of which can only be set from
a 'saved' image file format. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>

For example using "<CODE>tile:</CODE>" to create a tiled image of a specific
size...

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert tree.gif   -write mpr:tile +delete \
          -size 100x100 tile:mpr:tile    tile_mpr.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="tile_mpr.gif"
     ><IMG SRC="tile_mpr.gif"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  Remember that the "<CODE>tile:</CODE>" coder will replace any transparency
  in the image with the current background color. (see above)
</I></FONT></TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>

Or tile over an existing image, by setting the "<CODE><A
HREF="../../../html/www/command-line-options.html#tile" >-tile</A></CODE>" or "<CODE><A
HREF="../../../html/www/command-line-options.html#fill" >-fill</A></CODE>" fill pattern, and using
"<CODE><A HREF="../../../html/www/command-line-options.html#draw" >-draw</A></CODE>" to do a color
reset (see <A HREF="../draw/index.html#color" >Color Fill Primitives</A>)...

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert tree.gif  -write mpr:tile +delete \
          granite: -fill mpr:tile  -draw 'color 0,0 reset' \
          tile_mpr_reset.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="tile_mpr_reset.gif"
     ><IMG SRC="tile_mpr_reset.gif"       WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  If tiling with an image containing transparency, ensure the destination
  image also has transparency by using "<CODE>-alpha set</CODE>". If you
  do not the resulting image will show the tiles 'hidden' transparency color.
</I></FONT></TD></TR></TABLE></P>


<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>

Or draw using some other <A HREF="../draw/index.html#primitives" >Draw Primitive</A>,
such as a circle, using the fill pattern.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert tree.gif -write mpr:tile +delete \
          granite:  -tile mpr:tile  -draw 'circle 64,64 10,50' \
          tile_mpr_fill.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="tile_mpr_fill.gif"
     ><IMG SRC="tile_mpr_fill.gif"       WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

The name given after "<CODE><A HREF="../files/index.html#mpr" >mpr:</A></CODE>" can be
anything you like, it is only a label on 'mpr' register name used to store the
image, (in memory).  It can even be a label, number, color, or even
a filename.  </P>

<A NAME="tile_distort"></A>
<H4>Tiling using Virtual Pixels via Distort</H4>

In this method we use the <A HREF="../misc/index.html#virtual-pixel" >Virtual Pixel
Setting</A> to generate a large tiled canvas.  This setting defines how
the area surronding the actual image (outside the normal image bounds) should
look. </P>

The easiest way to extract virtual pixels is to use the <A
HREF="../distorts/index.html#distort" >Distort Operator</A> with a special <A
HREF="../distorts/index.html#distort_viewport" >Distort Viewport</A> setting.
</P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert tree.gif -set option:distort:viewport 100x100+0+0 \
          -virtual-pixel tile -filter point  -distort SRT 0 \
          tile_distort.gif
</CODE></PRE></TD></TR></TABLE>&nbsp;</TD><TD>
  <A HREF="tile_distort.gif"
     ><IMG SRC="tile_distort.gif"    WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

You also have access to other styles of virtual pixel tiling settings, such as
'<CODE><A HREF="../misc/index.html#mirror" >Mirror</A></CODE>', or even '<CODE><A
HREF="../misc/index.html#checker_tile" >CheckerTile</A></CODE>', and even good offset
tiling control using the viewport setting.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert tree.gif -set option:distort:viewport 100x100-10-10 \
          -background firebrick  -virtual-pixel CheckerTile \
          -distort SRT 0 +repage    tile_distort_checks.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="tile_distort_checks.gif"
     ><IMG SRC="tile_distort_checks.gif"    WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>


By using the <A HREF="../distorts/index.html#distort" >General Distortion
Operator</A> in this way, you also have the added bonus of distorting the
tiled image in some very complex ways. You can see examples of this in <A
HREF="../distorts/index.html#affine_tile" >Distort Affine Tiling</A>. </P>

As a more complex example, here I use an <A HREF="../distorts/index.html#arc" >Arc
Distortion</A> to tile the tree around the origin which is centered in the
viewport. The '<CODE>45</CODE>' specifies the angle the width of the tree
covers, while the '<CODE>50</CODE>' defines the radius for the top edge of
the tree tile. The rest just follows from this.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert tree.gif -set option:distort:viewport 100x100-50-50 \
          -virtual-pixel tile  -distort Arc '45 0 50' +repage \
          tile_distort_polar.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="tile_distort_polar.gif"
     ><IMG SRC="tile_distort_polar.gif"    WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>


<A NAME="pattern"></A>
<H3>Modifying Built-in IM Patterns/Tiles</H3>

See the full list of <A
HREF="../../script/formats.php.html#builtin-images"
>ImageMagick Built In Images and Patterns</A>. There are a lot of such
patterns, but I'll only look at one or two here. </P>

Now the built-in patterns are generally very very small images, which can tile
to cover large areas.  However, on their own they are very plain looking and
rather useless.  For example, here is one of the larger more interesting
patterns that is provided...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert  pattern:checkerboard  pattern_default.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="pattern_default.gif"
     ><IMG SRC="pattern_default.gif"    WIDTH=30 HEIGHT=30
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Pattern images are usually tiled over an larger areas, either as part of 
canvas
creation, by setting a "<CODE><A HREF="../../../html/www/command-line-options.html#size"
>-size</A></CODE>", or as a fill tile (see <A HREF="index.html#tile" >Tiled Canvases</A>
above). Without a size setting the default tile size of the pattern will be
used, <CODE>30x30</CODE> pixels in this case. </P>

Now you will probably notice that all the patterns currently provided by IM
are all pure black and white, with the single exception of the
'<CODE>checkerboard</CODE>' pattern I used in the last example. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>
Here is one pattern I particularly like to use as a tile pattern...

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 60x60 pattern:hexagons  pattern_hexagons.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="pattern_hexagons.gif"
     ><IMG SRC="pattern_hexagons.gif"       WIDTH=60 HEIGHT=60
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

If you are not happy with these colors you can replace them using the
"<CODE><A HREF="../../../html/www/command-line-options.html#opaque" >-opaque</A></CODE>" image
operator.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 60x60 pattern:hexagons \
          -fill blue -opaque black   -fill skyblue -opaque white \
          pattern_colored.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="pattern_colored.gif"
     ><IMG SRC="pattern_colored.gif"       WIDTH=60 HEIGHT=60
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

If you want to color the "<CODE>checkerboard</CODE>" pattern, then that is
best done by first using "<CODE><A HREF="../../../html/www/command-line-options.html#auto-level"
>-auto-level</A></CODE>" to map the two greys to black and white before
substituting those two colors.  Here instead of using "<CODE><A
HREF="../../../html/www/command-line-options.html#opaque" >-opaque</A></CODE>" to replace the colors,
I use a "<CODE><A HREF="../../../html/www/command-line-options.html#level-colors"
>+level-colors</A></CODE>" operator (add IM v6.2.4-1), which is a bit simpler
to use.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 60x60 pattern:checkerboard -auto-level \
          +level-colors red,blue     pattern_color_checks.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="pattern_color_checks.gif"
     ><IMG SRC="pattern_color_checks.gif"       WIDTH=60 HEIGHT=60
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

You can also use "<CODE><A HREF="../../../html/www/command-line-options.html#floodfill"
>-floodfill</A></CODE>" operator to color the pattern.  However for this to
work properly you need to do this, <I>before</I> you tile the modified
pattern.  In this case I also need to expand the tile three times to color it
with the regular pattern of colors I wanted.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 30x54 pattern:hexagons \
          -fill tomato     -opaque white \
          -fill dodgerblue -draw 'color 10,10 floodfill' \
          -fill limegreen  -draw 'color 10,25 floodfill' \
          -roll +15+27 \
          -fill dodgerblue -draw 'color 10,10 floodfill' \
          -fill limegreen  -draw 'color 10,25 floodfill'   miff:- |\
    convert -size 100x100 tile:- pattern_color_hexagons.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="pattern_color_hexagons.gif"
     ><IMG SRC="pattern_color_hexagons.gif"       WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

I used a pipeline of two commands in the above to separate the colored pattern
creation, from its actual usage.  If you like to do this with a single command
see <A HREF="index.html#tile_memory" >Tiling an Image In Memory</A> above. </P>


<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

You can also warp and distort a simple tiling pattern to produce an interesting
variations.  For example a 'wrinkling' effect (technique courtesy of the
wrinkle IM effect from <A HREF="http://interactimage.com/" >Font Image
Generator</A>) on a hexagon pattern I found particularly interesting

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 160x100 pattern:hexagons \
          -wave 3x100 -background white -rotate 90 -wave 4x66 -rotate -87 \
          -gravity center -crop 120x90+0+0 +repage   pattern_distorted.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="pattern_distorted.gif"
     ><IMG SRC="pattern_distorted.gif"       WIDTH=120 HEIGHT=90
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>



<A NAME="tile_mod"></A>
<H3>Modifying Tile Images</H3>

The biggest problem people face with modifying tiles, whether it's an existing
tile, or one of the built in patterns, is that many image operations destroy
the 'tilability' of the image. </P>

For example, here I have taken the built-in '<CODE>hexagon</CODE>' pattern, 
and
tried to modify it to produce a shaded gray-scale pattern of wide hexagonal
lines.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert pattern:hexagons  -rotate 90 \
          -blur 0x1  -edge 1  -negate  -shade 120x45 \
          miff:- |\
    convert  -size 100x100 tile:-   tile_mod_failure.jpg
</CODE></PRE></TD></TR></TABLE>
</TD><TD>
  <A HREF="tile_mod_failure.jpg"
     ><IMG SRC="tile_mod_failure.jpg"    WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

The first command generates the 'tile image' while the second actually tiles
the image, so we can see how they all fit together. </P>

As you can see the resulting tile image does NOT tile properly, with
artificial edge distortions clearly visible in the tiled image.  Basically we
lost the uniformity of the original tile, along the edges of the image. </P>

One solution is to use a special <A HREF="../misc/index.html#virtual-pixel" >Virtual
Pixels</A> setting, which is used to make operators think the image wraps
around the edges, when looking up colors that are beyond the bounds of the
actual image proper.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert pattern:hexagons  -rotate 90  -virtual-pixel tile \
          -blur 0x1  -edge 1  -negate  -shade 120x45 \
          miff:- |\
     convert  -size 100x100 tile:-   tile_mod_vpixels.jpg
</CODE></PRE></TD></TR></TABLE>
</TD><TD>
  <A HREF="tile_mod_vpixels.jpg"
     ><IMG SRC="tile_mod_vpixels.jpg"    WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Here is another example where I join two related tile patterns together, and
use various effects to create unusual brick wall tile.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert pattern:leftshingle pattern:rightshingle +append \
          -virtual-pixel tile  -blur 0x0.75 -resize 150% -shade 100x45 \
          -fill Peru  -tint 100%   miff:- |\
    convert  -size 100x100 tile:-   tile_slanted_bricks.jpg
</CODE></PRE></TD></TR></TABLE>
</TD><TD>
  <A HREF="tile_slanted_bricks.jpg"
     ><IMG SRC="tile_slanted_bricks.jpg"    WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<H4>Alternative</H4>

There is an alternative to relying on <A HREF="../misc/index.html#virtual-pixel"
>Virtual Pixels</A>. </P>

Basically we provide the 'virtual edge pixels' ourselves before operating
on the image, so as to avoid any edge effects that may be present.  And that
is done by tiling the image over a slightly larger area first.  After
modifying the image, we can re-extract the tile, avoiding the edge distortions
that were introduced. </P>

It does not have to be lot bigger, depending on the extent of the image
operations being performed. I have found 15 to 40 pixels should stop all edge
effects in the final result. </P>

To re-extract the image we can either "<CODE><A
HREF="../../../html/www/command-line-options.html#shave" >-shave</A></CODE>" off the extra pixels, or
"<CODE><A HREF="../../../html/www/command-line-options.html#crop" >-crop</A></CODE>" the original tile
size from the middle of the processed image. </P>

For example here I create a 3d "<CODE><A HREF="../../../html/www/command-line-options.html#shade"
>-shade</A></CODE>" effect using the built-in '<CODE>hexagons</CODE>' pattern.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 60x60 tile:pattern:hexagons  -rotate 90 \
          -blur 0x1  -edge 1  -negate  -shade 120x45 \
          -gravity center -crop 18x30+0+0 +repage miff:- |\
    convert  -size 100x100 tile:-   tile_mod_success.jpg
</CODE></PRE></TD></TR></TABLE>
</TD><TD>
  <A HREF="tile_mod_success.jpg"
     ><IMG SRC="tile_mod_success.jpg"    WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Note the exact position of the extracted tile does not matter.  A tilable
image can be cut anywhere from the tiled image, as long as it is away from the
distorted edges, and you use the same original size of the tile. </P>

Here instead of tiling the image over a larger area, we use a 'double clone'
technique to double the area the tile covers.  When finished we then just
center crop 50% of the image to recover our modified tile.  This means we have
no need to know the exact size of the tile you are processing.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert pattern:circles \( +clone \) +append \( +clone \) -append \
          -fill grey -opaque black  -blur 0x0.5 -shade 120x45 \
          -gravity center -crop 50%  +repage    miff:- |\
    convert  -size 100x100 tile:-   tile_circles.jpg
</CODE></PRE></TD></TR></TABLE>
</TD><TD>
  <A HREF="tile_circles.jpg"
     ><IMG SRC="tile_circles.jpg"    WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>


<A NAME="tile_gen">
<H3>Generating Tile Images</H3>
</A>

The biggest problem you face when generating images that can tile together is
trying to match the edges and corners of the image so that they can fit
together seamlessly.  If this is not done then all you get is a set of square
boxes each with a repeated copy of the image. </P>

This is not an easy matter and can be a very frustrating and hair pulling
experience.  An object appearing in the tile on one edge must re-appear on the
other side of the image in order to re-form the whole when the image is tiled. 
 While
you can do this fairly easily with computer generated images, it is next to
impossible to produce a good tiling image featuring real-world photographs.
</P>

The other major problem is trying to make the tile not look like it is
repeating.  The only true solution to this is to make your tile images large
enough to contain enough very similar, but still different elements that it
becomes difficult to see a repeated pattern.  For this reason, generating 
small
tiles that do not seem to repeat is especially difficult. </P>

<PRE>
FUTURE:  Ideas and suggestions for generating tile patterns?  Anyone?

Or roll, add element, roll, add element, etc...

Any and all suggestions and examples accepted.

Suggestions for generating tile from real photos of repeating patterns,
such as water, fallen leaves, clouds, stucco, brickwork, etc...

Generating Escher-like tile patterns.
</PRE>

<A NAME="tile_random"></A>
<H3>Random Noise Tile</H3>

Because a raw random noise canvas has no edges characteristics to begin with
(every pixel color is completely independent of any of its neighbours), you
can tile it without worry about edge distortions.  Basically it is so
extremely random at the pixel level, no edges match to begin with, so we don't
lose anything, by tiling. </P>

Unfortunately very few situations would use a raw random noise image, as is,
for any real purpose.  It is just so horribly random that it is useless.
However by modifying the image while preserving its inherent tilability, we
can make just about any randomized tile pattern we want. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>

For example lets look at the a basic "<CODE><A HREF="../../../html/www/command-line-options.html#blur"
>-blur</A></CODE>" of the original tile, using the same 'modifying a tile'
technique we used in the last example.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
<r>  convert -size 64x64 xc: +noise Random \
          -virtual-pixel tile -blur 0x6 -auto-level  tile_random.jpg

  convert -size 128x128   tile:tile_random.jpg   tiled_random.jpg
</CODE></PRE></TD></TR></TABLE>
</TD><TD ALIGN=center>
  <A HREF="tile_random.jpg"
     ><IMG SRC="tile_random.jpg"       WIDTH=64 HEIGHT=64
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<BR>
  <A HREF="tiled_random.jpg"
     ><IMG SRC="tiled_random.jpg"       WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>

Using this technique you can apply just about any transformation to a raw
random noise image image.   For example...

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
<r>  convert -size 64x64 xc: +noise Random \
          -virtual-pixel tile  -blur 0x6  -edge 1  -fx G \
          -shade 280x45  -auto-level  tile_random_pits.jpg

  convert -size 128x128 tile:tile_random_pits.jpg tiled_random_pits.jpg
</CODE></PRE></TD></TR></TABLE>
</TD><TD ALIGN=center>
  <A HREF="tile_random_pits.jpg"
     ><IMG SRC="tile_random_pits.jpg"       WIDTH=64 HEIGHT=64
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<BR>
  <A HREF="tiled_random_pits.jpg"
     ><IMG SRC="tiled_random_pits.jpg"    WIDTH=128 HEIGHT=128
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE>

As you can see it is a lot simpler to create randomized tiles using the raw
random noise image, and you will not have any edge distortions in the results.
</P>

This particular image transformation is listed on the <A
HREF="../backgrounds/index.html" >Background Images</A> page and is titled "pits".  See
that page for lots of other image random image transformations, and examples
of what they look like.  </P>


<A NAME="tile_hex"></A>
<H3>Hexagonal Tiling</H3>

Rather than tile in a square fashion, the 'random noise' image allows use to
generate a very different sort of tile.  By doubling the image dimensions
and re-laying the tile in the extra space, but offset by half, we can generate
a basic random noise hexagonal tile pattern. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

This is the same sort of tiling effect we get when we tile the special
"<CODE>pattern:hexagons</CODE>" built-in of ImageMagick.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert  pattern:hexagons  tile_hexagons.gif

  convert  -size 64x64  pattern:hexagons  tiled_hexagons.gif
</CODE></PRE></TD></TR></TABLE>
</TD><TD ALIGN=center>
  <A HREF="tile_hexagons.gif"
     ><IMG SRC="tile_hexagons.gif"    WIDTH=30 HEIGHT=18
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<BR>
  <A HREF="tiled_hexagons.gif"
     ><IMG SRC="tiled_hexagons.gif"    WIDTH=64 HEIGHT=64
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Note however that for this tile to look 'hexagonal' the tile cannot be
a normal square, or even a doubled square.  The final tile size needs to be
a rectangle. The exact ratio for this rectangle actually involves irrational
numbers, which is not very good for image work with a pixel array.  However
a good working ratio is 4:3, which is used by most computer and digital camera
images. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

Here we overlay the same 'random noise' image (a rectangle with a 2:3 ratio)
two extra times to generate the basic hexagon pattern (in a 4:3 rectangle).
</P>

The hex-tiled random noise tile is then transformed using the "paint_3s"
transformation from the <A HREF="../backgrounds/index.html" >Background Images</A> page,
to generate a rather nice looking hexagonal tile pattern.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
<r>  convert -size 48x64 xc: +noise Random  -write mpr:rand \
          -extent 96x64  -page +48-32 mpr:rand  -page +48+32 mpr:rand \
          -flatten          tile_hex_random.jpg

  convert tile_hex_random.jpg -virtual-pixel tile -blur 0x10 -paint 3 \
          -shade 280x45 -auto-level  tile_hex_layered.jpg

  convert -size 160x160  tile:tile_hex_layered.jpg  tiled_hex_layered.jpg
</CODE></PRE></TD></TR></TABLE>
</TD><TD ALIGN=center>
  <A HREF="tile_hex_layered.jpg"
     ><IMG SRC="tile_hex_layered.jpg"    WIDTH=96 HEIGHT=64
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<BR>
  <A HREF="tiled_hex_layered.jpg"
     ><IMG SRC="tiled_hex_layered.jpg"    WIDTH=160 HEIGHT=160
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

If you look at the pattern the tile produces you will see that any specific
feature, will have 6 copies of that same feature surrounding it in a circle.
This is the 'hexagonal' pattern the tile produces, even though it is still
tiled in the same 'square' pattern as all other tiling images. </P>

One variant of the above 'hextile' pattern is to double up the tile image
vertically, rather than horizontally as we have done above.  The result is
that the hexagonal pattern will be rotated ninety degrees. It is however still
the same type of pattern. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/expert.gif"   WIDTH=23 HEIGHT=26
    ><IMG SRC="../img_www/space.gif"   WIDTH=17 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  Mathematically the above is not generating a new <A
  HREF="http://en.wikipedia.org/wiki/Wallpaper_group" >Wallpaper Group</A>
  form an existing tile.  Both the original 'non-hexagonal' image and the
  final verson belong to the same '<B>p1</B>' tiling group. </P>

  What we are actually doing in the above is converting a rhombus 'prototile'
  tiling pattern into a larger rectangular orthogonally aligned 'fundamental
  domain' of the same tiling pattern. In this way you can then tile the image
  using a standard tiling method.

</I></FONT></TD></TR></TABLE></P>

<I>Future:  Flip the extra image over to generate a larger tiling pattern
(<B>pmg</B> tiling group). </I> </P>

<I>Future: how to cut out (mask) a hexagon from an image so it will tile
perfectly, without gaps or overlaps.</I> </P>


<A NAME="tile_triple_hex"></A>
<H3>Triple Hex Tiling</H3>

Like we did when coloring the the "<CODE>hexagons</CODE>" built-in pattern
(See <A HREF="index.html#pattern" >Modifying Built-in IM Patterns/Tiles</A> above), you
can make three different variants of the initial tile, (with rotations for
example) before re-mapping them to form the larger tile. </P>

Of course, just as I did when coloring the "<CODE>hexagons</CODE>" pattern,
the final tile image will need to be enlarged three times larger, so as to
generate a repeating rectangular tile pattern. </P>

The variations between the three tiles generated must not be too different,
and should survive any post-processing, otherwise you will not get the 
benefits
of the technique. This means the initial tile must be reasonably large as
well, so any distinct features present will be preserved.  </P>

For example here we take a very simple line drawing, and rotate it to produce
3 similar variations.  These rotated images are then tiled seven times onto a
larger canvas (6 times larger) to produce the triple image hex pattern. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 24x24 xc: -draw "rectangle 3,11 20,12"  tile_line.gif

  convert tile_line.gif   -gravity center\
          \( +clone -rotate    0 -crop 24x18+0+0 -write mpr:r1 +delete \) \
          \( +clone -rotate  120 -crop 24x18+0+0 -write mpr:r2 +delete \) \
                    -rotate -120 -crop 24x18+0+0 -write mpr:r3 +repage \
          -extent 72x36        -page  +0+0  mpr:r3 \
          -page +24+0  mpr:r1  -page +48+0  mpr:r2 \
          -page -12+18 mpr:r1  -page +12+18 mpr:r2 \
          -page +36+18 mpr:r3  -page +60+18 mpr:r1 \
          -flatten tile_hex_lines.jpg

  convert -size 120x120  tile:tile_hex_lines.jpg  tiled_hex_lines.jpg
</CODE></PRE></TD></TR></TABLE>
</TD><TD ALIGN=center>
  <A HREF="tile_line.gif"
     ><IMG SRC="tile_line.gif"           WIDTH=24   HEIGHT=24
           ALIGN=middle VSPACE=0  HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<BR>
  <A HREF="tile_hex_lines.jpg"
     ><IMG SRC="tile_hex_lines.jpg"      WIDTH=72   HEIGHT=36
           ALIGN=middle VSPACE=10 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<BR>
  <A HREF="tiled_hex_lines.jpg"
     ><IMG SRC="tiled_hex_lines.jpg"     WIDTH=120  HEIGHT=120
           ALIGN=middle VSPACE=0  HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

The above however only works for tiling a small shape in the middle of the
original image.  It does not work well for a general image. </P>

For a general image hex tiling we also need to mask out an equilateral
triangles. The pieces are then rotated so the equilateral trianlge edges are
mirrored.  This is not an easy task. </P>


<A NAME="tile_diagonal"></A>
<H3>Diagonal Mirror Tiling</H3>

Here is one way to take any square image and convert it into 8 mirrored images
around a central point.  Specifically we are generating a complex '<B>p4m</B>'
tiling pattern. </P>

I first generate <A HREF="index.html#random_hue" >Random Hue Image</A>, and using the
bottom-left half of the source image I mirror it diagonally, then horizontally
and vertically.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE RANDOM>
  convert -size 50x50 xc: +noise Random -virtual-pixel Tile -blur 0x5 \
          -auto-level -separate -background white \
          -compose ModulusAdd -flatten -channel R -combine +channel \
          -set colorspace HSB -colorspace RGB   tile_diag_source.jpg

  convert tile_diag_source.jpg     \( +clone -transpose \) \
          \( +clone -sparse-color voronoi '%w,0 white 0,%h black' \) \
          -composite \
          \( +clone -flop -chop 1x0 \) +append \
          \( +clone -flip -chop 0x1 \) -append \
          tile_diag_mirror.jpg
</CODE></PRE></TD></TR></TABLE>
</TD><TD ALIGN=center>
  <A HREF="tile_diag_source.jpg"
     ><IMG SRC="tile_diag_source.jpg"           WIDTH=50   HEIGHT=50
           ALIGN=middle VSPACE=0  HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<BR>
  <A HREF="tile_diag_mirror.jpg"
     ><IMG SRC="tile_diag_mirror.jpg"      WIDTH=99   HEIGHT=99
           ALIGN=middle VSPACE=10 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

The diagonal mirror is generated by doing a <A HREF="../warping/index.html#transpose"
>Transpose</A> and then using a mask generated using a <A HREF="index.html#voronoi"
>Voronoi, Sparse Color</A>.  Note that this diagonal mirror automatically
shares one line of pixels across the mirror in the same way, due to the pixel
geometry of the square. </P>

I also remove one set of pixels along the edge before creating vertical and
horizontal <A HREF="../warping/index.html#flip" >Flips and Flops</A>.  I also recommend
the removal another row and column of pixels along the top and left edge,
before using this image as a 'tile'.  You don't need to do this, but I think
it looks better.  Without removing one row and column of edge pixels, you get
ugly 'seams' of doubled pixels, where the images join together. </P>


An alternative is to tile the raw random image first, then do the  <A
HREF="../backgrounds/index.html" >Background Pattern</A> conversion, you are less likely
to get a 'clipped look' along the mirror lines, but a smoother transition.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE RANDOM>
  convert -size 51x51 xc: +noise Random   \( +clone -transpose \) \
          \( +clone -sparse-color voronoi '%w,0 white 0,%h black' \) \
          -composite \
          \( +clone -flop -chop 1x0 \) +append \
          \( +clone -flip -chop 0x1 \) -append \
          -chop 1x1 \
          \
          -virtual-pixel Tile -blur 0x5 -auto-level \
          -separate -background white \
          -compose ModulusAdd -flatten -channel R -combine +channel \
          -set colorspace HSB -colorspace RGB    tile_p4m.jpg
</CODE></PRE></TD></TR></TABLE>
</TD><TD ALIGN=center>
  <A HREF="tile_p4m.jpg"
     ><IMG SRC="tile_p4m.jpg"      WIDTH=100   HEIGHT=100
           ALIGN=middle VSPACE=10 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

The first part is the generation of the 'tiling of the random data' the second
half I convert the random data into a 'hues' mapping. </P>

I also added the extra pixel to the initial image which will be later choped
as appropiate to generate a tiling image. </P>

<BR>

For a more complete introduction into tiling images and the mathematics behind
them, see <A HREF="http://en.wikipedia.org/wiki/Wallpaper_group" >Wikipedia:
Wallpaper Group</A>.  What we have explored above is only a few of the many
tiling patterns you can create. </P>

<BR>

The '<B>p4g</B>' is almost exactly the same as the '<B>p4m</B>' tiling above,
but uses a 180 degree rotations of the mirrored squares, rather than using
flips, to generate the full tiling image. </P>

However as the images are not joined by mirrors you can not use an existing
image as the tile source as the edges will become disjoint and discontinuous.
However you can tile the raw random data then process the resulting tile
image, to produce a smooth result.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE RANDOM>
  convert -size 50x50 xc: +noise Random   \( +clone -transpose \) \
          \( +clone -sparse-color voronoi '%w,0 white 0,%h black' \) \
          -composite \
          \( +clone -rotate -90 \) +append \
          \( +clone -rotate 180 \) -append \
          \
          -virtual-pixel Tile -blur 0x5 -auto-level \
          -separate -background white \
          -compose ModulusAdd -flatten -channel R -combine +channel \
          -set colorspace HSB -colorspace RGB    tile_p4g.jpg
</CODE></PRE></TD></TR></TABLE>
</TD><TD ALIGN=center>
  <A HREF="tile_p4g.jpg"
     ><IMG SRC="tile_p4g.jpg"      WIDTH=100   HEIGHT=100
           ALIGN=middle VSPACE=10 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Note that due to the non-mirroring nature of the tiling, you do not need need
to remove the duplicated row or column of pixels from the edges before you
append. Though it does not hurt to do so, if you want to follow the same type
of process for both cases. </P>

<BR>

</DIV>
<HR><!-- ---------------------------------------------------------------- -->
<ADDRESS>
Created: 19 December 2003 <BR>
Updated: 22 March 2011 <BR>
Author: <A HREF="https://antofthy.gitlab.io/anthony.html"
        >Anthony Thyssen</A>, &lt;Anthony.Thyssen&#64;gmail.com&gt;<BR>
Examples Generated with:
        <IMG SRC="version.gif" ALIGN=absmiddle ALT="[version image]"><BR>
URL: <CODE>https://legacy.imagemagick.org/Usage/canvas/</CODE>
</ADDRESS></BODY></HTML>

