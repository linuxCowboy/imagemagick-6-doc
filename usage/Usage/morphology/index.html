<html lang="en"><HEAD>
<meta charset="utf-8" >
<meta name="viewport" content="width=device-width, initial-scale=1" >
<link rel="stylesheet" href="../../../html/www/css/magick.css">
<TITLE>Morphology of Shapes -- IM v6 Examples</TITLE>
<LINK REL="icon" HREF="../img_www/favicon.ico" type="image/x-icon">
<LINK REL="shortcut" HREF="../img_www/favicon.ico" type="image/x-icon">
<LINK REL="canonical" HREF="../morphology.html">
</HEAD><BODY BGCOLOR="#B0C4DE">

<H1>ImageMagick v6 Examples -- <BR>
    <IMG SRC="../img_www/space.gif" width=50 height=1>
    Morphology of Shapes</H1>

<DIV ALIGN=justify>

<DL>
<DT><B>Index</B>
<DT><A HREF="../index.html"
    ><IMG SRC="../img_www/granitesm_left.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > ImageMagick Examples Preface and Index</A>
<DD><A HREF="index.html#intro"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > Morphology Introduction</A>
    <UL>
    <LI><A HREF="index.html#morphology"
        >Morphology Operator</A>
    <LI><A HREF="index.html#kernel"
        >Basic Built-In Morphology Kernels</A>
        <UL>
        <LI><A HREF="index.html#unity"        ><CODE>Unity</CODE></A>,&nbsp;
            <A HREF="index.html#diamond"      ><CODE>Diamond</CODE></A>,&nbsp;
            <A HREF="index.html#square"       ><CODE>Square</CODE></A>,&nbsp;
            <A HREF="index.html#octagon"      ><CODE>Octagon</CODE></A>,&nbsp;
            <A HREF="index.html#disk"         ><CODE>Disk</CODE></A>,&nbsp;
            <A HREF="index.html#plus"         ><CODE>Plus</CODE></A>,&nbsp;
            <A HREF="index.html#cross"        ><CODE>Cross</CODE></A>,&nbsp;
            <A HREF="index.html#ring"         ><CODE>Ring</CODE></A>,&nbsp;
            <A HREF="index.html#rectangle"    ><CODE>Rectangle</CODE></A>
        <LI><A HREF="index.html#user"         >User Defined Kernels</A>
        <LI><A HREF="index.html#image2kernel" >Image to User Kernel</A>
        </UL>
    <LI><A HREF="index.html#iteration"
        >Iterating (Repeating) Morphology Operations</A>
    <LI><A HREF="index.html#verbose"
        >Verbose Output of Changes</A> (for monitoring)
    <LI><A HREF="index.html#showkernel"
        >Displaying the Generated Kernel</A> (for debugging purposes)
    <LI><A HREF="index.html#kernel2image"
        >Generating an Image of the Kernel</A> (for debugging purposes)
    <LI><A HREF="index.html#multi-kernel"
        >Multiple Kernel List Handling</A>
        <UL>
        <LI><A HREF="index.html#multi-kernel"
            >Generating a List of Multiple Kernels</A>
        <LI><A HREF="index.html#rotated_kernels"
            >Expanding to a Rotated Kernel List</A>
        <LI><A HREF="index.html#kernel_compose"
            >Multiple Kernel Results Merging : Re-iterate or Compose</A>
        </UL>
    </UL>
<DD><A HREF="index.html#basic"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > Basic Morphology Methods</A>
    <UL>
    <LI><A HREF="index.html#erode"    ><CODE>Erode</CODE></A>,&nbsp;
        <A HREF="index.html#dilate"   ><CODE>Dilate</CODE></A>,&nbsp;
        <A HREF="index.html#open"     ><CODE>Open</CODE></A>,&nbsp;
        <A HREF="index.html#close"    ><CODE>Close</CODE></A>,&nbsp;
        <A HREF="index.html#smooth"   ><CODE>Smooth</CODE></A>
    <LI><A HREF="index.html#greyscale_flat" >Flat Grey-scale Morphology</A>
    <LI><A HREF="index.html#greyscale"   >True Grey-scale or 3-dimensional Morphology</A>
    <LI><A HREF="index.html#intensity"   >Intensity Variant of Basic Methods</A>
    <LI><A HREF="index.html#alturnative" >Alternative Basic Morphology Techniques</A>
    </UL>
<DD><A HREF="index.html#difference"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > Difference Morphology Methods</A>
    <UL>
    <LI><A HREF="index.html#edgein"     ><CODE>EdgeIn</CODE></A>,&nbsp;
        <A HREF="index.html#edgeout"    ><CODE>EdgeOut</CODE></A>,&nbsp;
        <A HREF="index.html#edge"        ><CODE>Edge</CODE></A>,&nbsp;
        <A HREF="index.html#top-hat"     ><CODE>Top-Hat</CODE></A>,&nbsp;
        <A HREF="index.html#bottom-hat"  ><CODE>Bottom-Hat</CODE></A>
    </UL>
<DD><A HREF="index.html#using"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > Using Low Level Morphology Methods</A>
    <UL>
    <LI><A HREF="index.html#channel"     >Basic Morphology and Channels</A>
    <LI><A HREF="index.html#granularity" >Granularity of a Collection of Shapes</A>
    <LI><A HREF="index.html#asymmetric"  >Asymmetric Kernel Effects</A> (method testing)
    </UL>
<DD><A HREF="index.html#hmt"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > Hit and Miss (HMT) Pattern Matching</A>
    <UL>
    <LI><A HREF="index.html#hitmiss"
        >Hit And Miss</A>
        <UL>
        <LI><A HREF="index.html#hitmiss_greyscale"
            >Hit and Miss with Grey-Scale Images</A>
        </UL>
    <LI><A HREF="index.html#thicken"
        >Thicken - Add pixels that match</A>
        <UL>
        <LI><A HREF="index.html#thicken_convexhull"
            >Octagonal Convex Hull</A>
        <LI><A HREF="index.html#thicken_greyscale"
            >Thicken Grey-scale Images</A>
        </UL>
    <LI><A HREF="index.html#thinning"
        >Thinning - Subtracting pixels that match</A>
        <UL>
        <LI><A HREF="index.html#thinning_edgedet"
            >Thinning Edge Detector Output </A>
        <LI><A HREF="index.html#thinning_skeleton"
            >Thinning down to a Skeleton</A>
        <LI><A HREF="index.html#skeleton_info"
            >Skeleton Information</A>
        <LI><A HREF="index.html#thinning_pruning"
            >Pruning Lines</A>
        <LI><A HREF="index.html#thinning_prune_fast"
            >Fast Pruning of Lines</A>
        <LI><A HREF="index.html#thinning_style"
            >Thinning Style - Sequential vs Simultaneous</A>
        </UL>
    <LI><A HREF="index.html#pattern_kernels"
        >Pattern Matching Kernels</A>
        <UL>
        <LI><A HREF="index.html#peaks"          ><CODE>Peaks</CODE></A>,&nbsp;
            <A HREF="index.html#edges"          ><CODE>Edges</CODE></A>,&nbsp;
            <A HREF="index.html#corners"        ><CODE>Corners</CODE></A>,&nbsp;
            <A HREF="index.html#diagonals"      ><CODE>Diagonals</CODE></A>,&nbsp;
            <A HREF="index.html#lineends"       ><CODE>LineEnds</CODE></A>,&nbsp;
            <A HREF="index.html#linejunctions"  ><CODE>LineJunctions</CODE></A>,&nbsp;
        <BR><A HREF="index.html#ridges"         ><CODE>Ridges</CODE></A>,&nbsp;
            <A HREF="index.html#convexhull"     ><CODE>ConvexHull</CODE></A>,&nbsp;
            <A HREF="index.html#skeleton"       ><CODE>Skeleton</CODE></A>,&nbsp;
            <A HREF="index.html#thinse"         ><CODE>ThinSE</CODE></A>
        </UL>

    </UL>
<DD><A HREF="index.html#distance"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > Distance Morphology Method </A>
    <UL>
    <LI><A HREF="index.html#distance_kernels"
        >Distance Kernels</A>,&nbsp;
        <UL>
        <LI><A HREF="index.html#chebyshev" ><CODE>Chebyshev</CODE></A>,&nbsp;
            <A HREF="index.html#manhattan" ><CODE>Manhattan</CODE></A>,&nbsp;
            <A HREF="index.html#octagonal" ><CODE>Octagonal</CODE></A>,&nbsp;
            <A HREF="index.html#knight"  ><CODE>Euclidean&nbsp;(knight)</CODE></A>,&nbsp;
            <A HREF="index.html#euclidean" ><CODE>Euclidean</CODE></A>,&nbsp;
        <LI><A HREF="index.html#distance_compare"
            >Comparison of Distance Kernels</A>
        <LI><A HREF="index.html#distance_user"
            >Special User defined Distance Kernels</A>
        </UL>
    <LI><A HREF="index.html#distance_anti-alias"
        >Distance with an Anti-Aliased Shape</A>
    <LI><A HREF="index.html#distance_feather"
        >Feathering Shapes using Distance</A>
    </UL>
<DD><A HREF="index.html#conditional"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > Conditional or Constrained Morphology</A>
    <UL>
    <LI><A HREF="index.html#dilate_conditional"
        >Conditional Dilation</A>
    <LI><A HREF="index.html#distance_constrainted"
        >Constrained Distance</A>
    </UL>
<DD><A HREF="index.html#skeletons"
    ><IMG SRC="../img_www/granitesm_right.gif" BORDER=0 WIDTH=15 HEIGHT=15
    > Generating Skeletons from Shapes. </A>  <I>Under Construction</I>
    <UL>
    <LI><A HREF="index.html#distance_skeleton"
        >Distance to Skeleton</A>
    <LI><A HREF="index.html#autotrace_skeleton"
        >Skeleton using Autotrace</A>
    </UL>
</DL></P>

Morphology modifies an image in various ways based on the nearby
'neighbourhood' of the other pixels that surround it.  This in turn can
provide a huge range of effects,  Shape expansion and contraction
(dilate/erode), to distance from edge, to thining down to a skeleton, or
mid-line axis. </P>

Even the more anchiet method of 'convolution' techniques that provide
blurring and sharpening techniques (next section), is in a way a type
of morphology method. </P>

Essentually morphology is for the modification, determination, and discovery
of the shapes of objects found within an image. </P>

<HR><!-- ---------------------------------------------------------------- -->

<A NAME="intro"></A>
<H2>Morphology Introduction</H2>

Morphology was originally developed as a method by which the structure of
shapes within an image could be cleaned up and studied.  It works by comparing
each pixel in the image against its neighbours in various ways, so as to
either add or remove, brighten or darken that pixel. Applied over a whole
image, perhaps repetitively, specific shapes can be found and/or removed and
modified. </P>

For example if an pixel is white and completely surrounded by other white
pixels, then that pixel is obviously not on the edge of the image. You may
then like to make that pixel black, so as to leave only edge pixels turned on.
A method known as '<CODE><A HREF="index.html#edgein" >EdgeIn</A></CODE>' (see below).
</P>

The whole process actually depends on the definition of a 'Structuring
Element' or 'Kernel', which defines what pixels are to be classed as
'neighbours' for each specific morphological method.  Exactly what size and
shape this 'neighbourhood' often depends on just what you are trying to
achieve, or what you are specifically looking for within the image. </P>

Here are some examples of various kernels that have been converted into images
(using a special script "<CODE><A HREF="../scripts/kernel2image"
>kernel2image"</A></CODE>") showing some of the 'neighbourhoods' around
a central pixel, 'origin'.

<DIV ALIGN=center>
<!--<CODE EXECUTE>
  kernel2image -20.2 -m "Diamond"            kernel_diamond.gif
  kernel2image -20.2 -m "Square"             kernel_square.gif
  kernel2image -15.2 -m "Octagon"            kernel_octagon.gif
  kernel2image -9.1  -m "Disk"               kernel_disk.gif
  kernel2image -15.2 -m "Plus"               kernel_plus.gif
  kernel2image -15.2 -m "Rectangle:7x4+3+2"  kernel_rectangle.gif
  kernel2image -20.2 -m -k 0 "Corners"       kernel_corner.gif
  kernel2image -8.1 -mn -n "Gaussian:5x2"    kernel_gaussian.gif

  # small GIF's are broken!
  kernel2image "Disk" kernel_disk_raw.gif
</CODE>-->
<TABLE><TR VALIGN=center HEIGHT=100>
<TD ALIGN=center>
  <A HREF="kernel_diamond.gif"
      ><IMG SRC="kernel_diamond.gif"
            ALIGN=middle VSPACE=2 HSPACE=0 BORDER=0 ALT="[IM Output]"></A>
<TD ALIGN=center>
  <A HREF="kernel_square.gif"
      ><IMG SRC="kernel_square.gif"
            ALIGN=middle VSPACE=2 HSPACE=0 BORDER=0 ALT="[IM Output]"></A>
<TD ALIGN=center>
  <A HREF="kernel_octagon.gif"
      ><IMG SRC="kernel_octagon.gif"
            ALIGN=middle VSPACE=2 HSPACE=0 BORDER=0 ALT="[IM Output]"></A>
<TD ALIGN=center>
  <A HREF="kernel_disk.gif"
      ><IMG SRC="kernel_disk.gif"
            ALIGN=middle VSPACE=2 HSPACE=0 BORDER=0 ALT="[IM Output]"></A>
<TD ALIGN=center>
  <A HREF="kernel_plus.gif"
      ><IMG SRC="kernel_plus.gif"
            ALIGN=middle VSPACE=2 HSPACE=0 BORDER=0 ALT="[IM Output]"></A>
<TD ALIGN=center>
  <A HREF="kernel_rectangle.gif"
      ><IMG SRC="kernel_rectangle.gif"
            ALIGN=middle VSPACE=2 HSPACE=0 BORDER=0 ALT="[IM Output]"></A>
<TD ALIGN=center>
  <A HREF="kernel_corner.gif"
      ><IMG SRC="kernel_corner.gif"
            ALIGN=middle VSPACE=2 HSPACE=0 BORDER=0 ALT="[IM Output]"></A>
<TD ALIGN=center>
  <A HREF="kernel_gaussian.gif"
      ><IMG SRC="kernel_gaussian.gif"
            ALIGN=middle VSPACE=2 HSPACE=0 BORDER=0 ALT="[IM Output]"></A>
</TR></TABLE>
</DIV>

The images have been scaled to highlight the individual elements of the
'kernel', and as you can see typical kernels are often very small. In fact the
'Disk' kernel show above is actually "<IMG SRC="kernel_disk_raw.gif" WIDTH=9
HEIGHT=9 BORDER=0 ALT="[Raw Disk Kernel Image]">", and that is one of the
largest kernels shown above. </P>

However the 'kernels' are not really images. Just an array of floating-point
values with one element specified to be the 'origin' of the kernel.  This
special element is the location of the pixel that will be 'effected' by the
defined neighbourhood, and is typically though not always the center pixel of
a symetrical kernel.  </P>

Note that these are only some examples of possible neighbourhoods.  Some
kernels can be made larger, typically by increasing a 'radius' argument
specific to that kernel, while others used for special purposes are of fixed
size. </P>

For simple kernels, such as the first two, the morphological method could be
repeated (iterated) to increase the effective 'size' of the kernel, so as to
effect more pixels further away from the 'origin' (as marked).  This does not
always work however, and can produce unexpected results, however it is
sometimes faster than directly using a larger kernel, but again that is not
always the case. </P>

The final size and shape of a 'Structuring Element', or 'SE', as a kernel is
termed in morphology research papers, is important as a means of locating and
enhancing or deleting image elements that are larger or smaller than this
shape.  This is what makes morphology extremely powerful as a means of sorting
out various elements within images.  However the larger the kernel, the longer
the morphological methods will take, so it is better to keep the kernels
small.  </P>

All of the kernels shown, excluding the last one, are actually shaped.  The
parts that are transparent are <I>not</I> part of the defined 'neighbourhood'
of the kernel.  That is they will do not have any valid value, and will not
take part in any of the morphology calculations.  </P>

Note how the second last kernel '<CODE>Corner #0</CODE>' not only has 'on'
values, but also 'off' values, as part of its 'shape'.  Both values, as well
as those that are transparent (not part of shape) are important to the <A
HREF="index.html#hitmiss" >Hit-n-Miss</A> and related methods (see below).  This
specific kernel is only the first of a series of kernels that to locate
'corner' pixels of binary shapes within an image. </P>

The last 'kernel' shown above is fully defined over a large rectangular
(square) area. Also unlike the other kernels which only use values of
1 (white), 0 (black), or a special 'undefined' value, the values of this
kernel actually range from near-zero (almost-black) at the edges to a maximum
(pure-white) value in the center.  However such kernels can also use negative,
or even very large values, well beyond the normal range of other kernels.
Remember a kernel is really just an array of values, and these could have any
value, not just a 0 to 1 range. </P>

This type of kernel is especially important in '<A HREF="../convolve/index.html#intro"
>Convolution Operations</A>', a special method that has been around far longer
than morphology itself.  As a result IM has a very large number of built-in,
or 'Named' kernels of this type.  This will be looked at in more detail in the
next section of IM Examples, <A HREF="../convolve/index.html" >Convolution of
Images</A>'. </P>

Now as I already mentioned, kernels are not really images.  They are simply an
array of floating point values.  We will be looking at these actual values
(which was converted into an image for viewing, above) latter. </P>


<A NAME="morphology"></A>
<H3>Morphology Operator</H3>

The "<CODE><A HREF="../../../html/www/command-line-options.html#morphology" >-morphology</A></CODE>"
operator is a very complex, as it provides the user with a lot of controls
over its actions. </P>

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE DO_NOT_EXECUTE>
  -morphology {<I>method</I>}[:{<I>iterations</I>}] <!--
                  -->  {<I>kernel</I>}[:[<I>k_args</I>}]
</CODE></PRE></TD></TR></TABLE>
</DIV></P>

Note that you need to provide at least two items, the morphology
'<I>method</I>', telling the operator type of operation you want to apply to
the image, and a '<I>kernel</I>' specifying what 'neighbouring' pixels should
effect the final result.  Both are equally important and both can have far
reaching consequences. </P>

You can get a list of the methods that are available using
"<B><CODE>-list&nbsp;morphology</CODE></B>". A list of the built-in kernels
that we have included in IM can be see with
"<B><CODE>-list&nbsp;kernel</CODE></B>". We will go though the various
methods, and the kernels that those methods may use later.  </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/warning.gif"  WIDTH=28 HEIGHT=28
    ><IMG SRC="../img_www/space.gif"   WIDTH=12 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  The "<CODE><A HREF="../../../html/www/command-line-options.html#morphology" >-morphology</A></CODE>"
  operator (basic methods) and the initial set of kernels was added to
  ImageMagick version 6.5.9-0 by myself, while I was on a vacation in China.
  December 2009 to January 2010. </P>

  However it is posible to perform simplified 'square' kernel morphology using
  the older and closely related "<CODE><A HREF="../../../html/www/command-line-options.html#convolve"
  >-convolve</A></CODE>" method.  See <A HREF="index.html#alturnative" > Alternative
  Basic Morphology Techniques</A> below. </P>

</I></FONT></TD></TR></TABLE></P>


<A NAME="kernel"></A>
<A NAME="man_kernels"></A>
<H3>Basic Built-In Shape Kernels</H3>

As the kernel is common to all the morphology methods, and the results of the
various methods depend heavily on the actual kernel selected, we will first
look at how you can define or select a kernel to use. </P>

A good selection of kernels have already predefined for you and often you need
look no further than these.  You can get a list of the pre-defined built-in
kernels by using "<CODE>-list&nbsp;kernel</CODE>"

All kernels have a specific size, typically a square which has an odd number of
pixels per side, the center of which is the 'origin' of the kernel.  However
as you will see the "<CODE><A HREF="../../../html/www/command-line-options.html#morphology"
>-morphology</A></CODE>" operator is not restricted to this limitation. </P>

The most common <I>k_argument</I> used for built-in kernels, and
generally the first argument given is a '<I>radius</I>'.  This defines how big
the typical odd-sized square neighbourhood of the kernel will be.  The final
kernel size will generally be twice the radius plus one (for the center
pixel).  That is a '<I>radius</I>' of '<CODE>2</CODE>' will create a kernel
that is 5&times;5 pixels square. </P>

While a '<I>radius</I>' typically defines the size of the final kernel, and
thus the overall speed of the morphological operation over the images, it may
not be the most important factor, especially for <A HREF="index.html#convolve_kernels"
>Convolution Kernels</A> where the values have a greater effect on results
than the kernels size. </P>

If a '<I>radius</I>' set to 0, or left undefined the '<I>radius</I>' will
automatically default to some reasonable or most commonly used value,
depending on the kernel involved. </P>


<!--<CODE EXECUTE>
   kernel2image -35.2 -m "Unity"    kernel_unity.gif
</CODE>-->
  <A HREF="kernel_unity.gif"
      ><IMG SRC="kernel_unity.gif"
            ALIGN=right HSPACE=10 BORDER=0 ALT="[IM Output]"></A>

<A NAME="unity"></A>
<H4>Unity</H4>

This is a special kernel that is specifically used when you need a 'No-Op'
kernel.  Most morphological methods using this kernel will either re-produce
the original image, or generate a blank result. </P>

The kernel has no arguments. </P>

This exact same single element kernel can also be generated using '<CODE><A
HREF="index.html#disk" >Disk:0.5</A></CODE>', which also allow you to specify a scaling
argument as part of the kernels generation. </P>

  <A HREF="kernel_diamond.gif"
      ><IMG SRC="kernel_diamond.gif"
            ALIGN=right HSPACE=10 BORDER=0 ALT="[IM Output]"></A>

<A NAME="diamond"></A>
<H4>Diamond</H4>

The most minimal, though perhaps not the simplist kernel is the
'<B><CODE>Diamond</CODE></B>' built-in kernel.

A simple way to look at the basic kernel is to use a <A HREF="index.html#dilate"
>Dilate</A> morphology method, on an image containing a single white pixel on
a black background.  This basically expands the single pixel into the 'shape'
of the kernels neighbourhood. </P>

Here is the result of a  using '<CODE>Dilate</CODE>' with the minimal
'<CODE>Diamond</CODE>' built-in kernel, and scaling the result larger to make
it more visible.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert xc: -bordercolor black -border 5x5 pixel.gif
  convert pixel.gif -scale 800% pixel_mag.gif
  convert pixel.gif -morphology Dilate Diamond \
                    -scale 800% k_diamond.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="pixel.gif"
     ><IMG SRC="pixel_mag.gif"               WIDTH=88 HEIGHT=88
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="k_diamond.gif"
     ><IMG SRC="k_diamond.gif"      WIDTH=88 HEIGHT=88
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  Remember all the kernel image results in this area of IM examples have been
  enlarged to allow you to see the individual pixels.  In reality all the
  kernels and the results we are showing are very small, as they should be. In
  this case the image being dilated only 11&times;11 pixels in size and has
  been scaled 8 times for display.
</I></FONT></TD></TR></TABLE></P>

This is actually a fairly good kernel for morphological operations, and
basically defines the most minimal practical neighbourhood: the original
pixel, plus the four pixels in direct contact.  Another name for this type of
kernel is a 'Z<sub>4</sub>' structuring element.  It looks rather like a tiny
'plus' sign.  The diamond shape only becomes apparent as the radius increases.
</P>

The optional <I>k_arg</I> for this kernel can take two values, like
this...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE DO_NOT_EXECUTE>
     Diamond[:{<I>radius</I>}[,{<I>scale</I>}]]
</CODE></PRE></TD></TR></TABLE>
</DIV></P>

For all the shape kernels the most important argument is <I>radius</I> and as
mentioned before is an integer that represents the distance from the center
'origin' to the nearest edge. </P>

As such the final '<CODE>Diamond</CODE>' kernel is a square (2 times
<I>radius</I> plus 1) containing the diamond shape.  Here is the results of
using a larger <I>radius</I> to generate a large kernel. </P>

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE SCRIPT>
  for r in 1 2 3 4; do
    convert pixel.gif -morphology Dilate Diamond:$r -scale 800% k_diamond:$r.gif
  done
</CODE></PRE></TD></TR></TABLE>
<TABLE><TR VALIGN=top>
<TD ALIGN=center>
  <A HREF="k_diamond_1.gif"
      ><IMG SRC="k_diamond_1.gif"          WIDTH=88 HEIGHT=88
            ALIGN=middle VSPACE=2 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
  <BR>Diamond:1
  <BR><FONT SIZE=-1>(default)</FONT>
<TD ALIGN=center>
  <A HREF="k_diamond_2.gif"
      ><IMG SRC="k_diamond_2.gif"          WIDTH=88 HEIGHT=88
            ALIGN=middle VSPACE=2 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
  <BR>Diamond:2
<TD ALIGN=center>
  <A HREF="k_diamond_3.gif"
      ><IMG SRC="k_diamond_3.gif"          WIDTH=88 HEIGHT=88
            ALIGN=middle VSPACE=2 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
  <BR>Diamond:3
<TD ALIGN=center>
  <A HREF="k_diamond_4.gif"
      ><IMG SRC="k_diamond_4.gif"          WIDTH=88 HEIGHT=88
            ALIGN=middle VSPACE=2 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
  <BR>Diamond:4
</TR></TABLE>
</DIV></P>

The other <I>k_argument</I> is <I>scale</I> which defaults to a value of
1.0.  Typically this is used to change the actual values used by the kernel to
form the shape.  This is generally only important to special methods such as
<A HREF="index.html#convolve" >Convolve</A>, and <A HREF="index.html#greyscale" >Grey-scale
Morphology</A>. </P>


  <A HREF="kernel_square.gif"
      ><IMG SRC="kernel_square.gif"
            ALIGN=right HSPACE=10 BORDER=0 ALT="[IM Output]"></A>

<A NAME="square"></A>
<H4>Square</H4>

The '<B><CODE>Square</CODE></B>' is the most commonly used kernel for
morphology, as it is easiest to apply using other alterantive techniques.
However it is not the most minimal kernel (see '<CODE><A HREF="index.html#diamond"
>Diamond</A></CODE>' above). </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>

By default the '<CODE>Square</CODE>' kernel uses a 3x3 pixel neighbourhood
around the 'center'.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert pixel.gif  -morphology Dilate Square -scale 800% k_square.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="k_square.gif"
     ><IMG SRC="k_square.gif"            WIDTH=88 HEIGHT=88
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Basically this means that all 8 neighbours of the original pixel will be
classed as part of that pixels neighbourhood.  As a result it is a good kernel
for averaging pixels, or expanding/shrinking some shape by one pixel.  </P>

As with all the shape kernels it takes the same <I>k_arguments</I> as
shown for the <A HREF="index.html#diamond" >Diamond Kernel</A> above, with the first
argument <I>radius</I> being the most important.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE SCRIPT>
  for r in 1 2 3 4; do
    convert pixel.gif  -morphology Dilate Square:$r -scale 800% k_square:$r.gif
  done
</CODE></PRE></TD></TR></TABLE>
<TABLE><TR VALIGN=top>
<TD ALIGN=center>
  <A HREF="k_square_1.gif"
      ><IMG SRC="k_square_1.gif"          WIDTH=88 HEIGHT=88
            ALIGN=middle VSPACE=2 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
  <BR>Square:1
  <BR><FONT SIZE=-1>(default)</FONT>
<TD ALIGN=center>
  <A HREF="k_square_2.gif"
      ><IMG SRC="k_square_2.gif"          WIDTH=88 HEIGHT=88
            ALIGN=middle VSPACE=2 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
  <BR>Square:2
<TD ALIGN=center>
  <A HREF="k_square_3.gif"
      ><IMG SRC="k_square_3.gif"          WIDTH=88 HEIGHT=88
            ALIGN=middle VSPACE=2 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
  <BR>Square:3
<TD ALIGN=center>
  <A HREF="k_square_4.gif"
      ><IMG SRC="k_square_4.gif"          WIDTH=88 HEIGHT=88
            ALIGN=middle VSPACE=2 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
  <BR>Square:4
</TR></TABLE>
</DIV></P>

The default (radius=1) for this kernel as mentioned is a 3&times;3 square, and
is commonly known as a 'Z<sub>8</sub>' structuring element (for the number of
immediate neighbours involved). </P>


  <A HREF="kernel_octagon.gif"
      ><IMG SRC="kernel_octagon.gif"
            ALIGN=right HSPACE=10 BORDER=0 ALT="[IM Output]"></A>

<A NAME="octagon"></A>
<H4>Octagon</H4>

The '<B><CODE>Octagon</CODE></B>' kernel is a 8 sided shaped kernel. And was
specifically designed to match the '<CODE><A HREF="http://legacy.imagemagick.org/Usage/morphology/octagonal" >Octagonal
Distance Metric</A></CODE>'. Do not confuse the two as they are very different
kernels. </P>

Here are the resulting kernels for small radii...
<!--<CODE EXECUTE>
   kernel2image -20.2 -m "Octagon:1"  kernel_octagon_1.gif
   kernel2image -15.2 -m "Octagon:2"  kernel_octagon_2.gif
   kernel2image -12.2 -m "Octagon:3"  kernel_octagon_3.gif
   kernel2image -10.1 -m "Octagon:4"  kernel_octagon_4.gif
   kernel2image -9.1  -m "Octagon:5"  kernel_octagon_5.gif
</CODE>-->
<DIV ALIGN=center>
  <A HREF="kernel_octagon_1.gif"
      ><IMG SRC="kernel_octagon_1.gif"
            ALIGN=middle VSPACE=2 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
  <A HREF="kernel_octagon_2.gif"
      ><IMG SRC="kernel_octagon_2.gif"
            ALIGN=middle VSPACE=2 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
  <A HREF="kernel_octagon_3.gif"
      ><IMG SRC="kernel_octagon_3.gif"
            ALIGN=middle VSPACE=2 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
  <A HREF="kernel_octagon_4.gif"
      ><IMG SRC="kernel_octagon_4.gif"
            ALIGN=middle VSPACE=2 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
  <A HREF="kernel_octagon_5.gif"
      ><IMG SRC="kernel_octagon_5.gif"
            ALIGN=middle VSPACE=2 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

Note that at radius 1, you get the same kernel as a "Diamond" kernel. Because
of this the default octagon size is of radius '<CODE>2</CODE>'. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  From this point on I will be using a special <A HREF="index.html#kernel2image"
  >kernel2image</A> script to generate images of the kernels as they are much
  clearer than using a raw "dilate-scale" method (as above).  Remember however
  the kernels are in generally very small, though Octagon and Disk kernels (see
  next) can become very large for specific uses. </P>

</I></FONT></TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  The "<CODE>Octagon</CODE>" kernel was added in IM v6.6.9-4, along with
  the "<CODE><A HREF="index.html#octagonal" >Octagonal</A></CODE>" distance kernel.
</I></FONT></TD></TR></TABLE></P>

  <A HREF="kernel_disk.gif"
      ><IMG SRC="kernel_disk.gif"
            ALIGN=right HSPACE=10 BORDER=0 ALT="[IM Output]"></A>

<A NAME="disk"></A>
<H4>Disk</H4>

The '<CODE>Disk</CODE>' kernel is as you would expect, a circular shape. And
is commonly used when a very large morphological kernel is needed. Note
however it is an aliased boolean circle. </P>

However the <I>radius</I> argument for a disk can be a floating point number,
which allows you to produce a quite a range of shapes, using small radii. </P>

<!--<CODE EXECUTE>
   kernel2image -30.2 -m "Disk:0.5"  kernel_disk_01.gif
   kernel2image -20.2 -m "Disk:1.0"  kernel_disk_02.gif
   kernel2image -20.2 -m "Disk:1.5"  kernel_disk_03.gif
   kernel2image -15.2 -m "Disk:2.0"  kernel_disk_04.gif
   kernel2image -15.2 -m "Disk:2.5"  kernel_disk_05.gif
   kernel2image -15.2 -m "Disk:2.9"  kernel_disk_06.gif
   kernel2image -12.1 -m "Disk:3.5"  kernel_disk_07.gif
   kernel2image -12.1 -m "Disk:3.9"  kernel_disk_08.gif
   kernel2image -10.1 -m "Disk:4.3"  kernel_disk_09.gif
   kernel2image -10.1 -m "Disk:4.5"  kernel_disk_10.gif
   kernel2image -9.1  -m "Disk:5.3"  kernel_disk_11.gif
</CODE>-->
<DIV ALIGN=center>
  <A HREF="kernel_disk_01.gif"
      ><IMG SRC="kernel_disk_01.gif"
            ALIGN=middle VSPACE=2 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
  <A HREF="kernel_disk_02.gif"
      ><IMG SRC="kernel_disk_02.gif"
            ALIGN=middle VSPACE=2 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
  <A HREF="kernel_disk_03.gif"
      ><IMG SRC="kernel_disk_03.gif"
            ALIGN=middle VSPACE=2 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
  <A HREF="kernel_disk_04.gif"
      ><IMG SRC="kernel_disk_04.gif"
            ALIGN=middle VSPACE=2 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
  <A HREF="kernel_disk_05.gif"
      ><IMG SRC="kernel_disk_05.gif"
            ALIGN=middle VSPACE=2 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
  <A HREF="kernel_disk_06.gif"
      ><IMG SRC="kernel_disk_06.gif"
            ALIGN=middle VSPACE=2 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
<BR>
  <A HREF="kernel_disk_07.gif"
      ><IMG SRC="kernel_disk_07.gif"
            ALIGN=middle VSPACE=2 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
  <A HREF="kernel_disk_08.gif"
      ><IMG SRC="kernel_disk_08.gif"
            ALIGN=middle VSPACE=2 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
  <A HREF="kernel_disk_09.gif"
      ><IMG SRC="kernel_disk_09.gif"
            ALIGN=middle VSPACE=2 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
  <A HREF="kernel_disk_10.gif"
      ><IMG SRC="kernel_disk_10.gif"
            ALIGN=middle VSPACE=2 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
  <A HREF="kernel_disk_11.gif"
      ><IMG SRC="kernel_disk_11.gif"
            ALIGN=middle VSPACE=2 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

The '<CODE>Disk:4.3</CODE>' kernel is the default, and what I regard as the
first true disk shape. Disks of this size or larger are especially good for
generally rounding and smoothing image shapes. </P>

The final size of the kernel containing the disk is the '<I>radius</I>' value
rounded down, times 2 plus 1. As such the default '<CODE>Disk:4.3</CODE>'
kernel has a kernel size radius of 4, making the final kernel size 4 times
2 plus 1, and generating a 9&times;9 kernel to hold the disk shape. </P>

Note that a value less than one (but not zero) will always produce a single
pixel kernel, though that is not very useful. After that the kernel tends to
mostly produce kernels that can also be generated using the previous kernel
types.  It is only as the radius gets large that true disk-shaped kernels
start to emerge.  </P>

The most important thing to note is that a disk with a fractional radius works
a lot better than using an integer radius.   Adding a fraction of about 0.3 to
0.5 is generally recommended, to avoid generating an off looking single pixel
on the sides of the disk. </P>


  <A HREF="kernel_plus.gif"
      ><IMG SRC="kernel_plus.gif"
            ALIGN=right HSPACE=10 BORDER=0 ALT="[IM Output]"></A>

<A NAME="plus"></A>
<H4>Plus</H4>

The '<CODE>Plus</CODE>' kernel is actually a little different to the other
morphological shape kernels, in that it is designed to represent a specific
'shape' rather than a simple 'neighbourhood' around a pixel. </P>

Using a larger '<I>radius</I>' with this kernel does not simply increase the
size of the kernel, but lengthens the arms of the resulting plus sign.  The
thickness of the arms however does not increase. </P>

<!--<CODE EXECUTE>
   kernel2image -20.2 -m "Plus:1"  kernel_plus_1.gif
   kernel2image -15.2 -m "Plus:2"  kernel_plus_2.gif
   kernel2image -10.1 -m "Plus:3"  kernel_plus_3.gif
   kernel2image -9.1  -m "Plus:4"  kernel_plus_4.gif
</CODE>-->
<DIV ALIGN=center>
  <A HREF="kernel_plus_1.gif"
      ><IMG SRC="kernel_plus_1.gif"
            ALIGN=middle VSPACE=2 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
  <A HREF="kernel_plus_2.gif"
      ><IMG SRC="kernel_plus_2.gif"
            ALIGN=middle VSPACE=2 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
  <A HREF="kernel_plus_3.gif"
      ><IMG SRC="kernel_plus_3.gif"
            ALIGN=middle VSPACE=2 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
  <A HREF="kernel_plus_4.gif"
      ><IMG SRC="kernel_plus_4.gif"
            ALIGN=middle VSPACE=2 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

The default size of a '<CODE>Plus</CODE>' kernel is a radius of 2, producing
2 pixel 'arms' around the central 'origin'.  A '<CODE>Plus:1</CODE>' kernel
happens to be the same as the default '<CODE>Diamond</CODE>' kernel. </P>

Note that a '<CODE>Plus</CODE>' kernel is a generally not used for normal
morphological methods, and should be avoided for such purposes.  However it is
a very useful if you are wanting to find and highlight single points in an
image, such as I do later to display <A HREF="index.html#skeleton_info" >Skeleton
Information</A>.  Basically it provides a method of <A HREF="../draw/index.html#symbols"
>Drawing Symbols</A>, without needing to know exactly where the individual
'points' are located in the image. </P>


<!--<CODE EXECUTE>
   kernel2image -13.2 -m "Cross"   kernel_cross.gif
</CODE>-->
  <A HREF="kernel_cross.gif"
      ><IMG SRC="kernel_cross.gif"
            ALIGN=right HSPACE=10 BORDER=0 ALT="[IM Output]"></A>

<A NAME="cross"></A>
<H4>Cross</H4>

The '<CODE>Cross</CODE>' kernel is exactly like '<CODE><A HREF="index.html#plus"
>Plus</A></CODE>' but rotated 45 degrees.  It is also just a special kernel
shape suitable for expanding pixels to mark the locations of various points
</P>

<!--<CODE EXECUTE>
   kernel2image -20.2 -m "Cross:1"  kernel_cross_1.gif
   kernel2image -13.2 -m "Cross:2"  kernel_cross_2.gif
   kernel2image -10.1 -m "Cross:3"  kernel_cross_3.gif
   kernel2image -9.1  -m "Cross:4"  kernel_cross_4.gif
</CODE>-->
<DIV ALIGN=center>
  <A HREF="kernel_cross_1.gif"
      ><IMG SRC="kernel_cross_1.gif"
            ALIGN=middle VSPACE=2 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
  <A HREF="kernel_cross_2.gif"
      ><IMG SRC="kernel_cross_2.gif"
            ALIGN=middle VSPACE=2 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
  <A HREF="kernel_cross_3.gif"
      ><IMG SRC="kernel_cross_3.gif"
            ALIGN=middle VSPACE=2 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
  <A HREF="kernel_cross_4.gif"
      ><IMG SRC="kernel_cross_4.gif"
            ALIGN=middle VSPACE=2 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

<!--<CODE EXECUTE>
   kernel2image -10.1 -m "Ring"   kernel_ring.gif
</CODE>-->
  <A HREF="kernel_ring.gif"
      ><IMG SRC="kernel_ring.gif"
            ALIGN=right HSPACE=10 BORDER=0 ALT="[IM Output]"></A>


<A NAME="ring"></A>
<H4>Ring</H4>

The '<CODE>Ring</CODE>' kernel, like the '<CODE><A HREF="index.html#plus"
>Plus</A></CODE>' kernel is also designed as a special 'shape' kernel for
marking pixels and generating patterns on images. </P>

However it does not just take one radius, it can take two radii and is defined
in the same way as <A HREF="index.html#disk" >Disk Kernels</A>...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE DO_NOT_EXECUTE>
     Ring[:{<I>radius1</I>}[,{<I>radius2</I>}[,{<I>scale</I>}]]]
</CODE></PRE></TD></TR></TABLE>
</DIV></P>

What it does it turn 'on' any pixel that falls between the two radii,
regardless of the order of the two radii given.  If no radii are given it
defaults to a radii of '<CODE>2.5</CODE>' and '<CODE>3.5</CODE>', producing
a '<CODE>Ring:2.5,3.5</CODE>', which looks like a hollow octagonal shaped
ring, that is ideal for circling a pixel. </P>

By varying the two radii you can create a 'ring' of any size and thickness.
Small changes to the radii will add and remove very small numbers of pixels
around the edges, allowing you for fine control of the look of the ring. </P>

If the two radii are within 1 pixel of each other you can also generate a ring
consisting of sparsly separated dots, which can be useful as a special purpose
neighbourhood.  Small radii will also generate box-like kernels, that can also
be useful. </P>

If the second radius is not given it will default to a value of
'<CODE>0.5</CODE>' which effectively defines a full disk, but without the
center 'origin' pixel.  In otherwords, a disk kernel but excluding the
'origin' pixel. </P>

Here are examples of many of the '<CODE>Ring</CODE>' kernels that can be
generated...</P>

<!--<CODE EXECUTE>
   kernel2image -20.1 -m "Ring:1"         kernel_ring_01.gif
   kernel2image -20.1 -m "Ring:1.5"       kernel_ring_02.gif
   kernel2image -20.1 -m "Ring:1,1.5"     kernel_ring_03.gif
   kernel2image -15.1 -m "Ring:2"         kernel_ring_04.gif
   kernel2image -15.1 -m "Ring:1,2"       kernel_ring_05.gif
   kernel2image -15.1 -m "Ring:1.5,2"     kernel_ring_06.gif
   kernel2image -15.1 -m "Ring:1,2.5"     kernel_ring_07.gif
   kernel2image -15.1 -m "Ring:1.5,2.5"   kernel_ring_08.gif
   kernel2image -15.1 -m "Ring:1.5,2.9"   kernel_ring_09.gif
   kernel2image -15.1 -m "Ring:2,2.5"     kernel_ring_10.gif
   kernel2image -12.1 -m "Ring:2,3.5"     kernel_ring_11.gif
   kernel2image -12.1 -m "Ring:2.5,3.5"   kernel_ring_12.gif
   kernel2image -12.1 -m "Ring:2.9,3.5"   kernel_ring_13.gif
   kernel2image -12.1 -m "Ring:3,3.5"     kernel_ring_14.gif
   kernel2image -12.1 -m "Ring:3,3.9"     kernel_ring_15.gif
   kernel2image -10.1 -m "Ring:2.5,4.3"   kernel_ring_16.gif
   kernel2image -10.1 -m "Ring:3.5,4.3"   kernel_ring_17.gif
   kernel2image -10.1 -m "Ring:3.9,4.5"   kernel_ring_18.gif
   kernel2image -10.1 -m "Ring:4,4.5"     kernel_ring_19.gif
   kernel2image -10.1 -m "Ring:4.3,4.5"   kernel_ring_20.gif
   kernel2image -9.1  -m "Ring:4.3,5.3"   kernel_ring_21.gif
</CODE>-->

<DIV ALIGN=center>
  <A HREF="kernel_ring_01.gif"
      ><IMG SRC="kernel_ring_01.gif"
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
  <A HREF="kernel_ring_02.gif"
      ><IMG SRC="kernel_ring_02.gif"
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
  <A HREF="kernel_ring_03.gif"
      ><IMG SRC="kernel_ring_03.gif"
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
  <A HREF="kernel_ring_04.gif"
      ><IMG SRC="kernel_ring_04.gif"
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
  <A HREF="kernel_ring_05.gif"
      ><IMG SRC="kernel_ring_05.gif"
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
  <A HREF="kernel_ring_06.gif"
      ><IMG SRC="kernel_ring_06.gif"
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
  <A HREF="kernel_ring_07.gif"
      ><IMG SRC="kernel_ring_07.gif"
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
  <A HREF="kernel_ring_08.gif"
      ><IMG SRC="kernel_ring_08.gif"
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
  <A HREF="kernel_ring_09.gif"
      ><IMG SRC="kernel_ring_09.gif"
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
  <A HREF="kernel_ring_10.gif"
      ><IMG SRC="kernel_ring_10.gif"
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
  <A HREF="kernel_ring_11.gif"
      ><IMG SRC="kernel_ring_11.gif"
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
  <A HREF="kernel_ring_12.gif"
      ><IMG SRC="kernel_ring_12.gif"
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
  <A HREF="kernel_ring_13.gif"
      ><IMG SRC="kernel_ring_13.gif"
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
  <A HREF="kernel_ring_14.gif"
      ><IMG SRC="kernel_ring_14.gif"
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
  <A HREF="kernel_ring_15.gif"
      ><IMG SRC="kernel_ring_15.gif"
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
  <A HREF="kernel_ring_16.gif"
      ><IMG SRC="kernel_ring_16.gif"
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
  <A HREF="kernel_ring_17.gif"
      ><IMG SRC="kernel_ring_17.gif"
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
  <A HREF="kernel_ring_18.gif"
      ><IMG SRC="kernel_ring_18.gif"
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
  <A HREF="kernel_ring_19.gif"
      ><IMG SRC="kernel_ring_19.gif"
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
  <A HREF="kernel_ring_20.gif"
      ><IMG SRC="kernel_ring_20.gif"
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
  <A HREF="kernel_ring_21.gif"
      ><IMG SRC="kernel_ring_21.gif"
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

As you can see you have a lot of possibilities, by carefully adjusting the two
radii, and provides a good way of showing locations of interest in an image.
</P>


  <A HREF="kernel_rectangle.gif"
      ><IMG SRC="kernel_rectangle.gif"
            ALIGN=right HSPACE=10 BORDER=0 ALT="[IM Output]"></A>

<A NAME="rectangle"></A>
<H4>Rectangle</H4>

The '<CODE>Rectangle</CODE>' kernel is closely related to the '<CODE><A
HREF="index.html#k_square" >Square</A></CODE>' kernel above, and by default
produces the same square 3x3 kernel.  But rather than a simple radius
argument, you can give a '<I>geometry</I>' argument to specify the
exact size of the rectangular kernel wanted. </P>

Here are some specifications and an image of the kernels they produce.

<!--<CODE EXECUTE>
   kernel2image -35.2 -m "Rectangle:2x2"      kernel_rect_1.gif
   kernel2image -25.2 -m "Rectangle"          kernel_rect_2.gif
   kernel2image -20.2 -m "Rectangle:4x2"      kernel_rect_3.gif
   kernel2image -20.2 -m "Rectangle:4"        kernel_rect_4.gif
   kernel2image -15.1 -m "Rectangle:7x3"      kernel_rect_5.gif
   kernel2image -15.1 -m "Rectangle:7x1"      kernel_rect_6.gif
   kernel2image -15.1 -m "Rectangle:7x1+1+0"  kernel_rect_7.gif
   kernel2image -15.1 -m "Rectangle:7x1+6+0"  kernel_rect_8.gif
</CODE>-->
<DIV ALIGN=center>
  <A HREF="kernel_rect_1.gif"
      ><IMG SRC="kernel_rect_1.gif"
            ALIGN=middle VSPACE=2 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
  <A HREF="kernel_rect_2.gif"
      ><IMG SRC="kernel_rect_2.gif"
            ALIGN=middle VSPACE=2 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
  <A HREF="kernel_rect_3.gif"
      ><IMG SRC="kernel_rect_3.gif"
            ALIGN=middle VSPACE=2 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
  <A HREF="kernel_rect_4.gif"
      ><IMG SRC="kernel_rect_4.gif"
            ALIGN=middle VSPACE=2 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
<BR>
  <A HREF="kernel_rect_5.gif"
      ><IMG SRC="kernel_rect_5.gif"
            ALIGN=middle VSPACE=2 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
  <A HREF="kernel_rect_6.gif"
      ><IMG SRC="kernel_rect_6.gif"
            ALIGN=middle VSPACE=2 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
  <A HREF="kernel_rect_7.gif"
      ><IMG SRC="kernel_rect_7.gif"
            ALIGN=middle VSPACE=2 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
  <A HREF="kernel_rect_8.gif"
      ><IMG SRC="kernel_rect_8.gif"
            ALIGN=middle VSPACE=2 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

By default the kernel will try to set the 'origin' of the neighbourhood to the
exact 'center' of the kernel. But for an even-sized rectangle, it will pick
the point to the immediate top and/or left of the center as appropriate.

However you can also specify off-centered origins as well. </P>

This particular kernel is also good at defining long horizontal and vertical
lines, allowing you to search for such objects within images. More on this
later. </P>

At this time you can not provide a <I>scale</I> factor for a rectangle.  All
its kernel values will be set to 1.0 only. </P>

<A NAME="user"></A>
<H4>User Defined DIY Kernels</H4>

You are not restricted to just the built-in kernels, but can also specify your
own kernel, and giving the exact values you want the kernel to use... </P>

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE DO_NOT_EXECUTE>
   "[{<I>geometry</I>}:] {<I>value</I>}, {<I>value</I>}, {<I>value</I>},....."
</CODE></PRE></TD></TR></TABLE>
</DIV></P>

The '<I>geometry</I>' specification is basically exactly like the argument of
the previous '<CODE><A HREF="index.html#k_rectangle" >Rectangle</A></CODE>' kernel.  It
gives the size of the kernel, and optionally the 'offset' of the neighbourhood
'origin'.  If only one number is supplied, it is the dimensions for an square
kernel will be assumed. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/warning.gif"  WIDTH=28 HEIGHT=28
    ><IMG SRC="../img_www/space.gif"   WIDTH=12 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  Remember the geometry value is NOT a 'radius' argument but the
  overall kernal size.
</I></FONT></TD></TR></TABLE></P>

If no '<I>geometry</I>' or '<CODE>:</CODE>' is specified, then you are using
the 'old' style specification. An odd sized square kernel big enough to hold
all the values given will be generated. This is not recommended and only
provided for backward compatibility with older versions of ImageMagick. </P>

After the '<CODE>:</CODE>' (which is required after a '<I>geometry</I>'
specification) you then supply <I>width</I> &times; <I>height</I> floating
point values separated by commas and/or whitespace.  A special value of
'<CODE>NaN</CODE>' (meaning "Not a Number") or a '<CODE>-</CODE>' on its own,
can be used to specify that this point in the kernel is not part of the
morphological neighbourhood. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

For example here is a specification for a square kernel of width 3, that can
be used for convolution blurring of the single pixel image.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert pixel.gif   -morphology Convolve \
            "3:  0.3,0.6,0.3   0.6,1.0,0.6   0.3,0.6,0.3" \
                                         -scale 800%  k_user_3.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="k_user_3.gif"
     ><IMG SRC="k_user_3.gif"            WIDTH=88 HEIGHT=88
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

With a single pixel, <A HREF="index.html#convolve" >Convolve</A> works almost the same
as <A HREF="index.html#dilate" >Dilate</A>, however <A HREF="index.html#convolve" >Convolve</A>
uses the kernels values, expanding and adding neighbouring values together. <A
HREF="index.html#dilate" >Dilate</A> on the other hand generally works using an on/off
(boolean) shape and the maximum of all the neighbours.  However when applied
on a single isolated pixel with a boolean shape you get the same result.  </P>

Note how you can add extra spacing (or even newlines) to the input string so
as to separate the the individual rows of the rectangular kernel definition.
</P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

And here I defined a 5&times;3 rectangular area, but use the special 'nan'
(not a number) values to cut off the corners to make an oval shaped kernel...

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert pixel.gif   -morphology Dilate \
            "5x3: nan,1,1,1,nan   1,1,1,1,1   nan,1,1,1,nan " \
                                    -scale 800%   k_user_5x3.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="k_user_5x3.gif"
     ><IMG SRC="k_user_5x3.gif"            WIDTH=88 HEIGHT=88
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

And finally here is an example of specifying a rectangular neighbourhood, that
forms a 'L' shape around the 'origin'.  I used '-' instead of 'nan' to specify
the parts that is not part of the kernel.  Note that the origin of this kernel
is not even part of its own neighbourhood, it can be located anywhere inside
the rectangular bounds of the kernel.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert pixel.gif   -morphology Dilate \
            "2x3+1+1:   1,-   1,-   1,1   "  -scale 800% k_lman.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="http://legacy.imagemagick.org/Usage/morphology/k_lspace.gif"
     ><IMG SRC="k_lman.gif"            WIDTH=88 HEIGHT=88
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

As you can see user kernel specification is very flexible, allowing you to
specify just about any type of kernel you like, whether it is a convolution
kernel with lots of fractions, or a shaped kernel with 'not part of
neighbourhood' elements, for morphological methods.  </P>


<A NAME="image2kernel"></A>
<H4>Convert an Image to an User Kernel</H4>

To make it easier to generate DIY kernels you can use the  "<CODE><A
HREF="../scripts/image2kernel" >image2kernel</A></CODE>" script to create
kernels.  For example here I convert a small flag <NOBR>(&nbsp;<IMG
SRC="../images/flag.gif" ALIGN=bottom>&nbsp;)</NOBR> into an user kernel data file
("<CODE><A HREF="flag_kernel.dat.html" >flag_kernel.dat</A></CODE>"), then use it
to dilate an image with a couple of pixels in it.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 80x80 xc:black -fill white \
          -draw 'point 20,15 point 55,30 point 40,60'  points_pixels.gif
  image2kernel -qgm flag.gif flag_kernel.dat

  convert  points_pixels.gif \
             -morphology Dilate @flag_kernel.dat \
           flagged_points.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="points_pixels.gif"
     ><IMG SRC="points_pixels.gif"            WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/mph_dilate.gif" ALIGN=middle WIDTH=20 HEIGHT=30 ALT="-">
  <A HREF="kernel_flag.gif"
     ><IMG SRC="kernel_flag.gif"
           ALIGN=top VSPACE=2 HSPACE=18 BORDER=0 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" WIDTH=20 HEIGHT=20 ALIGN=middle ALT="==>">
  <A HREF="flagged_points.gif"
     ><IMG SRC="flagged_points.gif"            WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=5 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</DIV>
<!--<CODE EXECUTE>
   kernel2image -6.1 -m  -ml "Flag"  @flag_kernel.dat  kernel_flag.gif
</CODE>-->
See also <A HREF="index.html#kernel2image" >Generating an Image of the Kernel</A> below,
which can generate images (or generate enlarged pretty versions) of a kernel.
</P>

This technique is also talked about in <A HREF="../draw/index.html#symbol_alts"
>Alternatives to Drawing Symbols</A>. </P>

<BR>

<A NAME="iteration"></A>
<H3>Iterating (Repeating) Morphology Operations</H3>

As you have seen you can generate a larger kernel, so as to apply a morphology
over a larger neighbourhood.  </P>

However in most cases a faster alternative to using a larger kernel is to
simply repeat (iterate or loop) the morphology operator multiple times.  This
means that the effect of that operator will be carried further, having the
same basic effect as an using a larger kernel, but without the added
computational cost of using a larger kernel. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>

For example, here is a dialtion of a single pixel using a
'<CODE>Diamond:3</CODE>' kernel...

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE DO_NOT_EXECUTE>
  convert pixel.gif  -morphology Dilate Diamond:3 -scale 800% k_diamond_x3.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="http://legacy.imagemagick.org/Usage/morphology/k_diamond:3.gif"
     ><IMG SRC="http://legacy.imagemagick.org/Usage/morphology/k_diamond:3.gif"            WIDTH=88 HEIGHT=88
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>

But you can also achieve the same result by using a smaller
'<CODE>Diamond</CODE>' kernel (radius 1) three times...

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert pixel.gif  -morphology Dilate Diamond \
                     -morphology Dilate Diamond \
                     -morphology Dilate Diamond  -scale 800% k_diamond_x3.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="k_diamond_x3.gif"
     ><IMG SRC="k_diamond_x3.gif"            WIDTH=88 HEIGHT=88
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

You are still only using a very small 3x3 kernel, but repeating the basic
morphological operation three times to produce the same effect as if you are
using a larger kernel.  In fact repeating small kernels like this is actually
a good deal faster than using the much larger kernel. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/expert.gif"   WIDTH=23 HEIGHT=26
    ><IMG SRC="../img_www/space.gif"   WIDTH=17 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  A large 'Diamond:3' kernel has 81 elements to be processed per pixel in the
  image.  But repeating a smaller 'Diamond' kernal 3 times has 3&times;9, or
  27 kernel elements to process or pixel in the image.  In this case it is
  3 times faster. </P>

  This is speed increase isn't much in this case but he savings are much
  greater as the size of the kernels increase.

</I></FONT></TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

Because repeating a morphological operation is very common, rather than
repeating the operation multiple times, you can just ask IM to loop or iterate
the operation, that many times.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert pixel.gif   -morphology Dilate:3 Diamond -scale 800%  k_diamond_3.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="k_diamond_3.gif"
     ><IMG SRC="k_diamond_3.gif"            WIDTH=88 HEIGHT=88
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Note the difference between this and the first example. All that has happened
is that we have moved the '<CODE>:3</CODE>' from being the radius of the
'<CODE>Diamond</CODE>' kernel to the number of times the '<CODE>Dilate</CODE>'
method is to be used. </P>

Using an '<I>iteration</I>' to make the effective neighbourhood bigger, works
for most 'circular', or 'convex' kernels, such as a '<CODE>Square</CODE>' and
'<CODE>Diamond</CODE>'.  But <B>it does not work for all kernel types</B>.
</P>

For example for a non-convex kernel such as a '<CODE>Plus</CODE>' (which is
not a 'concave' shape) will produce a very unusual results.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

For example, this is not that same as going from '<CODE>Plus</CODE>' (radius
2) to a double size '<CODE>Plus:4</CODE>' kernel...

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert pixel.gif   -morphology Dilate:2 Plus  -scale 800%  k_plus_2.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="k_plus_2.gif"
     ><IMG SRC="k_plus_2.gif"            WIDTH=88 HEIGHT=88
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Note that if you use a '<I>iteration</I>' count of '<CODE>0</CODE>', the
morphology will do nothing. This is an useful way to 'turn off' the operator
when you don't want it to do anything, but do not want to remove it from the
command line. See <A HREF="index.html#showkernel" >Verbose Output Display</A>, below for
another use of a zero iteration count. </P>

Using a special value of '<CODE>-1</CODE>', will repeat the operation until no
more changes are seen in the image. That is the image reaches a point of
'convergence'.  This is however dangerous, as in some situations could lead
to very long running operations.  For an operation such as for
'<CODE>Dilate</CODE>' for example it would simply repeat the dilation until
the whole image was completely filled with white. Basically producing a sort
of runaway 'flood fill' (see the next example below). </P>

Iterating a '<CODE>Disk</CODE>' kernel to produce a larger neighbourhood
effect, is also generally not recommended.  That is because the
'<CODE>Disk</CODE>' kernel becomes a more accurate disk shape as the radius
gets larger, where an iterated disk, will enlarge not just the shape but the
errors (non-disk shape) of the kernel.  As such you may be better off using
a larger radius (which is slower) rather than iterating the operation (which
produces a more distorted disk) . </P>

However as a '<CODE>Disk</CODE>' radius becomes really large then
a combination of radius and multiple iterations, could produce a faster, but
still acceptable result. Caution and some experimentation with your specific
situation may be needed. </P>

<BR>

<A NAME="verbose"></A>
<H3>Verbose Output of Changes</H3>

If you want to see the results of iterating (repeating) a morphological
operation, you can set the "<CODE><A HREF="../../../html/www/command-line-options.html#define"
>-define debug=True</A></CODE>" option, which turns on the <A HREF="../basics/index.html#verbose"
>Verbose Operational Control</A>.  As the morphology operator iterates, it
will report an incrementing count of the iteration, and how many pixels in the
image were changed by each iterated step. The output is to standard error, so
that you can still pipe the image results..  </P>

For example lets '<CODE>Dilate</CODE>' the single pixel image using the larger
'<CODE>Octagon</CODE>' kernel until the whole image has been filled with white
and no more changes can be made to the image.  Remember an iteration limit of
'<CODE>-1</CODE>' means iterate forever, or until no more changes are seen.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=top><TD WIDTH=10% ALIGN=justify ROWSPAN=2></TD>
               <TD WIDTH=80% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE SCRIPT
     IMAGE=iterate_infinite.gif ERR=verbose_iterate.txt>
  MAGICK_THREAD_LIMIT=1 \
    convert pixel.gif -define debug=true -morphology Dilate:-1 Octagon \
            -scale 800% iterate_infinite.gif
</CODE></PRE></TD></TR></TABLE></TD><TD ROWSPAN=2>
  <A HREF="iterate_infinite.gif"
     ><IMG SRC="iterate_infinite.gif"  WIDTH=88 HEIGHT=88
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR><TR><TD>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD>
  <A HREF="verbose_iterate.txt"
     ><IMG SRC="verbose_iterate.txt.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE>
</TD></TR></TABLE></P>

Note the number of changes made in each iteration. Initially there were 20
pixels converted from black to white.  Then 48 more on the next iteration, and
so on.  This number generally grows as the edge of the resulting shape gets
larger, but then started to shrink again as shape hits the image boundary. On
the fourth dialation the last 4 pixels (in the corners of the image) were
filled in.  On the last dilation (iteration 5) the image was already
completely filled, as such no more changes to any pixel was performed.  As no
changes were made the morphology automatically aborts, giving a final number
of changes for this stage of the operation. </P>

Using an infinite iteration of '<CODE>-1</CODE>' does have an internal limit.
This is currently set to the maximum width or height of the image.  This is
done to prevent ImageMagick from going into a never ending loop. Typically
however operations will finish long before that internal limit is reached.
</P>

Some morphology methods are actually defined in terms of simpler more
primitive methods.  For example a '<CODE><A HREF="index.html#smooth" >Smooth</A></CODE>'
method for example is one such compound method.  The "<CODE><A
HREF="../../../html/www/command-line-options.html#define" >-define</A></CODE>" output that is
generated when using this method, shows the multiple internal steps that
goes to make up its processing. </P>


<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE SCRIPT ERR=verbose_compound.txt>
  MAGICK_THREAD_LIMIT=1 \
    convert man.gif -define debug=true -morphology Smooth:2 Diamond null:
</CODE></PRE></TD></TR></TABLE>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD>
  <A HREF="verbose_compound.txt"
     ><IMG SRC="verbose_compound.txt.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE>
</DIV></P>

If you look you can see that the '<CODE><A HREF="index.html#smooth" >Smooth</A></CODE>'
actually iterates, 4 more primitive methods, and thus internally processes the
image 8 times to perform the requested operation.  </P>

Each line consists of..

<BLOCKQUOTE><DL>
<DT><CODE>Smooth:<I>i</I>.<I>s</I></CODE>
<DD>this shows the high level morphology method being applied to the image,
    and the iteration count '<I>i</I>' and primitive 'stage' '<I>s</I>',
    that IM is processing. </P>

    For the '<CODE>Smooth</CODE>' method that first number is always '1', as
    the user-given 'iteration count' is applied in the lower level primitive
    method. In other methods, the user-given iteration may be applied at this
    higher level rather than at the lower level. </P>

    The second 'stage' number is the primitive 'stage' count that is being
    applied. '<CODE>Smooth</CODE>' itself is composed of four such stages, as
    it implements the '<CODE><A HREF="index.html#open" >Open</A></CODE>' and '<CODE><A
    HREF="index.html#close" >Close</A></CODE>' compound methods. </P>

<DT><CODE>Dilate*:<I>i</I>.<I>k</I></CODE>
<DD>This is the primitive method being applied.  The first number <I>i</I> is
    again the user-given iteration count (if it is being applied here).

    The second number '<I>k</I>' is the kernel being applied by the primitive
    morphology method.  As there is only one kernel so it is always zero in
    this case.  (See <A HREF="index.html#multi-kernel" >Multi-Kernel Handling</A> below)
    </P>

    The '<CODE>*</CODE>' indicates that the kernel was reflected (or rotated
    180 degrees around origin) before being applied by the morphological
    primitive.  This is required for some compound morphological methods, in
    this case the '<CODE><A HREF="index.html#close" >Close</A></CODE>' method always
    uses a reflected kernel in its use of the '<CODE><A HREF="index.html#dilate"
    >Dilate</A></CODE>' and '<CODE><A HREF="index.html#erode" >Erode</A></CODE>'
    primitive methods. </P>

<DT><CODE>#6 =&gt; Changed 311  Total 637</CODE>
<DD>This is a report of the results of applying the morphology primitive to
    the image. </P>

    The 'hash' number is an incremental count of the number of primitive passes
    though the image. This gives you a good idea of how computationally
    intensive a compound morphology operator is. </P>

    You then get a the actual number of pixels that were changed in some way
    during that pass. </P>

    If this is the last of a number of iterations for this specific primitive
    and kernel, a total count of pixel modifications is also output. This does
    not however reflect the total number of pixels changed in total from start
    to finish, just the changes caused by the low-level iteration of the
    specific primitive, kernel operation. Some pixels may change multiple
    times by some morphological primitives. </P>

</DL></BLOCKQUOTE></P>


From the above you may see that internally IM may have four loops of
processing being applied to fully process an given morphology method.  However
typically most of these loops are only applied once only. </P>


<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/warning.gif"  WIDTH=28 HEIGHT=28
    ><IMG SRC="../img_www/space.gif"   WIDTH=12 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  Warning the number of pixels that change, may not be correct on machines
  running a multi-threaded environment on modern multi-core machines! It is
  only guaranteed to be accurate when executed in a single threaded
  environment.  I class this as a bug, but not a vital one. </P>

  If this is a problem then ensure you set the environment variable
  "<CODE>MAGICK_THREAD_LIMIT</CODE>" to a value of '<CODE>1</CODE>' for that
  specific run of ImageMagick, as I did in the last two examples above. </P>

  As of IM v6.8.4 you no longer need the "<CODE>MAGICK_THREAD_LIMIT</CODE>"
  environment setting, as the counts are correctly handled in a multi-threding
  environment. </P>

</I></FONT></TD></TR></TABLE></P>


<A NAME="showkernel"></A>
<H3>Displaying the Kernel Generated
<FONT SIZE=-1>(for debugging purposes)</FONT></H3>

If you like to actually see the values that was used to define a particular
kernel that was generated, you can define a special setting...

<BLOCKQUOTE>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE NOT_AN_EXECUTABLE>
    -define morphology:showkernel=1   &nbsp;
    -define convolve:showkernel=1   &nbsp;
</CODE></PRE></TD></TR></TABLE>
</BLOCKQUOTE></P>

Any of the above defines causes IM to output (to 'standard error') all the
information about a generated kernel, after the kernel has been completely
processed in preparation for its use. (See <A
HREF="../convolve/index.html#kernel_scaling" >Convolve Kernel Scaling</A>). </P>

For example, here is the actual values of the built-in '<CODE><A HREF="index.html#disk"
>Disk</A></CODE>' kernel...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE ERR=k_disk.txt>
  convert xc: -define morphology:showkernel=1 -morphology Dilate:0 Disk null:
</CODE></PRE></TD></TR></TABLE>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD>
  <A HREF="k_disk.txt"
     ><IMG SRC="k_disk.txt.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE>
</DIV></P>

Note that as I only wanted to show the kernel, I really don't care about the
image processing at all.  As such I set the morphology '<I>iteration</I>' to
'<CODE>0</CODE>' (do nothing), and also discard any image result using a <A
HREF="../files/index.html#null" >null:</A> output file format. </P>

The special floating point value of 'nan' in the above has the same meaning as
when inputting a <A HREF="index.html#user" >User Defined Kernel</A>.  It means 'Not
A Number' and marks the parts of a kernel that is not part of the
neighbourhood. These values are ignored by all morphological operations. </P>

Here is another example. This time of a '<CODE><A HREF="../convolve/index.html#comet"
>Comet</A></CODE>' convolution kernel.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE ERR=k_comet.txt>
  convert xc:  -define morphology:showkernel=1 -morphology Dilate:0 Comet:0x2  null:
</CODE></PRE></TD></TR></TABLE>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD>
  <A HREF="k_comet.txt"
     ><IMG SRC="k_comet.txt.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE>
</DIV></P>

This is actually half a 1 Dimensional Gaussian Curve (sigma of 1.0), and can
provide a nice way of extracting such a curve from ImageMagick. </P>

Also notice that this specific kernel's 'origin' (the pixel that it effects),
is off-center (located at <CODE>+0+0</CODE>), which is not very common. </P>

The size and spacing of the values in the output can be controlled by the
special <A HREF="../basics/index.html#precision" >Precision Operational Control</A>.
That was added to IM at about the same time as the morphology operator.  </P>

For example here is a repeat of the previous example but using "<CODE><A
HREF="../../../html/www/command-line-options.html#precision" >-precision</A></CODE>" to limit the
number of significant digits from the default of 6 to 3.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE ERR=k_precision.txt>
  convert xc:  -define morphology:showkernel=1 -precision 3 \
          -morphology Dilate:0 Comet:0x2  null:
</CODE></PRE></TD></TR></TABLE>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD>
  <A HREF="k_precision.txt"
     ><IMG SRC="k_precision.txt.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE>
</DIV></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/warning.gif"  WIDTH=28 HEIGHT=28
    ><IMG SRC="../img_www/space.gif"   WIDTH=12 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  The "<CODE><A HREF="../../../html/www/command-line-options.html#precision" >-precision</A></CODE>"
  option was added to ImageMagick version 6.5.9-1 during the morphology
  development cycle. As such if morphology is available, precision can also be
  regarded as available.
</I></FONT></TD></TR></TABLE></P>


<A NAME="kernel2image"></A>
<H3>Generating an Image of the Kernel</H3>

To make it easier to see kernels, rather than using <A HREF="index.html#dilate"
>Dilating</A> or <A HREF="../convolve/index.html#convolve" >Convolution</A> on
an single pixel image to see what it produces, I created a special script
called "<CODE><A HREF="../scripts/kernel2image" >kernel2image</A></CODE>".
This script extracts the exact <A HREF="index.html#showkernel" >Show Kernel</A> output,
and converts it into an image of the kernel. </P>

The  "<CODE><A HREF="../scripts/kernel2image" >kernel2image</A></CODE>" script
has lots of options, from output the raw image of the kernel (the default) to
specifying the amount of scaling, inter-pixel gaps, montage, labeling, and even
coloring of the resultant 'kernel image'. </P>

The script makes it a lot easier to view and understand the various kernels,
and is used extensivally to generate the kernel images displayed in these
example pages.  </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>

For example here is how I generated the "<CODE><A HREF="index.html#octagon"
>Octagon</A></CODE>" kernel image.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE DO_NOT_EXECUTE>
  kernel2image -10.1  -m "Octagon"  kernel_octagon.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="kernel_octagon.gif"
     ><IMG SRC="kernel_octagon.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE>

The special option '<CODE>-10.1</CODE>' means scale all pixels to 10 pixels in
size, but also include a 1 pixel gap between those pixels.  If the kernel is
scaled enough the 'origin' of the kernel will be marked with some drawn
circles.  The '<CODE>-m</CODE>' then specifies that I it to create a <A
HREF="../montage/index.html" >Montage</A> of the image with an identification label of
the extracted "<CODE><A HREF="index.html#octagon" >Octagon</A></CODE>" kernel, and
shadow effects. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>

And here I generate a 'kernel image' of the 'L' shaped user defined kernel,
I used above.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  kernel2image -20.2 -ml 'L-Shape'  "3: 1,-,-  1,-,-  1,1,- " kernel_lman.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="kernel_lman.gif"
     ><IMG SRC="kernel_lman.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

If you want to create a kernel from an existing image, a script "<CODE><A
HREF="../scripts/image2kernel" >image2kernel</A></CODE>" can be used to create
a kernel data file from an image.  This script normally takes a gray-scale
image, but if a multi-colored image is given each channel of the image is
converted as a separate kernel data file. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>

Here I create the <A HREF="index.html#user" >User kernal data</A> from a small flag
image <NOBR>(&nbsp;<IMG SRC="../images/flag.gif" ALIGN=bottom>&nbsp;)</NOBR>, then use
"<CODE><A HREF="../scripts/kernel2image" >kernel2image</A></CODE>" to convert
that data back into an enlarged 'kernel image' for display.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE DO_NOT_EXECUTE>
   image2kernel -qgm flag.gif  flag_kernel.dat
   kernel2image -6.1 -m  -ml "Flag"  @flag_kernel.dat  kernel_flag.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="kernel_flag.gif"
     ><IMG SRC="kernel_flag.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

ASIDE: I could have generated the 'enlarged' version of the small image more
directly with a similar script "<CODE><A HREF="../scripts/enlarge_image"
>enlarge_image</A></CODE>, but that would have been displaying the image, and
not the Kernel Data, "<CODE><A HREF="flag_kernel.dat.html"
>flag_kernel.dat</A></CODE>". </P>


<A NAME="multi-kernel"></A>
<H3>Multiple Kernel List Handling</H3>

<H4>Generating Multiple Kernels </H4>

As of IM v6.6.2-0 you can specify multiple kernels which will be applied to
the image one at a time.  To specify multiple kernels you would just append
each kernel definition together, separated by a semicolon '<CODE>;</CODE>'.
A final semicolon at the end is optional. </P>

For example here I define a special kernel list containing a list that
can be used for 'pattern matching' corner pixels.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE NOT_AN_EXECUTABLE>
     3: 0,0,- 0,1,1 -,1,-  ;     &nbsp;
     3: -,0,0 1,1,1 -,1,-  ;
     3: -,1,- 1,1,0 -,0,0  ;
     3: -,1,- 0,1,1 0,0,-  ;
</CODE></PRE></TD></TR></TABLE>
</DIV></P>

Extra semicolons ('<CODE>;</CODE>') do not matter, as long as at least one is
provided between kernel specifications.  Nor does extra white space (including
newlines), in any kernel specification. </P>

Here is a <A HREF="index.html#showkernel" >Show Kernel Output</A> of this definition.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE SCRIPT ERR=k_multi.txt>
  convert xc: -define morphology:showkernel=1 -morphology Dilate:0 \
             " 3: 0,0,- 0,1,1 -,1,-  ;
               3: -,1,- 1,1,0 -,0,0  ;
               3: -,0,0 1,1,1 -,1,-  ;
               3: -,1,- 0,1,1 0,0,-  ; "   null:
</CODE></PRE></TD></TR></TABLE>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD>
  <A HREF="k_multi.txt"
     ><IMG SRC="k_multi.txt.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE>
</DIV></P>

And here is a <A HREF="index.html#kernel2image" >Kernel Image</A> of these four kernel
using the special "<CODE><A HREF="../scripts/kernel2image"
>kernel2image</A></CODE>" script.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE SCRIPT IMAGE=kernel_multi.gif>
   kernel2image -20.2 -ml '' -mt x1 \
             " 3: 0,0,- 0,1,1 -,1,-  ;
               3: -,1,- 1,1,0 -,0,0  ;
               3: -,0,0 1,1,0 -,1,-  ;
               3: -,1,- 0,1,1 0,0,-  ; "  kernel_multi.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="kernel_multi.gif"
     ><IMG SRC="kernel_multi.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</DIV></P>

Now this definition actually consists of just the one kernel which has been
expanded to form a set of 4 kernels each rotated by 90 degrees. </P>

ASIDE: This definition is almost equivalent to the the special '<CODE><A
HREF="index.html#corners" >Corners</A></CODE>' pattern matching kernel (see below).
except that it limits itself to corners of the actual shape, and not just any
corner, background or foreground. </P>


<A NAME="rotated_kernels"></A>
<H4>Expanding to a Rotated Kernel List</H4>

As of IM v6.2.2-0 you can ask IM to expand a single kernel into a list of
rotated kernels by using one of three special flags, in either named or
user-defined kernels.  The three special flags are...

<BLOCKQUOTE><TABLE>
<TR VALIGN=top><TD>'<B><CODE>@</CODE></B>'&nbsp;&nbsp;&nbsp;
<TD>Cyclically rotate 3x3 kernels in 45-degree increments, producing a list
    of up to 8 rotated kernels.  (mnemonic: '<CODE>@</CODE>' is circular)
<TR VALIGN=top><TD>'<B><CODE>&gt;</CODE></B>'
<TD>Rotate (square or linear kernels only) in 90-degree increments.
    (mnemonic: the '<CODE>&gt;</CODE>' is right angled).
<TR VALIGN=top><TD>'<B><CODE>&lt;</CODE></B>'
<TD>Also produce 90-degree rotations but in a 'mirror' sequence (rotation
    angles of  0, 180, -90, +90 ).  This special form of rotation expansion
    works better for morphology methods such as '<CODE><A HREF="index.html#thinning"
    >Thinning</A></CODE>'.  (mnemonic: '<CODE>&lt;</CODE>' is a mirror of
    a right angle).
</TABLE></BLOCKQUOTE></P>

For example that same kernel above be specified more simply as...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE NOT_AN_EXECUTABLE>
    ' 3&gt;:  0,0,-  0,1,1  -,1,- '
</CODE></PRE></TD></TR></TABLE>
</DIV></P>

This defines one kernel, which the '<CODE>&gt;</CODE>' flag then tells IM to
expand into a 90 degree rotated list. </P>

And here is an image of the resulting multi-kernel list

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
   kernel2image -20.2 -ml '' -mt x1 \
                '3&gt;: 0,0,- 0,1,1 -,1,- '  kernel_rotated_list.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="kernel_rotated_list.gif"
     ><IMG SRC="kernel_rotated_list.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</DIV></P>

And here I rotate a 3x3 kernel in a 'cyclic' 45 degree rotation, expanding it
to a list of 8 kernels.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
   kernel2image -20.2 -ml '' -mt x1 \
                '3@: -,1,- -,0,- 1,1,1 '  kernel_rotated_list2.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="kernel_rotated_list2.gif"
     ><IMG SRC="kernel_rotated_list2.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</DIV></P>

You can also do the same for any 'single' built-in named kernel IM, using the
same flags in the argument section of those kernels.  For example here I take
a symmetrical '<CODE><A HREF="../convolve/index.html#blur" >Blur</A></CODE>' kernel and
expand it into a 90 degree rotated list using a '<CODE>&gt;</CODE>' flag.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
   kernel2image -12.1 -n -ml ''   "Blur:0x1&gt;"  blur_kernels.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="blur_kernels.gif"
     ><IMG SRC="blur_kernels.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</DIV></P>

Note that only 2 kernels were generated as a third kernel, would just
reproduce the first kernel exactly. This is discovered and the generation of
rotated kernels stops. </P>

However if the 'origin' is off centered, then the full sequence of 4 rotated
kernels would have been generated as while the kernel 'shape' matches, the
origin location would not be the same. </P>

Many built-in kernel definitions automatically generate a multi-kernel list,
so you do not need to specify any flags for that purpose.  That is, the
rotation expansion is also 'built-in' to the specific kernel definition.  Such
kernels typically also provide 'sub-types' of the original single kernel
definition, so that you can pick and choose specific kernels for specific
purposes. </P>


<A NAME="kernel_compose"></A>
<H3>Multiple Kernel Result Merging: Re-iterate or Compose</H3>

When you have defined multiple kernels, the morphology method also needs to
know how it should merge the results generated by multiple kernels.  This can
be controlled by the use of a global <A HREF="../basics/index.html#define" >Define</A>...

<BLOCKQUOTE>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE NOT_AN_EXECUTABLE>
    -define morphology:compose={<I>compose_method</I>}   &nbsp;
</CODE></PRE></TD></TR></TABLE>
</BLOCKQUOTE></P>

The default for most morphology methods is a setting of '<CODE>None</CODE>'.
This means that after each kernel has been applied using the morphology method
given, the resulting image should be used as the source for next kernel.  That
is simply '<I>re-iterate</I>' or reuse the resulting image from applying one
kernel, for the next kernel. </P>

For example, if I <A HREF="../convolve/index.html#convolve" >Convolve</A> using 2, 90
degree rotated '<CODE><A HREF="../convolve/index.html#blur" >Blur</A></CODE>' kernels we
get the following.

<!--<CODE EXECUTE>
   kernel2image -12.1 -n -ml '' "Blur:0x1"    blur_kernel.gif
   kernel2image -12.1 -n -ml '' "Blur:0x1+90" blur_kernel2.gif
</CODE>-->
<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert pixel.gif  -morphology Convolve "Blur:0x1&gt;" \
          -auto-level  blur_re-iterate.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="pixel.gif"
     ><IMG SRC="pixel_mag.gif"               WIDTH=88 HEIGHT=88
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/mph_convolve.gif" ALIGN=middle ALT="*">
  <A HREF="blur_kernel.gif"
     ><IMG SRC="blur_kernel.gif"
           ALIGN=middle VSPACE= HSPACE=0 BORDER=0 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/comma.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT=",">
  <A HREF="blur_kernel2.gif"
     ><IMG SRC="blur_kernel2.gif"
           ALIGN=middle VSPACE= HSPACE=0 BORDER=0 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="blur_re-iterate.gif"
     ><IMG SRC="blur_re-iterate.gif"     WIDTH=88 HEIGHT=88
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

As you can see both kernels were applied to the image one after the other, so
that each kernel works with the result of the previous kernel.  That is it
'<I>re-iterates</I>' the result of one kernel with the next kernel, in
sequence. </P>

This is equivalent to doing the two steps like this.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE DO_NOT_EXECUTE>
  convert pixel.gif -morphology Convolve "Blur:0x1" -auto-level blur_1.gif
  convert blur_1.gif -morphology Convolve "Blur:0x1+90" \
          -auto-level blur_re-iterate.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="pixel.gif"
     ><IMG SRC="pixel_mag.gif"               WIDTH=88 HEIGHT=88
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/mph_convolve.gif" ALIGN=middle ALT="*">
  <A HREF="blur_kernel.gif"
     ><IMG SRC="blur_kernel.gif"
           ALIGN=middle VSPACE= HSPACE=0 BORDER=0 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="blur_1.gif"
     ><IMG SRC="blur_1_mag.gif"     WIDTH=88 HEIGHT=88
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/mph_convolve.gif" ALIGN=middle ALT="*">
  <A HREF="blur_kernel2.gif"
     ><IMG SRC="blur_kernel2.gif"
           ALIGN=middle VSPACE= HSPACE=0 BORDER=0 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="blur_re-iterate.gif"
     ><IMG SRC="blur_re-iterate.gif"     WIDTH=88 HEIGHT=88
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

Actually this is how the <A HREF="../blur/index.html#blur" >Blur Operator</A> really
works, to generate image blurs more quickly. See <A
HREF="../convolve/index.html#gaussian_vs_blur" >Gaussian vs Blur Kernels</A> which
demonstrates this use more throughly. </P>

<BR>

By setting the '<CODE>{<I>compose_method</I>}</CODE>' to any method other than
'<CODE>None</CODE>', the operation will NOT be <I>re-iterated</I>.  Instead
each kernel will be applied <I>to the original image</I>, and the resulting
images will be then be <A HREF="../compose/index.html" >Composited</A> together using
the '<CODE>{<I>compose_method</I>}</CODE>' method specified. </P>

For example if I use a '<CODE><A HREF="../compose/index.html#lighten"
>Lighten</A></CODE>' morphology method to generate a <A
HREF="../compose/index.html#set_theory" >Union</A> of the separate results, we would
get..

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE NO_EXECUTE>
  convert pixel.gif  -define morphology:compose=Lighten \
                     -morphology Convolve "Blur:0x1&gt;" \
          -auto-level blur_union.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="pixel.gif"
     ><IMG SRC="pixel_mag.gif"               WIDTH=88 HEIGHT=88
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/mph_convolve.gif" ALIGN=middle ALT="*">
  <A HREF="blur_kernel.gif"
     ><IMG SRC="blur_kernel.gif"
           ALIGN=middle VSPACE= HSPACE=0 BORDER=0 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/comma.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT=",">
  <A HREF="blur_kernel2.gif"
     ><IMG SRC="blur_kernel2.gif"
           ALIGN=middle VSPACE= HSPACE=0 BORDER=0 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="blur_union.gif"
     ><IMG SRC="blur_union_mag.gif"     WIDTH=88 HEIGHT=88
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

That was equivalent to doing...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert pixel.gif -morphology Convolve "Blur:0x1"  -auto-level blur_1.gif
  convert pixel.gif -morphology Convolve "Blur:0x1+90" -auto-level blur_2.gif
  convert blur_1.gif blur_2.gif -compose Lighten -composite \
          -auto-level blur_union.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="pixel.gif"
     ><IMG SRC="pixel_mag.gif"               WIDTH=88 HEIGHT=88
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/mph_convolve.gif" ALIGN=middle ALT="*">
  <A HREF="blur_kernel.gif"
     ><IMG SRC="blur_kernel.gif"
           ALIGN=middle VSPACE= HSPACE=0 BORDER=0 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="blur_1.gif"
     ><IMG SRC="blur_1_mag.gif"     WIDTH=88 HEIGHT=88
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
<BR>
  <A HREF="pixel.gif"
     ><IMG SRC="pixel_mag.gif"               WIDTH=88 HEIGHT=88
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/mph_convolve.gif" ALIGN=middle ALT="*">
  <A HREF="blur_kernel2.gif"
     ><IMG SRC="blur_kernel2.gif"
           ALIGN=middle VSPACE= HSPACE=0 BORDER=0 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="blur_2.gif"
     ><IMG SRC="blur_2_mag.gif"     WIDTH=88 HEIGHT=88
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
<BR>
  <A HREF="blur_1.gif"
     ><IMG SRC="blur_1_mag.gif"     WIDTH=88 HEIGHT=88
           ALIGN=middle VSPACE= HSPACE=0 BORDER=0 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/union.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="U">
  <A HREF="blur_2.gif"
     ><IMG SRC="blur_2_mag.gif"     WIDTH=88 HEIGHT=88
           ALIGN=middle VSPACE= HSPACE=0 BORDER=0 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="blur_union.gif"
     ><IMG SRC="blur_union_mag.gif"     WIDTH=88 HEIGHT=88
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>
<!--
  convert blur_1.gif -scale 800% blur_1_mag.gif
  convert blur_2.gif -scale 800% blur_2_mag.gif
  convert blur_union.gif -scale 800% blur_union_mag.gif
-->

If you are not sure what IM is actually doing during a morphology, turn on
the <A HREF="index.html#verbose" >Verbose Output of Changes</A>.

For example here the verbose output of re-iterating with each kernel...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE  ERR=blur_re-iterate.txt>
  convert pixel.gif  -define morphology:compose=None \
          -define debug=true -morphology Convolve "Blur:0x1&gt;" null:
</CODE></PRE></TD></TR></TABLE>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD>
  <A HREF="blur_re-iterate.txt"
     ><IMG SRC="blur_re-iterate.txt.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE>
</DIV></P>

And here is the verbose output of a <A HREf="../compose/index.html#set_theory"
>Union</A> (<A HREF="../compose/index.html#lighten" >Lighten Composition</A>) of each
kernel result....

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE  ERR=blur_union.txt>
  convert pixel.gif  -define morphology:compose=Lighten \
          -define debug=true -morphology Convolve "Blur:0x1&gt;" null:
</CODE></PRE></TD></TR></TABLE>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD>
  <A HREF="blur_union.txt"
     ><IMG SRC="blur_union.txt.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE>
</DIV></P>

Both of which clearly shows what ImageMagick is doing to generate the final
image.  The number after the decimal point represents the kernel number that
is being applied, at each step. Followed at the end by how it composes the
images together according to the '<CODE>morphology:compose</CODE>'
setting. </P>

Many of the <A HREF="../compose/index.html#math" >Mathematical Composition Methods</A>
and their equivelent <A HREF="../compose/index.html#set_theory" >Set Theory</A> type
operations, can also be used to merge the results of applying each kernel to
the original image. </P>

In summery this setting defines how the individual kernels of a multi-kernel
list will be applied to the given image.  The default is the compose value of
'<CODE>None</CODE>' meaning to simply 're-iterate' results, otherwise it will
merge all the results based on the compose method given. </P>


<HR><!-- ---------------------------------------------------------------- -->

<A NAME="basic"></A>
<H2>Basic Morphology Methods</H2>

Morphological Methods is an image processing technique for the finding, and
analysis of shapes of objects withing an image.  Expanding, shrinking,
locating specific shapes, and so on. </P>

It was original developed with binary (pure black and white) images in mind,
and because of this it most commonly applied to <A
HREF="../quantize/index.html#threshold" >Thresholded</A> images containing simple black
and white shapes.  By convention white in a binary image represents
foreground, while black represents background.  The method names are thus
described according to this convention. </P>

That is not to say the operators will not work with gray-scale image, or in
some cases color images, but their original purpose was to handle binary
shapes. </P>

The basic <A HREF="index.html#man_kernels" >Shape Kernels</A> already looked at above,
are the most commonly used neighbourhood defining 'shapes', for morphological
methods.  Such kernels are often called 'Structure Elements' as they are
typically used to determine the structure of the shapes within the image.
</P>

<A NAME="erode"></A>
<H3>Erode
&nbsp; <FONT SIZE=5>(
<IMG SRC="../img_www/mph_erode.gif" ALIGN=absmiddle>
)</FONT></H3>

As the name implies the '<CODE><B>Erode</B></CODE>' method 'eats away' the
white shape, from any background pixel making it smaller. You can also think
of it as expanding the black areas of the image. </P>

For example here is a simple binary 'man-like' shape that has been eroded
using a '<CODE><A HREF="index.html#octagon" >Octagon</A></CODE>' kernel.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert man.gif   -morphology Erode Octagon  erode_man.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="man.gif"
     ><IMG SRC="man.gif"               WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/mph_erode.gif" ALIGN=middle WIDTH=20 HEIGHT=30 ALT="-">
  <A HREF="kernel_octagon.gif"
     ><IMG SRC="kernel_octagon.gif"
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="erode_man.gif"
     ><IMG SRC="erode_man.gif"      WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

Its basic effects is to make any protuberances or points the image may have
thinner, or remove them completely, but it also makes any holes that is
present (such as caused by this images 'arm') in an image larger.  In general
the size of kernel, determines how many pixels are removed. </P>

<A NAME="dilate"></A>
<H3>Dilate
&nbsp; <FONT SIZE=5>(
<IMG SRC="../img_www/mph_dilate.gif" ALIGN=absmiddle>
)</FONT></H3>

The '<CODE><B>Dilate</B></CODE>' method is the dual of '<CODE>Erode</CODE>'.
It expands the white shapes, making a shape bigger according to the kernel
(and the number of iterations) specified.  Of course that also means it will
'erode' the black areas of the image. </P>

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert man.gif   -morphology Dilate Octagon  dilate_man.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="man.gif"
     ><IMG SRC="man.gif"               WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/mph_dilate.gif" ALIGN=middle WIDTH=20 HEIGHT=30 ALT="+">
  <A HREF="kernel_octagon.gif"
     ><IMG SRC="kernel_octagon.gif"
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="dilate_man.gif"
     ><IMG SRC="dilate_man.gif"      WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

Notice how the shape not only becomes larger, but its outlined becomes
smoother.  The large indent between the 'legs' has been filled in, as was the
small single pixel 'hole' the image contained.  The size and shape of the
kernel determines how many pixels were are added around the edges of the
image. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

The '<CODE>Dilate</CODE>' and '<CODE>Erode</CODE>' are dual. That is (at least
with a symmetrical kernel) by negating the image before and after the applying
the morphological method, you will actually perform the other form of the
operator.   For example here I perform an erosion by using '<CODE>Dilate</CODE>'
on the <A HREF="../color_mods/index.html#negate" >Negated Images</A>.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert man.gif -negate \
             -morphology Dilate Octagon   -negate dilate_man_neg.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="dilate_man_neg.gif"
     ><IMG SRC="dilate_man_neg.gif"      WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>


<A NAME="open"></A>
<H3>Open
&nbsp; <FONT SIZE=5>(
<IMG SRC="../img_www/mph_open.gif" ALIGN=absmiddle>
)</FONT></H3>

Here is the effect of the '<CODE><B>Open</B></CODE>' method, but this time
using much larger '<CODE><A HREF="index.html#disk" >Disk</A></CODE>'
kernel.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert man.gif   -morphology Open Disk  open_man.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="man.gif"
     ><IMG SRC="man.gif"               WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/mph_open.gif" ALIGN=middle WIDTH=20 HEIGHT=30 ALT="o">
  <A HREF="kernel_disk.gif"
     ><IMG SRC="kernel_disk.gif"
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="open_man.gif"
     ><IMG SRC="open_man.gif"      WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

As a result you will see that '<CODE>Open</CODE>' smoothed the outline, by
rounding off any sharp points, and remove any parts that is smaller than the
shape used.  It will also disconnect or 'open' any thin bridges. </P>

However it does not remove any 'holes', or gaps that may be present in the
image.  such as between the shapes 'legs'.  Also it does not make the basic
'core' size of the shape larger or smaller. </P>

In actual real terms, what it does is to '<CODE><A HREF="index.html#erode"
>Erode</A></CODE>' an image then '<CODE><A HREF="index.html#dilate" >Dilate</A></CODE>'
it again using the same kernel that was provided

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert man.gif         -morphology Erode  Disk  open_erode.gif
  convert open_erode.gif  -morphology Dilate Disk  open_man_2.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="man.gif"
     ><IMG SRC="man.gif"               WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=2 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="open_erode.gif"
     ><IMG SRC="open_erode.gif"
           ALIGN=middle VSPACE=2 HSPACE=10 BORDER=0 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="open_man_2.gif"
     ><IMG SRC="open_man_2.gif"      WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=2 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

Note that performing a '<CODE>Open</CODE>' on a shape that has already been
opened, with the same kernel will result in no further change to the shape.
For example...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert open_man.gif  -morphology Open Disk  open_man_twice.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="man.gif"
     ><IMG SRC="man.gif"               WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="open_man.gif"
     ><IMG SRC="open_man.gif"      WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="open_man_twice.gif"
     ><IMG SRC="open_man_twice.gif"      WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

That is repeating a '<CODE>Open</CODE>' operation, with the same kernel, has
no effect on the result. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

Because of this, any <I>iteration</I> count provided will be applied to the
individual dilate and erode sub-methods, and not to the method as a whole,
so that the iteration can be used to 'expand' the effective kernel, rather
than uselessly repeating the compound operation.  </P>

That is a '<I>Open:2</I>' iteration will actually be applied as
a '<CODE>Erode:2</CODE>, followed by an '<CODE>Dilate:2</CODE>' to the image.
This has the general effect of making the effective 'neighbourhood' defined by
the kernel larger.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert man.gif   -morphology Open:2  Disk  open_man_x2.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="open_man_x2.gif"
     ><IMG SRC="open_man_x2.gif"      WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Here you can see that the resulting larger neighbourhood resulted in both the
man's 'head' and 'feet' extremities being removed.  The main body of the shape
basically intact, though also smoother in appearance, while the leg gap
remains untouched. </P>

This is the same effect as doubling the size of the kernel, though its exact
shape may not be exactly the same as a kernel of double the radius.  </P>


<A NAME="close"></A>
<H3>Close
&nbsp; <FONT SIZE=5>(
<IMG SRC="../img_www/mph_close.gif" ALIGN=absmiddle>
)</FONT></H3>

The basic use of the '<CODE><B>Close</B></CODE>' method is to reduce or remove
any 'holes' or 'gaps' about the size of the kernel 'Structure Element'. That
is 'close' parts of the background that are about that size. </P>

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert man.gif    -morphology Close Disk   close_man.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="man.gif"
     ><IMG SRC="man.gif"               WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/mph_close.gif" ALIGN=middle WIDTH=20 HEIGHT=30 ALT=".">
  <A HREF="kernel_disk.gif"
     ><IMG SRC="kernel_disk.gif"
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="close_man.gif"
     ><IMG SRC="close_man.gif"      WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

The basic effect of this operator is to smooth the outline of the shape, by
filling in (closing) any holes, and indentations.  It also will form
connecting 'bridges' to other shapes that are close enough for the kernel to
touch both simultaneously.  But it does not make the basic 'core' size of the
shape larger or smaller. </P>

In actual real terms, what it does is to '<CODE><A HREF="index.html#dilate"
>Dilate</A></CODE>' the image then '<CODE><A HREF="index.html#erode" >Erode</A></CODE>'
it again using the same kernel that was provided, causing the image to become
first larger, then smaller.  This is the opposite order of what '<CODE><A
HREF="index.html#open" >Open</A></CODE>' does.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert man.gif           -morphology Dilate Disk  close_dilate.gif
  convert close_dilate.gif  -morphology Erode  Disk  close_man_2.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="man.gif"
     ><IMG SRC="man.gif"               WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=2 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="close_dilate.gif"
     ><IMG SRC="close_dilate.gif"
           ALIGN=middle VSPACE=2 HSPACE=10 BORDER=0 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="close_man_2.gif"
     ><IMG SRC="close_man_2.gif"      WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=2 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

The results is that the external points of the image will be left as is, but
any 'bays' smoothed and thickened, and 'holes' and 'gaps' closed.
Disconnected objects that are very close together can be come linked together.
</P>

as with '<CODE><A HREF="index.html#open" >Open</A></CODE>', repeating the '<CODE><A
HREF="index.html#close" >Close</A></CODE>' method with the same kernel does not make any
further changes to the image.  Using an '<I>iteration</I>' with the operator
will however repeat the internal sub-methods, so as to produce a stronger
rounding effect, similar to using a larger kernel. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>

And just as with the '<CODE><A HREF="index.html#dilate" >Dilate</A></CODE>' and
'<CODE><A HREF="index.html#erode" >Erode</A></CODE>' methods,  the '<CODE><A
HREF="index.html#open" >Open</A></CODE>' and '<CODE><A HREF="index.html#close" >Close</A></CODE>'
methods are duals.  You can reproduce the effect of the other 'dual' by <A
HREF="../color_mods/index.html#negate" >Negating</A> the image before and after the
operation.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert man.gif   -negate -morphology Close Disk -negate   close_man_neg.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="close_man_neg.gif"
     ><IMG SRC="close_man_neg.gif"      WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>


<A NAME="smooth"></A>
<H3>Smooth</H3>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>

The '<CODE><B>Smooth</B></CODE>' method applies a '<CODE><A HREF="index.html#open"
>Open</A></CODE>' followed by a '<CODE><A HREF="index.html#close" >Close</A></CODE>' of
the shape, which first removes any 'small objects' then fills in and 'holes'
or 'gaps' about the size of the kernel 'Structure Element'. </P>

Here we smooth the image using a mid-range '<CODE><A HREF="index.html#octagon"
>Octagon:3</A></CODE>' kernel.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert man.gif  -morphology Smooth  Octagon:3  smooth_man.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="smooth_man.gif"
     ><IMG SRC="smooth_man.gif"      WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

As you can see all the 'indents', 'gaps', 'holes', and 'points' have been
smoothed and rounded off according to the size and shape of the kernel.  </P>

The '<CODE><A HREF="index.html#smooth" >Smooth</A></CODE>' operator is also often
repeated with slowly increasing sized Structure Elements, so as to slowly
remove noise from images. If the parts removed are preserved, you get
a morphological 'decomposition' of the image which can be used for further
study. See <A HREF="index.html#granularity" >Granularity</A> below.

The method is particularly good for cleaning up scanned documents. </P>

Note that this is actually applying 4 separate 'primitive' operations to the
original image.  It is thus 4 times slower than just a simple  '<CODE><A
HREF="index.html#erode" >Erode</A></CODE>' or  '<CODE><A HREF="index.html#dilate"
>Dilate</A></CODE>'. </P>


<A NAME="greyscale_flat"></A>
<H3>Flat Grey-scale Morphology</H3>

While essentially all four of the Basic Morphological Methods, and later ones
which are defined in terms of these four methods, are specifically designed to
work with binary images, they can be applied to both grey-scale and color
images (though color images may generate some odd color effects).  </P>

<I>Practical Example of Grey-scale Operation Wanted Here</I></P>

However the kernel itself will always be regarded as a simple 'on' or 'off'
neighbourhood.  Any kernel value that is either a 'nan' or less than
'<CODE>0.5</CODE>' will be regards as outside the 'neighbourhood' that it
defines. </P>

In summery, the above operators apply a 'flat' kernel without any 'height' or
'3-dimensional' features, but can still be applied to gray-scale images. </P>


<A NAME="greyscale"></A>
<H3>True Gray-scale or 3-dimensional Morphology</H3>

True gray-scale or 3-dimensional morphology (as one library put it) will
actually add or subtract the values found in the kernel from the neighbouring
pixels in the image, before looking for the maximum/minimum values as the
result.  What this means is that it treats a gray-scale image as a 'height
field' of a 3-dimensional morphology object and the gray-scale shape of the
kernel the smoothing shape to adjust that height field.  </P>

While the implementation details of true gray-scale morphology is well
documented, is usage in practical situations is not.  That is I have not found
any useful example of using true grey-scale morphology beyond 'flat shaped
kernels', other than a comment about its use in 'photometric' processing.
Because of this I have not implemented true 3-dimensional grey-scale
morphology.  However if people really do need such non-flat grey-scale
morphological operators, please let me know, and I will implement the
appropriate operators.  </P>

Note the special '<CODE><A HREF="index.html#distance" >Distance</A></CODE>' method (see
below) is actually similar to how true gray-scale morphology works, in that it
adds the kernel's value to each pixel value, before taking the smallest
'minimum' value. However this method does not match either 3D erode (subtract
and take minimum) or dilate (add and take maximum) morphology definitions.  It
is however very closely related, and probably could be implemented using those
methods. </P>


<A NAME="intensity"></A>
<H3>Intensity Variant for Color Images</H3>

As the above four methods, are grey-scale <A HREF="index.html#channel" >Channel</A>
methods, using them on color images can generate off color effects where one
channel is modified, but another isn't.  They are really not designed for use
with multi-channel color images, only with grey-scale and binary images. </P>

The result is that for color images, the colors become distorted, becoming
a brighter or darker shade depending on the operation. </P>

With this in mind I have created 'Intensity' versions of these methods.

'<CODE>ErodeIntensity</CODE>', '<CODE>DilateIntensity</CODE>',
'<CODE>OpenIntensity</CODE>', '<CODE>CloseIntensity</CODE>'. </P>

These compare the pixels within the defined 'neighbourhood', and replaces the
current pixel color according to the pixels intensity.  That is the whole
color pixel is copied, and not just the individual channel values. As
a result... </P>

<DIV ALIGN=center><B>
   Intensity Variants do not generate any 'new' colors in images.
</B></DIV></P>

Because of their nature the <A HREF="index.html#intensity" >Intensity Methods</A>
will ignore the current "<CODE><A HREF="../../../html/www/command-line-options.html#channel"
>-channel</A></CODE>" setting completely.  </P>

For example here I use the binary and intensity variants of '<CODE><A
HREF="index.html#dilate" >Dilate</A></CODE>' Morphology (expand bright areas), on the
built-in "<CODE>rose:</CODE>" image.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rose: -morphology Dilate          Octagon:3  rose_dilate.gif
  convert rose: -morphology DilateIntensity Octagon:3  rose_dilate_intensity.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="../images/rose.gif"
     ><IMG SRC="../images/rose.gif"    WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="rose_dilate.gif"
     ><IMG SRC="rose_dilate.gif"    WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=2 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="rose_dilate_intensity.gif"
     ><IMG SRC="rose_dilate_intensity.gif"      WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=2 HSPACE=10 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

As you can see the normal '<CODE><A HREF="index.html#dilate" >Dilate</A></CODE>' method
can generate different shades in each of the large dilated spots, as each
channel is separately handled. The second intensity dilation however
preserves the full color of the brightest spots, expanding them according to
the boolean kernel shape. </P>

The intensity methods also has a short hand naming scheme, by replacing the
word '<CODE>Intensity</CODE>' with just a '<CODE>I</CODE>'. As such here I use
a '<CODE>CloseIntensity</CODE>' method but use the short hand name of
'<CODE>CloseI</CODE>'. </P>

For example here are the results of using each of the four 'Intensity' variants
on the built-in rose image.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rose: -morphology ErodeI Octagon:3 rose_erode_intensity.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="rose_erode_intensity.gif"
     ><IMG SRC="rose_erode_intensity.gif"    WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
<c>  convert rose: -morphology DilateI Octagon:3 rose_dilate_intensity.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="rose_dilate_intensity.gif"
     ><IMG SRC="rose_dilate_intensity.gif"    WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rose: -morphology OpenI Octagon:3 rose_open_intensity.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="rose_open_intensity.gif"
     ><IMG SRC="rose_open_intensity.gif"    WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100% ALIGN=center>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rose: -morphology CloseI Octagon:3 rose_close_intensity.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="rose_close_intensity.gif"
     ><IMG SRC="rose_close_intensity.gif"    WIDTH=70 HEIGHT=46
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

The last two may be particularly suitable as a replacement operator for the <A
HREF="http://legacy.imagemagick.org/Usage/transform/#paint" >Paint Operator</A>. </P>

<I>These methods are classed as experimental</I>, and comments or problems
with its use is welcome.  If I do not hear comments, nothing more will be
added! </P>


<A NAME="alturnative"></A>
<H2>Alternative Basic Morphology Techniques</H2>
<PRE>

For people with versions of IM older than v6.5.9-0 you can still implement
some basic morphology methods.

You can generate a kernel that is all ones. For example a 7x7 array of 1's
(radius=3), by use an extremely large sigma and specify the appropriate radius,
using a Gaussian blur.

As such
    -convolve 1,1,1,1,1,.....
for a total of 49 ones is equivalent to
    -gaussian-blur 3x65535

This allows you to generate a simple square kernel for binary morphological
methods.

'Dilate'   for a 3x3 square kernel (radius=1) is thus
    -gaussian-blur 1x65535 -threshold 0
'Erode'  is thus
    -gaussian-blur 1x65535 -threshold 99.999%

As previously shown above
'Open' is a 'Dilate' followed by a 'Erode'
'Close' is a 'Erode' followed by a 'Dilate'
and Smooth is a 'Open' followed by a 'Close'

Larger square kernels can be specified using larger radii.

Unfortunately the other built-in kernel shapes are not available,
without using the convolve operator to manually define their shape.

This also only truly works for binary morphology. To implement a
flat-greyscale morphology, you will need to use a different technique of
generating a separate image for each pixel in the kernel, and rolling
it for the pixels position.

Both the thresholded-convolve and roll-shift composition methods have been
implemented in Fred Weinhaus's script "morphology", which was created long
before the "-morphology" operator was added to ImageMagick.

See and Download Fred's Weinhaus "Morphology" Script from
  http://www.fmwconcepts.com/imagemagick/morphology/index.php
</PRE>


<HR><!-- ---------------------------------------------------------------- -->

<A NAME="difference"></A>
<A NAME="subtractive"></A>
<H2>Difference Morphology Methods</H2>

The next level of morphological methods is something I term difference
morphology.  That is the results of these morphology methods is the difference
between one of the previous basic morphology methods, and the original image,
or some other morphological method. </P>

Essentially they return the changes that was made to the original image by one
of the simpler methods, giving you the outlines, the additions or subtractions
between the images.  They are essentially a '<CODE><A
HREF="../compose/index.html#difference" >Difference</A></CODE>' or '<CODE><A
HREF="../compose/index.html#minus" >Minus</A></CODE>' image compositions of the image
results. </P>


<A NAME="edgein"></A>
<H3>EdgeIn</H3>

The '<CODE><B>EdgeIn</B></CODE> method, also called a '<I>Internal
Gradient</I>', find the pixels that an the <A HREF="index.html#erode" >Erosion</A>
removes from the original.  As a result the pixels that are closest to the
edge, but which were part of the original shape is returned.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert man.gif   -morphology EdgeIn Octagon  edgein_man.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="man.gif"
     ><IMG SRC="man.gif"               WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="erode_man.gif"
     ><IMG SRC="erode_man.gif"      WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="edgein_man.gif"
     ><IMG SRC="edgein_man.gif"      WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

The resulting edge is about half the size of the kernel given, which for
a '<CODE><A HREF="index.html#octagon" >Octagon</A></CODE>' kernel is rather thick. More
typically the you would use a much smaller '<CODE><A HREF="index.html#diamond"
>Diamond</A></CODE>' or '<CODE><A HREF="index.html#square" >Square</A></CODE>' kernel,
to produce a single pixel pixel outline of the shape. </P>

An example of using '<CODE><A HREF="index.html#edgein" >EdgeIn</A></CODE>' with the
alpha channel, to extract edge pixels is shown in <A
HREF="../canvas/index.html#sparse_fill" >Sparse Color as a Fill Operator</A>. </P>


<A NAME="edgeout"></A>
<H3>EdgeOut</H3>

The '<CODE><B>EdgeOut</B></CODE>' method, also called '<I>External
Gradient</I>', finds the pixels that was added to the original image by a <A
HREF="index.html#dilate" >Dilation</A> of that image.  As a result the background pixels
immediately next to the shape is returned.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert man.gif   -morphology EdgeOut Octagon  edgeout_man.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="man.gif"
     ><IMG SRC="man.gif"               WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="dilate_man.gif"
     ><IMG SRC="dilate_man.gif"      WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="edgeout_man.gif"
     ><IMG SRC="edgeout_man.gif"      WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

An example of using '<CODE><A HREF="index.html#edgeout" >EdgeOut</A></CODE>' with the
alpha channel, is shown in <A HREF="../masking/index.html#outline" >Outline or Halo
Transparency</A>. </P>


<A NAME="edge"></A>
<H3>Edge or Morphological Gradient</H3>

The '<CODE><B>Edge</B></CODE>' method returns a '<I>Morphological
Gradient</I>', which can be described as either the addition of the last two
'edge' methods, or more specifically the difference between the <A
HREF="index.html#erode" >Eroded</A> shape from its <A HREF="index.html#dilate" >Dilated</A> shape.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert man.gif   -morphology Edge Octagon  edge_man.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="man.gif"
     ><IMG SRC="man.gif"               WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="dilate_man.gif"
     ><IMG SRC="dilate_man.gif"      WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/minus.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="erode_man.gif"
     ><IMG SRC="erode_man.gif"      WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="edge_man.gif"
     ><IMG SRC="edge_man.gif"      WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

As before the size and shape of the kernel defines the thickness of the eroded
image.  Its thickness is essentially equivalent to that kernel size, minus the
center pixel. As such a kernel of radius 3 will generally produce
a '<CODE>Edge</CODE>' which 6 pixels thick (kernel size is 7 pixels thick) </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>

Here for example is the '<CODE>Edge</CODE>' outline of the shape using the
minimal '<CODE><A HREF="index.html#diamond" >Diamond</A></CODE>' kernel.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE SCRIPT>
  convert man.gif  -morphology Edge Diamond  man_outline.gif
</CODE></PRE></TD></TR></TABLE></P>

The edge is two pixels thick as it contains the pixels that lie on either side
of the actual 'pixel edge' of the original shape.  The only way to make this
edge thinner is actually to offset the whole image diagonally by half-a-pixel.

</TD><TD>
  <A HREF="man_outline.gif"
     ><IMG SRC="man_outline.gif"      WIDTH=100  HEIGHT=125
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Text]"></A>
</TD></TR></TABLE></P>

For more details of getting outlines of shapes in various ways see the section
on <A HREF="http://legacy.imagemagick.org/Usage/transform/#edge" >Edge Detection</A>. </P>

<I>Future: generating the edge using a 'diagonal line'. </I> </P>


<A NAME="top-hat"></A>
<H3>Top-Hat</H3>

The '<CODE><B>TopHat</B></CODE>' method, or more specifically '<I>White Top
Hat</I>', returns the pixels that were removed by a <A HREF="index.html#open"
>Opening</A> of the shape, that is the pixels that were removed to round off
the points, and the connecting bridged between shapes.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert man.gif   -morphology TopHat Disk  tophat_man.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="man.gif"
     ><IMG SRC="man.gif"               WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="open_man.gif"
     ><IMG SRC="open_man.gif"      WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="tophat_man.gif"
     ><IMG SRC="tophat_man.gif"      WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

As you can see the pixels often form small highly disjoint islands, with no
set of pixels any thicker that the kernel used. </P>

The methods name '<I>Top Hat</I>' actually refers to the operators use when
applied using the method for gray-scale 3-dimensional morphology, and not with
binary images as we have done here.  </P>

This operator is more commonly used with greyscale images. </P>

<I>FUTURE: Example of greyscale top-hat</I> </P>


<A NAME="bottom-hat"></A>
<H3>Bottom-Hat</H3>

The '<CODE><B>BottomHat</B></CODE>' method, also known as '<I>Black
TopHat</I>' is the pixels that a <A HREF="index.html#close" >Closing</A> of the shape
adds to the image.  That is the the pixels that were used to fill in the
'holes', 'gaps', and 'bridges'.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert man.gif   -morphology BottomHat Disk  bottomhat_man.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="man.gif"
     ><IMG SRC="man.gif"               WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="close_man.gif"
     ><IMG SRC="close_man.gif"      WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="bottomhat_man.gif"
     ><IMG SRC="bottomhat_man.gif"      WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

Again you can see that it also results in highly disjoint 'islands' of pixels,
none of which is thicker that the kernel used. However they are always
a completely different set of islands to the previous method. </P>

<I>FUTURE: Example of greyscale bottom-hat</I> </P>


<HR><!-- ---------------------------------------------------------------- -->

<A NAME="using"></A>
<H2>Using Low Level Morphology Methods</H2>

<A NAME="channel"></A>
<H3>Basic Morphology and Channels</H3>

All the above basic morphology methods are channel methods, as such they are
applied to the individual channels of an image according to the current
"<CODE><A HREF="../../../html/www/command-line-options.html#channel" >-channel</A></CODE>" setting.
</P>

This means you can apply these methods to color images, provided you are not
too fussy about 'color leakage' from undefined transparent areas. </P>

For example lets '<CODE><A HREF="index.html#erode" >Erode</A></CODE>' the alpha channel
of the original 'man figure' image, without modifying the color channels.

<!--<CODE EXECUTE>
  kernel2image -10.1 -m "Diamond:3"   kernel_diamond_3.gif
</CODE>-->
<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert figure.gif -channel A  -morphology Erode Diamond:3 \
          +channel   figure_erode.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="../images/figure.gif"
     ><IMG SRC="../images/figure.gif"               WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=2 HSPACE=0 BORDER=0 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/mph_erode.gif" ALIGN=middle WIDTH=20 HEIGHT=30 ALT="-">
  <A HREF="kernel_diamond_3.gif"
     ><IMG SRC="kernel_diamond_3.gif"
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=0 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="figure_erode.gif"
     ><IMG SRC="figure_erode.gif"      WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=2 HSPACE=0 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

As you can see it works fine. </P>

For other examples see <A HREF="../canvas/index.html#sparse_fill" >Sparse Color as
a Fill Operator</A>, using the '<CODE><A HREF="index.html#edgein" >EdgeIn</A></CODE>'
method to find the edge pixels of an image. Also <A HREF="../masking/index.html#outline"
>Outline or Halo Transparency</A> using '<CODE><A HREF="index.html#edgeout"
>EdgeOut</A></CODE>' to expand the edges of an image with a specific color.
</P>


<A NAME="searching"></A>
<H3>Search for Specific Shapes</H3>

<PRE>
Knowledge about an object depends on the manner in which we probe (observe)
it.                    -- Georges Matheron, The Father of Morphology

Using Erode to locate specific shapes from a large correction of shapes. Taken
to extreme this creates <A HREF="index.html#skeletons" >Skeletons</A>, see also <A
HREF="index.html#thinning_skeleton" >Thinning Skeletons</A>.

Restoring objects using Open (smoothed result) or <A
HREF="index.html#dilate_conditional" >Conditional Dilation</A>.

Needs some sort of Connected Component Analysis, (Segmentation) to properly
count objects found within an image.

</PRE>


<A NAME="granularity"></A>
<H3>Granularity of a collection of Shapes</H3>

By using a series of '<CODE><A HREF="index.html#open" >Open</A></CODE>' operations in an
image of slowly increasing size structuring elements, and measuring the
resulting area, you can quickly get a summery of number of such shapes that
can be found in the image. </P>

By taking the derivative (slope) of that result you get a 'spectrum' of the
number and size those shapes that form the image. This graph is the
'<B>granularity</B>' of the image for some particular shape. </P>

See <A HREF="http://en.wikipedia.org/wiki/Granulometry_%28morphology%29"
>Granulometry (morphology), Wikipedia</A>. </P>

The differences from one size to the next will also let you separate and count
specific elements based on size, and in turn separate areas containing
different sized and shaped elements.  The result is a method of texture
segmentation. </P>

<I>Demonstration of determining the number and size a collection of shapes.
However this requires a 'counting' method (to be added) to implement fully.
</I></P>

<B>Historical note...</B></P>

This usage was in fact the original driving force behind the original creation
of morphology methods, at a Paris mining company, in the 1960's.  It allowed
the creators to create an automated system to analyze the grain structure of
microscopic photos of mineral samples to determine their suitability for
mining. That is locate and count the size and amount of mineral in samples.
</P>

For example: Two mineral ores may have the same amount of desired mineral
(usually as grains or crystals in the rock), but only the ore with larger
grains could be effectively mined as it allowed you to more easily separate
the large pure mineral from the surrounding ore bearing rock.  This was a very
labour intensive task, which morphology made a lot easier. </P>

<A NAME="asymmetric"></A>
<H3>Asymmetric Kernel Effects
<FONT SIZE=-1>(Basic Method Tests)</FONT></H3>

Lets have a look at how these basic method work when used with a kernel which
is not symmetrical.  For example here I apply an user defined 'L' shape against
a special morphological test image  (enlarged for viewing individual pixels).

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE SCRIPT>
  for method in  erode dilate open close; do
    convert test_morphology.gif \
             -morphology $method  '2x3+1+1: 1,-  1,-  1,1 '  test_$method.gif
  done
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="test_mag.gif"
     ><IMG SRC="test_mag.gif"      WIDTH=156  HEIGHT=102
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Text]"></A>
</TD></TR></TABLE></P>
<!-- <CODE EXECUTE SCRIPT>
 for method in  '' _erode _dilate _open _close; do
   convert test$method.gif -scale 156x102 test${method}_mag.gif
 done
</CODE> -->


Which has the following results... <P>

  <A HREF="test_erode.gif"
     ><IMG SRC="test_erode_mag.gif"      WIDTH=156  HEIGHT=102
           ALIGN=right VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Text]"></A>

<B>'<CODE><A HREF="index.html#erode" >Erode</A></CODE>'</B>
results in any exact match of the kernel shape, becoming a single white pixel
at the matching point 'origin'.  It will also expand any single pixel 'hole'
into that same shape but 'reflected' around the 'origin', that is as if the
kernel had been rotated 180 degrees. <BR CLEAR=all></P>

  <A HREF="test_dilate.gif"
     ><IMG SRC="test_dilate_mag.gif"      WIDTH=156  HEIGHT=102
           ALIGN=right VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Text]"></A>

<B>'<CODE><A HREF="index.html#dilate" >Dilate</A></CODE>'</B> As expected produces that
same results but for a 'negative' and 'reflected' form of either the image or
the kernel.   A single white pixel expands to the kernel shape, while any
matching 'reflected' shaped hole, shrinks down to a single pixel 'hole'. <BR
CLEAR=all></P>

Note also that the boundary between positive and negative halves of the test
image does move as consequence of applying the above basic morphological
methods.  That is to be expected.  </P>

This brings up a specific point about these two methods.  To convert
a '<CODE><A HREF="index.html#erode" >Erode</A></CODE>' methods into a '<CODE><A
HREF="index.html#dilate" >Dilate</A></CODE>' or visa-versa, you not only need to <A
HREF="../color_mods/index.html#negate" >Negate</A> the images before and after, but you
also need to rotate or reflect the kernel about the origin.  Normally this
second aspect can be ignored, as most kernels are 'symmetrical'. It only
becomes important with user defined asymmetrical kernels.  </P>

  <A HREF="test_open.gif"
     ><IMG SRC="test_open_mag.gif"      WIDTH=156  HEIGHT=102
           ALIGN=right VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Text]"></A>

<B>'<CODE><A HREF="index.html#open" >Open</A></CODE>'</B> as mentioned before, generally
does not remove any 'holes' in the image, however an exactly matching shape
will remain unchanged.  Larger shapes (such as the negative half of the test
image, may also remain, but perhaps slightly modified.  <BR CLEAR=all></P>

  <A HREF="test_close.gif"
     ><IMG SRC="test_close_mag.gif"      WIDTH=156  HEIGHT=102
           ALIGN=right VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Text]"></A>

<B>'<CODE><A HREF="index.html#close" >Close</A></CODE>'</B> is an exact negative result
of the previous, but is defined such that it does not need the kernel to be
reflected (as it is reflected by its internal definition), only the image
negated.  <BR CLEAR=all></P>


<HR><!-- ---------------------------------------------------------------- -->

<A NAME="hmt"></A>
<A NAME="hitmiss"></A>
<A NAME="hitandmiss"></A>
<H2>Hit And Miss (HMT) Pattern Matching</H2>

<H3>Hit-And-Miss
&nbsp; <FONT SIZE=5>(
<IMG SRC="../img_www/mph_hitmiss.gif" ALIGN=absmiddle>
)</FONT></H3>

The '<CODE>Hit-And-Miss</CODE>' morphology method, also commonly known as
"<I>HMT</I>" in computer science literature, is a high level morphology method
that is specifically designed to find and locate specific patterns in images.
It does this by looking for a specific configuration of 'foreground' and
'background' pixels around the 'origin'. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/warning.gif"  WIDTH=28 HEIGHT=28
    ><IMG SRC="../img_www/space.gif"   WIDTH=12 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  As of IM v6.6.9-4, you can use any of the method names
  '<CODE>HitAndMiss</CODE>', '<CODE>Hit_N_Miss</CODE>' or just
  '<CODE>HMT</CODE>', and the variants, to specify this morphology method.
  Before this version only the '<CODE>HitAndMiss</CODE>' method name could be
  used.

</I></FONT></TD></TR></TABLE></P>

For example we could look for a 'foreground' pixel, which has a 'background'
pixel immediately to its right.

<!--<CODE EXECUTE>
  kernel2image -30.2 -m "2x1:1,0"    kernel_right.gif
</CODE>-->
<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert man.gif   -morphology Hit-and-Miss '2x1:1,0'  hmt_right.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="man.gif"
     ><IMG SRC="man.gif"               WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/mph_hitmiss.gif" ALIGN=middle WIDTH=20 HEIGHT=30 ALT="o">
  <A HREF="kernel_right.gif"
     ><IMG SRC="kernel_right.gif"
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="hmt_right.gif"
     ><IMG SRC="hmt_right.gif"      WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

As you can see the small 2 element kernel only matched the pixels, that were
on the right side of the image.  That is the method only returned a specific
pixel which matched the given pattern. </P>

The 'Kernel' or 'Structuring Element' used can contain a pattern of 3 types of
elements only:  a value of '<CODE>1</CODE>' meaning 'foreground', a value of
'<CODE>0</CODE>' meaning 'background', and also a third element which can be
specified as either '<CODE>Nan</CODE>', or '<CODE>-</CODE>' or a value of
'<CODE>0.5</CODE>' which means 'I Don't Care' or 'Any Pixel' </P>

What value you use for the 'origin' is very important as it will define
whether you only want to 'hit' the foreground shape, or the background
pattern.  But if you specifically set the 'origin' value to a value of 'I
Don't Care', then you can match either foreground and background pixels
who has the correct surrounding neighbourhood. </P>

For example if I use a structured element like...

<!--<CODE EXECUTE>
  kernel2image -30.2 -m "3x1:1,-,0"    kernel_right2.gif
</CODE>-->
<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert man.gif   -morphology Hit-and-Miss '3x1:1,-,0'  hmt_right2.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="man.gif"
     ><IMG SRC="man.gif"               WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/mph_hitmiss.gif" ALIGN=middle WIDTH=20 HEIGHT=30 ALT="o">
  <A HREF="kernel_right2.gif"
     ><IMG SRC="kernel_right2.gif"
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="hmt_right2.gif"
     ><IMG SRC="hmt_right2.gif"      WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

You get any right edge pixels which are either inside or outside. As such you
are now marking both sides of the shape boundary, and extracting a 2 pixel
wide edge.  However not all pixels match the patten, so not ever pixel is
doubled, but in general that is what you get. </P>

The use of a 'I Don't Care' value for the 'origin' is actually very common,
especially when we later look at <A HREF="index.html#thicken" >Thicken</A> and <A
HREF="index.html#thinning" >Thinning</A> methods, which restrict themselves to either
adding or removing pixels.  By 'Not Caring' the same kernel definition could
be used for either operation, as the operation itself defines what type of
'hits' you are interest in. </P>

<BR>

Here is another example, but this time I again limit my 'hits' to pixels that
fall inside the shape but which form a North-West facing corner.

<!--<CODE EXECUTE>
  kernel2image -30.2 -m "3:0,0,- 0,1,1 -,1,-"    kernel_nw_corner.gif
</CODE>-->
<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert man.gif   -morphology HMT "3:0,0,- 0,1,1 -,1,-" hmt_nw_corner.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="man.gif"
     ><IMG SRC="man.gif"               WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/mph_hitmiss.gif" ALIGN=middle WIDTH=20 HEIGHT=30 ALT="o">
  <A HREF="kernel_nw_corner.gif"
     ><IMG SRC="kernel_nw_corner.gif"
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="hmt_nw_corner.gif"
     ><IMG SRC="hmt_nw_corner.gif"      WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

By expanding this single corner to a set of 90 degree Rotated Corners by
adding a '<CODE>&gt;</CODE>' flag, we can find all corners that appear within
the shape.

<!--<CODE EXECUTE>
  kernel2image -20.2 -ml '' -mt x1 "3>:0,0,- 0,1,1 -,1,-" \
       kernel_hmt_corners.gif
</CODE>-->
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=top><TD WIDTH=100% ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert man.gif  -morphology HMT "3>:0,0,- 0,1,1 -,1,-" hmt_corners.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="kernel_hmt_corners.gif"
     ><IMG SRC="kernel_hmt_corners.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</TD><TD>
  <A HREF="hmt_corners.gif"
     ><IMG SRC="hmt_corners.gif"      WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

As you can see the '<CODE><A HREF="index.html#hmt" >Hit-And-Miss</A></CODE>'
method locates and returns ALL the pixel positions which match any of the
kernel patterns provided. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/expert.gif"   WIDTH=23 HEIGHT=26
    ><IMG SRC="../img_www/space.gif"   WIDTH=17 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  If you were to examine the <A HREF="index.html#verbose" >Verbose Output</A> of the
  "<CODE><A HREF="../../../html/www/command-line-options.html#morphology" >-morphology</A></CODE>"
  operation above, you will find that the '<CODE><A HREF="index.html#hmt"
  >Hit-And-Miss</A></CODE>' uses a '<CODE><A HREF="../compose/index.html#set_theory"
  >Lighten</A></CODE>' composition method to create a 'union' of all the
  pixels that match each of the pattern kernels provided. </P>

  Unfortunately the 'changed' pixel count is of all the pixels which are
  turned off by each kernel application.  In other words the number of pixels
  in the shape, minus the number of pixels that were matched by each kernel.
  </P>

</I></FONT></TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/expert.gif"   WIDTH=23 HEIGHT=26
    ><IMG SRC="../img_www/space.gif"   WIDTH=17 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  By the same token, repeating a the <A HREF="index.html#hitmiss" >Hit-And-Miss
  Method</A> with the results of itself is usually useless as the image would
  have change so much you will probably end up with no matches afterward. </P>

  You can, and as you see, use the results to modify the original image so as
  to generate a slightly different image.

</I></FONT></TD></TR></TABLE></P>

You can use a set of kernels that are more selective of what you are
specifically interested in.  For example suppose you are interested in the
points where three lines meet.  Then you can use the '<CODE><A
HREF="index.html#linejunctions" >LineJunctions</A></CODE>' kernel set, which is designed
specifically for this purpose.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert lines.gif -morphology HMT LineJunctions hmt_junctions.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="lines.gif"
     ><IMG SRC="lines.gif"               WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="hmt_junctions.gif"
     ><IMG SRC="hmt_junctions.gif"      WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

As you can see only a sprinkling of locations match any of the kernels in that
set.  However the results can make it very difficult to actually see where the
matching locations were in the original image.  This is especially bad if you
are dealing with a grey-scale image. </P>

One solution is to expand the matches using '<CODE><A HREF="index.html#dilate"
>Dilate</A></CODE>' with some <A HREF="http://legacy.imagemagick.org/Usage/morphology/man_kernels" >Shape Kernel</A>, such as
a '<CODE><A HREF="index.html#ring" >Ring</A></CODE>'.  For example...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert lines.gif \( +clone \
             -morphology HMT LineJunctions \
             -morphology Dilate Ring \
             -background red -alpha shape \
          \) -composite              hmt_junctions_rings.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="hmt_junctions_rings.gif"
     ><IMG SRC="hmt_junctions_rings.gif"      WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

You can now clearly see locations where this particular set of kernels
found Junctions of 3 or more lines. </P>

Each of the kernels in '<CODE><A HREF="index.html#linejunctions"
>LineJunctions</A></CODE>' may only match a couple of specific locations, as
such pattern matching in this way can be slow.  Still it is very precise and
works very well. </P>

Another similar '<CODE><A HREF="index.html#hitmiss" >Hit-And-Miss</A></CODE>' kernel set
is the '<CODE><A HREF="index.html#lineend" >LineEnds</A></CODE>' kernel which can be
used to find the free ends of all the lines in the image.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert lines.gif \( +clone \
             -morphology HMT LineEnds \
             -morphology Dilate Ring \
             -background red -alpha shape \
          \) -composite                  hmt_lineends_rings.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="hmt_lineends_rings.gif"
     ><IMG SRC="hmt_lineends_rings.gif"      WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>


<I>HitandMiss - with foreground pixels only -> erode</I></P>

<I>HitandMiss - with background only -> negated dilate</I></P>


<A NAME="hitmiss_greyscale"></A>
<H4>Hit And Miss with Gray-scale Images</H4>

When the '<CODE><A HREF="index.html#hitmiss" >Hit-And-Miss</A></CODE>' method is
applied to a gray-scale image, that actual value returned will be the
difference between the minimum 'foreground' value and the maximum 'background'
value.  If a negative result occurs (no math) the result is 'clipped to zero'
as negatives have no real meaning. </P>

In other words it returned the '<I>minimum separation</I>' of values between
the two sets of pixels. </P>

For Boolean shapes, that will be either '<CODE>0.0</CODE>' (black) or
'<CODE>1.0</CODE>' (white).  But for gray-scale images this is equivalent to
the 'gradient' of the matching pixels. It can for example be used to identify
just how much contrast is present between a particular foreground and
background in the matching pattern.  </P>

If you really only want a Boolean (on/off) result of what pixels actually
match the pattern in a grey-scale image, you should add a "<CODE><A
HREF="../../../html/www/command-line-options.html#threshold" >-threshold</A> 0</CODE>" option after the
command. </P>


<A NAME="thicken"></A>
<H3>Thicken
<!--&nbsp <FONT SIZE=5>(
<IMG SRC="../img_www/mph_thicken.gif" ALIGN=absmiddle>
)</FONT> &nbsp; -->
<FONT SIZE=3>(Adding Pixels to a Shape)</FONT></H3>


The '<CODE>Thicken</CODE>' method will add pixels to the original shape at
every matching location. </P>

For example here I look for a background pixel that is two pixels away from
the right edge of the shape.

<!--<CODE EXECUTE>
  kernel2image -30.2 -m "3x1+2+0:1,0,0"    kernel_right_out.gif
</CODE>-->
<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert man.gif   -morphology Thicken '3x1+2+0:1,0,0'  thick_right.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="man.gif"
     ><IMG SRC="man.gif"               WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/mph_hitmiss.gif" ALIGN=middle WIDTH=20 HEIGHT=30 ALT="o">
  <A HREF="kernel_right_out.gif"
     ><IMG SRC="kernel_right_out.gif"
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="thick_right.gif"
     ><IMG SRC="thick_right.gif"      WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

As you can see you ended up with a line of pixels just outside the shapes
original boundary. </P>

You can <A HREF="index.html#iteration" >Iterate</A> this '<CODE>Thicken</CODE>' method
a few times to continue the sequence.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert man.gif   -morphology Thicken:4 '3x1+2+0:1,0,0'  thick_right2.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="thick_right2.gif"
     ><IMG SRC="thick_right2.gif"      WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

However as pixels are being added, the origin of the pattern matching kernel
should NOT match foreground pixel, or you will essentially be adding a pixel,
where a pixel is already present. </P>

In the above set the origin pixel to a background pattern, so only background
patterns will actually match.  An alternative is to always set the origin to
a 'Do Not Care' element value.  By doing this you will be able to use the same
kernel pattern for thicken '<CODE><A HREF="index.html#thicken" >Thicken</A></CODE>',
and as you will see later for '<CODE><A HREF="index.html#thinning" >Thinning</A></CODE>'
as well. </P>

So the better rule is set origin to 'Do Not Care'. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/expert.gif"   WIDTH=23 HEIGHT=26
    ><IMG SRC="../img_www/space.gif"   WIDTH=17 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  Another way to generate a '<CODE><A HREF="index.html#thicken" >Thicken</A></CODE>'
  operation is to generate a <A HREF="../compose/index.html#set_theory" >Union</A> of
  the results of '<CODE><A HREF="index.html#hitmiss" >Hit-And-Miss</A></CODE>' of this
  kernel with the special '<CODE><A HREF="index.html#unity" >Unity</A></CODE>' kernel
  so as to include the original image in the results.  </P>

  For example...

</I></FONT>
<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert man.gif -define morphology:compose=Lighten \
                  -morphology HitAndMiss 'Unity ; 3x1+2+0:1,0,0' hmt_thicken.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="man.gif"
     ><IMG SRC="man.gif"               WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="hmt_thicken.gif"
     ><IMG SRC="hmt_thicken.gif"
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

<FONT SIZE=-1><I>
  Actually the <A HREF="index.html#kernel_compose" >Multi-Kernel Composition Setting</A>
  in the above example is not needed as the '<CODE><A HREF="index.html#hitmiss"
  >Hit-And-Miss</A></CODE>' method specifically sets this composition setting
  by default, when not defined by the user. </P>

</I></FONT></TD></TR></TABLE></P>

<BR>

Typically '<CODE><A HREF="index.html#thicken" >Thicken</A></CODE>' is used to enlarge
shapes such as lines, but without making the lines longer.  A special set of
kernels known as the '<CODE><A HREF="index.html#convexhull" >ConvexHull</A></CODE>'
kernel, allows you to do this </P>

For example...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 80x80 xc:black -fill none -stroke white \
          +antialias   -draw 'line 10,20 70,60'     man_line.gif
  convert man_line.gif   -morphology Thicken ConvexHull  thick_line.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="man_line.gif"
     ><IMG SRC="man_line.gif"               WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="thick_line.gif"
     ><IMG SRC="thick_line.gif"      WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>


<A NAME="thicken_convexhull"></A>
<H4>Thicken - Octagonal Convex Hull</H4>

The actual '<CODE><A HREF="index.html#convexhull" >ConvexHull</A></CODE>' kernel is
really designed to work with image shapes, and will expand a shape into
a '<I>Octagonal Convex Hull</I>'.  That is it will try to fill in all the gaps
between the extremes until it produces a 'octagonal shaped' object. </P>

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert man.gif -morphology Close Diamond \
                  -morphology Thicken:-1 ConvexHull \
                  -morphology Close Diamond       man_hull_full.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="man.gif"
     ><IMG SRC="man.gif"              WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="man_hull_full.gif"
     ><IMG SRC="man_hull_full.gif"      WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
<BR><FONT SIZE=-2>
    See '<CODE><A HREF="index.html#convexhull" >ConvexHull</A></CODE>' kernel
      definition for more details, and why the two '<CODE><A
      HREF="index.html#close" >Close</A></CODE>' methods are needed.
</FONT>
</DIV></P>

You can watch the iterations being performed by turning on the <A
HREF="index.html#verbose" >Verbose Output Setting</A>.  However this will show that the
above is very very slow. </P>

Each '<CODE><A HREF="index.html#thicken" >Thicken</A></CODE>' iteration will only
actually add a few pixels to the shape on each iteration.  As such it can take
a lot of iterations before the full 'hull' is completed.  In this specific
case, the image required 80 '<CODE><A HREF="index.html#thicken" >Thicken</A></CODE>'
iterations, with a 8 kernel '<CODE><A HREF="index.html#convexhull"
>ConvexHull</A></CODE>'.  That means the above actually required 640 primitive
iterations, plus another 4 primitive iterations needed to do the two '<CODE><A
HREF="index.html#close" >Close</A></CODE>' methods. That can take quite a large amount
of time. </P>

Basically iterating using <A HREF="index.html#hmt" >Hit And Miss Pattern Matching</A>
can be very very '<I>slow</I>', and if an alternative technique can be found,
it should be used instead. </P>

You can use this to also find the what points of the original image caused the
creation of this octagonal shape, by getting an intersection (<A
HREF="../compose/index.html#darken" >Darken Composition</A>) and the edge of the convex
hull and the original shape.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert man_hull_full.gif \
              -morphology EdgeIn Diamond man_convex_edge.gif
  convert man.gif man_convex_edge.gif \
          -compose Darken -composite man_extremities.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="man_convex_edge.gif"
     ><IMG SRC="man_convex_edge.gif"              WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/intersection.gif" ALIGN=middle WIDTH=20 ALT="n">
  <A HREF="man.gif"
     ><IMG SRC="man.gif"              WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="man_extremities.gif"
     ><IMG SRC="man_extremities.gif"      WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

Any connected shape that fits inside the convex hull, but also includes at
least one pixel on every edge of the above convex hull, will generate the same
octagonal convex hull. </P>


<A NAME="thicken_greyscale"></A>
<H4>Thicken with Gray-scale Images</H4>

When handling a gray-scale image '<CODE><A HREF="index.html#thicken" >Thicken</A></CODE>'
will <B>add</B> the '<CODE><A HREF="index.html#hitmiss" >Hit-And-Miss</A></CODE>'
foreground and background separation result to the origin pixel. </P>

This can thus be used to make the matching pixels brighter, even when the
'origin' pixel is not in the 'background' set. </P>

For example, lets repeat the corner-find example from above but with
a 50% grey version of the shape.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert man.gif   -evaluate multiply 0.5   man_grey.gif
  convert man_grey.gif  -morphology Thicken Corners  thick_corners.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="man_grey.gif"
     ><IMG SRC="man_grey.gif"               WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="thick_corners.gif"
     ><IMG SRC="thick_corners.gif"      WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

When using a <A HREF="../basics/index.html#hdri" >HDRI version of Imagemagick</A> with
'<CODE><A HREF="index.html#thicken" >Thicken</A></CODE>' it is probably a good idea to
"<CODE><A HREF="../../../html/www/command-line-options.html#clamp" >-clamp</A></CODE>" or "<CODE><A
HREF="../../../html/www/command-line-options.html#auto-level" >-auto-level</A></CODE>" the results to
prevent it overflowing the image pixel value range limits. </P>

<BR>

<A NAME="thinning"></A>
<H3>Thinning
&nbsp; <FONT SIZE=5>(
<IMG SRC="../img_www/mph_thinning.gif" ALIGN=absmiddle>
)</FONT> &nbsp;
<FONT SIZE=3>(Subtracting Pixels from a Shape)</FONT></H3>

The '<CODE>Thinning</CODE>' method is the dual of '<CODE><A HREF="index.html#thicken"
>Thicken</A></CODE>'.  Rather than adding pixels, this method subtracts them
from the original image. </P>

For example lets remove any pixel that is 4 pixels in from the right edge.

<!--<CODE EXECUTE>
  kernel2image -20.2 -m "5x1+0+0:1,1,1,1,0"    kernel_right_in.gif
</CODE>-->
<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert man.gif   -morphology Thinning '5x1+0+0:1,1,1,1,0' thin_right.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="man.gif"
     ><IMG SRC="man.gif"               WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/mph_thinning.gif" ALIGN=middle WIDTH=20 HEIGHT=30>
  <A HREF="kernel_right_in.gif"
     ><IMG SRC="kernel_right_in.gif"
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="thin_right.gif"
     ><IMG SRC="thin_right.gif"      WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

For '<CODE>Thinning</CODE>' to work properly the pattern matching kernel
should have an origin containing a foreground pixel, otherwise the method
has no matching pixel to remove from the shape. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/expert.gif"   WIDTH=23 HEIGHT=26
    ><IMG SRC="../img_www/space.gif"   WIDTH=17 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  Another way to generate a '<CODE><A HREF="index.html#thinning" >Thinning</A></CODE>'
  operation is to <A HREF="../compose/index.html#set_theory" >Relative Complement</A>
  (using a <A HREF="../compose/index.html#minussrc" >MinusSrc</A> composition) the
  results of '<CODE><A HREF="index.html#hitmiss" >Hit-And-Miss</A></CODE>' from the
  original image.  You can include that image at the start of the kernel list
  (to 'subtract' from) by using a '<CODE><A HREF="index.html#unity" >Unity</A></CODE>'
  kernel.  </P>

  For example...

</I></FONT>
<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert man.gif -define morphology:compose=MinusSrc \
          -morphology HMT 'Unity ; 5x1+0+0:1,1,1,1,0' hmt_thinning.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="man.gif"
     ><IMG SRC="man.gif"               WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="hmt_thinning.gif"
     ><IMG SRC="hmt_thinning.gif"
           ALIGN=middle VSPACE=2 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

<FONT SIZE=-1><I>
  This is an 'intersection' style of thinning, removing all the specified
  pixels of all the kernels in a single step, rather than 'iterative' style,
  that removes the pixels from each kernel in sequence. See <A
  HREF="index.html#thinning_style" >Thinning Style</A> for more info. </P>

</I></FONT></TD></TR></TABLE></P>

<H4>Line Connected-ness</H4>

<I>FUTURE: 4-connected verses 8-connected lines</I></P>

See discussion in IM forums, <A HREF="http://legacy.imagemagick.org/Usage/forum_link.cgi?f=1&amp;t=21253" >From
8-connected to 4-connected lines</A>. </P>



<A NAME="thinning_edgedet"></A>
<H4>Thinning Edge Detector Output </H4>

One of the most common uses of thinning is to reduce the threshold output of
an <A HREF="../convolve/index.html#edgedet" >Edge Detector</A> such as  <A
HREF="../convolve/index.html#sobel" >Sobel Convolution</A>, to lines of a single pixel
thickness, while preserving the full length of those lines. </P>

<I>Example using a Distance Gradient Image</I>. </P>


<A NAME="thinning_skeleton"></A>
<H4>Thinning down to a Skeleton </H4>

'<CODE><A HREF="index.html#thinning" >Thinning</A></CODE>' images is actually more
commonly used than '<CODE><A HREF="index.html#thicken" >Thicken</A></CODE>', as it is
used to reduce the shapes into more manageable forms, such as <A
HREF="index.html#skeletons" >Skeletons</A>.  Which, as will be discussed later, are meant
to be the center line of pixels between any two (or more) edges of the
shape.</P>

A skeleton is important as it provides a very good description of a very complex
shape. For example processing the image to find the number of loops, line
segments, and how they are arranged, will tell you a lot about the shape that
you have. </P>

So lets produce a '<I>Thinned Skeleton</I>' by '<CODE><A HREF="index.html#thinning"
>Thinning</A></CODE>' the edges of the man shape down repeatedly, until only
the center lines are left.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert man.gif  -morphology Thinning:-1 Skeleton  man_raw_thinned.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="man.gif"
     ><IMG SRC="man.gif"               WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="man_raw_thinned.gif"
     ><IMG SRC="man_raw_thinned.gif"      WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

A <A HREF="index.html#verbose" >Verbose</A> report on the above would have shown that 18
iterations, with 8 kernels, totalling 144 primitive iterations in total.  this
is actually a lot faster than finding its <A HREF="index.html#thicken_convexhull"
>Convex Hull</A> (above), as the thinning kernels remove whole rows and
columns of pixels with each iteration, and not just a few at a time. </P>

Note how the '<CODE><A HREF="index.html#skeleton" >Skeleton</A></CODE>' kernel set
failed to expand the hole, so that it did not find the center line between the
hole and the outside edge. This is a serious failing of this specific skeleton
thinning kernel, and is caused by the kernels all requiring at least
background pixels before they will make any thinning match.  </P>

You can use sets of skeleton thinning kernels to solve this problem. </P>

A simplier solution is to <A HREF="index.html#erode" >Erode</A> the image slightly to
give the kernels something to work with.  I will also only erode and thin the
'Red' and 'Green' channels, so as to leave original shape in blue.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert man.gif -channel RG -morphology Erode Diamond  man_erode.gif
  convert man_erode.gif -channel RG \
          -morphology Thinning:-1 Skeleton +channel  man_skeleton.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="man_erode.gif"
     ><IMG SRC="man_erode.gif"               WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="man_skeleton.gif"
     ><IMG SRC="man_skeleton.gif"      WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

You can also see that any hole in the image has now expanded to produce larger
continuous loop of pixels around it. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>

Here is a close up of loop around the eroded hole.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert man_skeleton.gif -crop 22x22+47+29 +repage \
          -scale 120x120    man_skeleton_zoom.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="man_skeleton_zoom.gif"
     ><IMG SRC="man_skeleton_zoom.gif"      WIDTH=120 HEIGHT=120
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Note that it did not produce an exact center-line between the hole and the
edge.  Also as the shape was eroded, the lines do not go right the edge of the
original the shape but stop one pixel short. That is the end of lines have
been 'pruned' slightly.  That is the disadvantage of the 'erode' soltion. </P>

The skeleton is also limited to octagonal lines, which means it is missing
a lot of detail, though in this case that simplification can be a good thing.
See the section on <A HREF="index.html#skeletons" >Skeletons</A> below. </P>

This is a traditional '<CODE><A HREF="index.html#skeleton" >Skeleton</A></CODE>' kernel,
which as you can see produces 'thick' diagonal lines, so that all parts of the
skeleton are '4-connected' or 'diamond connected'.  There are other variations
of '<CODE><A HREF="index.html#skeleton" >Skeleton</A></CODE>' kernels, which will
produce other variations in the resulting '<I>Thinned Skeleton</I>'.  </P>

<A NAME="thinner_skeleton"></A>
<B>Thinner, 8 Connected, Skeleton</B></P>

This 'traditional' skeleton as mentioned has thick diagonals. But often this
is not 'thin' enough.  In some situations what you want is a slightly thinner
skeleton. That is you want an '8-connected' skeleton rather than '4-connected'
skeleton.  </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>

One solution is to use a different skeleton generation variant, such as
generated using a '<CODE><A HREF="index.html#skeleton2" >Skeleton:2</A></CODE>' kernel,
(found on the <A HREF="http://homepages.inf.ed.ac.uk/rbf/HIPR2/morops.htm"
>HIPR2 Graphic Tutorial Website</A>). For example...

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert man.gif   -channel RG  -morphology Erode Diamond \
          -morphology Thinning:-1 Skeleton:2 +channel  man_skeleton_hipr.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="man_skeleton_hipr.gif"
     ><IMG SRC="man_skeleton_hipr.gif"      WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>

And here is a zoom of the loop area, showing how the resulting skeleton is
8-connected, with thinner diagonals.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert man_skeleton_hipr.gif -crop 22x22+47+29 +repage \
          -scale 120x120    man_skeleton_hipr_zoom.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="man_skeleton_hipr_zoom.gif"
     ><IMG SRC="man_skeleton_hipr_zoom.gif"      WIDTH=120 HEIGHT=120
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

However I have found such skeletons to not be as accurate as the 'traditional'
skeleton.  Basically in test cases I have found that the diagonals were
'thinned' on the wrong side.  Basically because the side of the diagonals that
is removed is controlled purely by the  order of the 'corner' thinning kernel
in the kernel set, and not by any decision due to the nature of the shape.
</P>

<BR>

The alternative is to take a 'traditional' skeleton, and thin it so that the
diagonals are always thinned on the 'outside' of the diagonal, as defined by
the end points of the diagonal. </P>

The special '<CODE><A HREF="index.html#diagonals" >Diagonals</A></CODE>'
thinning kernel, is designed to do this, with a '<CODE><A HREF="index.html#corners"
>Corners</A></CODE>' kernel being used afterward to 'finish'.  So lets thin
the previous 'traditional' skeleton further..

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert man_skeleton.gif -channel RG \
          -morphology Thinning:-1 Diagonals \
          -morphology Thinning Corners   man_thin_skeleton.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="man_skeleton.gif"
     ><IMG SRC="man_skeleton.gif"   WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="man_thin_skeleton.gif"
     ><IMG SRC="man_thin_skeleton.gif"    WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

This technique of thinning a traditional 4-connected skeleton, is slightly
slower, than simply directly using the  '<CODE><A HREF="index.html#skeleton2"
>Skeleton:2</A></CODE>' variant. The extra thinning required 8 thinning
iterations of the 8 kernels, or 64 primitive iterations. </P>

Alternately you can just use the '<CODE><A HREF="index.html#corners"
>Corners</A></CODE>' kernel only, though that will just generate the 'HIPR'
variant, with just a 'random' choice of which side of the diagonals was
thinned. However it will only take 1 pass of all 4 kernels, and as such it
much much faster than using '<CODE><A HREF="index.html#diagonals"
>Diagonals</A></CODE>'. </P>

In any case by starting with a 'traditional' 4-connected skeleton, you can
then generated an 8-connected version (of some kind), Very easily. </P>


<A NAME="skeleton_info"></A>
<H4>Skeleton Information</H4>

When you have a skeleton (perhaps even both a 4 and 8 connected version) the
next step is usually to find out more information about the skeleton. For
example how many 'free end of lines', 'line junctions', and 'line loops' are
present. </P>

<I>Number of Line Ends</I></P>

Here I use the a <A HREF="index.html#hitmiss" >Hit And Miss Search</A> for '<CODE><A
HREF="index.html#lineends" >LineEnds</A></CODE>' on the skeleton we generated previously
(extracting it from the 'red' channel).  I then <A HREF="index.html#dilate" >Dilate</A>
those line ends into <A HREF="index.html#ring" >Rings</A> and color them before merging
with the original skeleton, to make their locations highly visible.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert man_skeleton.gif -channel R -separate +channel \
          -morphology HMT LineEnds man_ends.gif
  convert man_ends.gif -morphology Dilate Ring -background Red -alpha Shape \
          man_skeleton.gif +swap -composite man_ends_marked.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="man_skeleton.gif"
     ><IMG SRC="man_skeleton.gif"         WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="man_ends.gif"
     ><IMG SRC="man_ends.gif"             WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="man_ends_marked.gif"
     ><IMG SRC="man_ends_marked.gif"      WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

Note that the lines all connect each other, or to the loop of pixels were not
found. Only the free line ends were indicated. </P>

If you did a pixel count (using a <A HREF="../files/index.html#histogram" >Histogram
Output</A>) you would see that this skeleton generated 12 line ends. </P>


<I>Number of Line Junctions</I></P>

You can get a rough count count of the number of line junctions in an image by
using the '<CODE><A HREF="index.html#linejunctions" >LineJunctions</A></CODE>' kernel
with a <B>8-connected skeleton</B>, preferably one that was thinned down from
the original skeleton used for counting line-ends.  Do not mix two different
skeleton generation variants.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert man_thin_skeleton.gif -channel R -separate +channel \
            -morphology HMT LineJunctions  man_junctions.gif
  convert man_junctions.gif -morphology Dilate Ring \
          -background Red -alpha Shape \
            man_thin_skeleton.gif +swap -composite man_junctions_marked.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="man_thin_skeleton.gif"
     ><IMG SRC="man_thin_skeleton.gif"               WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="man_junctions.gif"
     ><IMG SRC="man_junctions.gif"           WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="man_junctions_marked.gif"
     ><IMG SRC="man_junctions_marked.gif"      WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>


If you did try try this kernel directly with a traditional 4-connected
skeleton, you will get multiple matches for some of the '<CODE>T</CODE>'
junctions, making the count very inaccurate. </P>

The result as you can see are 12 line junctions, which for this specific
shape is correct. </P>

However for some junctions the '<CODE><A HREF="index.html#linejunctions"
>LineJunctions</A></CODE>' kernel is inaccurate.  For example a 4-line
diagonal '<CODE>X</CODE>' junction will only produce 1 match, while
an orthogonal '<CODE>+</CODE>' junction, will produce 4 matches.  Both of these
special junctions should produce 2 matches, to keep the line junction count
correct. </P>

As such to get an accurate count you will need to add 1 more value for every
'<CODE>X</CODE>' junction, and subtract 2 counts for every '<CODE>+</CODE>'
junction. </P>

<BR>

For a skeleton that has no loops the number of junctions should be 2 less than
the number of line ends. However if the number of  line ends equals the number
of line junctions it means you have one or more loops in the skeleton.  </P>

Now this skeleton has 12 line ends and 12 junctions. so it contains at least
one continuous loop of pixels somewhere in the image. </P>

<I>Number of Loops</I></P>

<I>FUTURE: Connected Object Labeling</I> </P>


<A NAME="thinning_pruning"></A>
<H4>Pruning Lines</H4>

So you know this image has at least one loop. Suppose you want to simplify the
shape to just those loop(s). The solution to to '<I>Prune</I>' all the line
ends repeatedly until you have removed them all. </P>

For a 4-connected skeleton such as this you can even use a smaller set of
'<CODE><A HREF="index.html#lineends_subtypes" >LineEnds</A></CODE>' kernels to make
process about twice as fast.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert man_skeleton.gif -channel G \
          -morphology Thinning:-1 'LineEnds:1>' man_loop.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="man_skeleton.gif"
     ><IMG SRC="man_skeleton.gif"               WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="man_loop.gif"
     ><IMG SRC="man_loop.gif"           WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

A <A HREF="index.html#verbose" >Verbose</A> report on this would have shown that this
took 75 iterations with 4 kernels, resulting in 300 primitive integrations to
'<I>Prune</I>' all the lines with free ends from the image. </P>

That is about twice as many operations as was used to find the skeleton, which
shows how much more intensive this operation can be.  Using a full set of
'<CODE><A HREF="index.html#lineends" >LineEnds</A></CODE>' kernels (8 kernels), would
also have taken 75 iterations, but with twice as many kernels, making this 600
primitive iterations. </P>


<A NAME="thinning_prune_fast"></A>
<H4>Fast Pruning of Lines</H4>

<PRE>Fast Complete pruning technique..

  1/  Find line ends, and line junctions.
  2/  Delete the line junctions to completely disconnect all line segments.
  3/  Flood fill, or use contitional dilate to remove 'line end' segments.
  4/  Restore line junctions.
  5/  use that as a map on original image to restore 'loops'.

</PRE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>

We have already covered the first step... resulting in...

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE DO_NOT_EXECUTE already done>
  convert man_skeleton.gif -channel R -separate +channel \
          -morphology HMT LineEnds man_ends.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="man_ends.gif"
     ><IMG SRC="man_ends.gif"             WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>


To disconnect (or separate) all the line segments you can use a '<CODE><A
HREF="index.html#linejunctions" >LineJunctions</A></CODE>' kernel.  However the default
kernel set will not completely disconnect '<CODE>T</CODE>' junctions (just
locate them). </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>

To properly disconnect all line segment you will also need to add orthogonal
'<CODE>T</CODE>' kernels to the kernel set, and it is also best to include
a '<CODE>+</CODE>' junction too.  For example.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert man_skeleton.gif -channel R -separate +channel \
      -morphology HMT 'LineJunctions;LineJunctions:3>;LineJunctions:5' \
      man_disconnect.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="man_disconnect.gif"
     ><IMG SRC="man_disconnect.gif"       WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>

Thinning with these matches will actually disconnect the segments, however you
must do this all in one step, (see <A HREF="index.html#thinning_style" >Thinning
Style</A>), or it will not work correctly.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert man_skeleton.gif -channel R -separate +channel \
      -define morphology:compose=Darken \
      -morphology Thinning 'LineJunctions;LineJunctions:3>;LineJunctions:5' \
      man_line_segments.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="man_line_segments.gif"
     ><IMG SRC="man_line_segments.gif"       WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>

Here is a zoom of the 'loop' showing the disconnected segments.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert man_line_segments.gif -crop 22x22+47+29 +repage \
          -scale 120x120    man_line_segments_zoom.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="man_line_segments_zoom.gif"
     ><IMG SRC="man_line_segments_zoom.gif"      WIDTH=120 HEIGHT=120
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

At this point we can now remove any line segment that contains a match
with the previously discovered 'line end'. </P>

This can be done either by 'flood filling' from those 'seed' points, to delete
them.  However this only works for a 4 connected skeleton, which is what flood
filling assumes. </P>

<I>Example Here</I></P>

Alternatively we can use <A HREF="index.html#cond_dilation" >Conditional Dilatation</A>
to find all all the points simultaneously, and remove them.

<I>Example Here - when Conditional Dilate or Erode is available.</I></P>

If you now restore the line junctions, do one prune, and remove any single
pixels that are left, you will now have removed all the line segments quickly.
</P>

Yes this seems like a lot of steps, but believe me it is still a lot faster
than having to '<I>prune the end of lines</I>' 300 times to get the same
result. </P>



<A NAME="thinning_style"></A>
<H4>Thinning Style - Sequential or Simultaneous</H4>

If you were to do one single 'pruning' of the end of the line segments, and
compare it to the original image you will find that more often than not a line
segment was pruned anywhere from 2 to 4 times, depending on the exact shape
and orientation of the lines. </P>

For example (resulting image enlarged) is is a default line ends thining

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 10x10 xc:black -fill white \
          +antialias  -draw 'line 1,7 8,3' line.gif
  convert line.gif -channel GB \
          -morphology Thinning LineEnds  line_seqential.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="line_mag.gif"
     ><IMG SRC="line_mag.gif"               WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="line_seqential_mag.gif"
     ><IMG SRC="line_seqential_mag.gif"           WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>
<!--
  convert line.gif -scale 800% line_mag.gif
  convert line_seqential.gif -scale 800% line_seqential_mag.gif
-->

That is because by default each of the '<CODE><A HREF="index.html#thinning"
>Thinning</A></CODE>' kernels is applied against the results of previous
kernel, in <I>sequence</I>.  That is it removes all the pixels selected by one
kernel, before appling the next kernel to that result, which may (and does)
select more pixels from the same end of line. In other words it will, by
default, thin the end of the lines multiple times for one complete 'iteration'
though all the kernels provided. </P>

That means you can not rely on the <A HREF="index.html#verbose" >Verbose Output</A> to
get an exact idea of how long all the lines were by counting the number of
pixels removed by a single iteration of this operator. </P>

However you can modify how '<CODE><A HREF="index.html#thinning" >Thinning</A></CODE>'
works, so that it removes only the set of pixels a single '<CODE><A
HREF="index.html#hitmiss" >Hit-And-Miss</A></CODE>' iteration through all the kernel
would find.  In other words apply all the kernels to the same image at the
start of the interation, merge them, then remove just those pixels, once only
for all kernels.  That is remove all the HMT selected pixels
<I>simultaniously</I>.  </P>

Basically you set the <A HREF="index.html#kernel_compose" >Multi-Kernel Composition
Setting</A> to use a '<CODE><A HREF="../compose/index.html#darken" >Darken</A></CODE>'
compose method, which will do exactly that. Specifically merging all the
selected pixels for a single removal of selected pixels.  For example... </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert line.gif -channel GB  -define morphology:compose=darken \
          -morphology Thinning LineEnds  line_simultaneous.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="line_simultaneous_mag.gif"
     ><IMG SRC="line_simultaneous_mag.gif"           WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>
<!--
  convert line_simultaneous.gif -scale 800% line_simultaneous_mag.gif
-->


What happened here is that each kernel of the <A HREF="index.html#pattern_kernels"
>Pattern Matching Kernels</A> will applied only to the original image.  Any
pixels that matched the original, will then be collected together.  That is we
will only remove a 'intersection' of the results of all kernels against the
original, by using a 'darken' composition. But the removal is done all in one
step for any one iteration through all the kernels. </P>

The result is that a line end will only ever get matched one time, even if
multiple kernels could match that line end. And thus only the single pixel on
the end will be removed, rather than 2 or more pixels, by different kernels.
</P>

In summary, adding a '<CODE><A HREF="../compose/index.html#darken" >Darken</A></CODE>'
<A HREF="index.html#kernel_compose" >Multi-Kernel Composition Setting</A>, will ensure
the '<CODE><A HREF="index.html#thinning" >Thinning</A></CODE>' method does
'<I>Simultaneous Thinning</I>' (all kernels simultaneously), rather than
'<I>Sequential Thinning</I>' (one kernel at a time - the default). </P>

<BR>

However, while this will make the pruning of line ends more well-behaved, it
will make it slower, and can change the overall result of a thinning. </P>

Take the case of '<CODE><A HREF="index.html#thinning" >Thinning</A></CODE>' some boxes
by thinning both the left and right edges simultaneously. </P>

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 10x10 xc:black -fill white -draw 'rectangle 4,1 5,7' rect.gif
  convert rect.gif -channel GB  -define morphology:compose=darken \
          -morphology Thinning Edges  rect_simultaneous.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="rect_mag.gif"
     ><IMG SRC="rect_mag.gif"               WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="rect_simultaneous_mag.gif"
     ><IMG SRC="rect_simultaneous_mag.gif"           WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>
<!--
  convert rect.gif -scale 800% rect_mag.gif
  convert rect_simultaneous.gif -scale 800% rect_simultaneous_mag.gif
-->

The 'Simultaneous Thinning' actually deleted the center rectangle completely!
What is happening is that the shape was thinned down to a two pixel thickness,
and then both sides of the 'thick' center-rect matched the pattern and both
sides were 'thinned'.  The same thing will happen if you do this when <A
HREF="index.html#thinning_skeleton" >Thinning down Skeletons</A>. </P>

The default 'Sequential Thinning' on the other hand produced... </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert rect.gif -channel GB \
          -morphology Thinning Edges rect_seqential.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="rect_seqential_mag.gif"
     ><IMG SRC="rect_seqential_mag.gif"           WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>
<!--
  convert rect_seqential.gif -scale 800% rect_seqential_mag.gif
-->

As you can see it preserved one of the pixels (on the right) to be a skeleton
center line. That is because one set of kernels first thinned down one side of
a 'thick' center-line, but the later kernels did not match this 'thinner'
line, so it was not removed.  </P>

Essentially there are situations where '<I>Sequential Thinning</I>' (the
default), is better than the special '<I>Simultaneous Thinning</I>', and
visa-versa.  </P>

<BR>

<A NAME="pattern_kernels"></A>
<H3>Pattern Matching Kernels</H3>

As mentioned a 'Pattern Matching' or '<CODE><A HREF="index.html#hitmiss"
>Hit-And-Miss</A></CODE>' kernel can contain 3 different types of elements,
foreground, background, and 'don't care'. </P>

A value of '<CODE>1.0</CODE>' or (white) matches foreground pixels.  A value
of '<CODE>0.0</CODE>' or (black) matches background pixels.  You can use
either a value of '<CODE>0.5</CODE>' or the special value of
'<CODE>Nan</CODE>' or '<CODE>-</CODE>' to represent pixel elements that are
not part of the neighbourhood and thus you 'don't care' about. </P>

The '<CODE><A HREF="index.html#hitmiss" >Hit-And-Miss</A></CODE>' will only match
places where the smallest (minimum) foreground pixel is larger than the
largest (maximum) background pixel.  It will then return the difference
between these two values, or zero. </P>

<!--<CODE EXECUTE>
   kernel2image -10.1 -m "Peaks"         kernel_peaks.gif
</CODE>-->
  <A HREF="kernel_peaks.gif"
      ><IMG SRC="kernel_peaks.gif"
            ALIGN=right BORDER=0 ALT="[IM Output]"></A>

<A NAME="peaks"></A>
<H4>Peaks</H4>

The '<CODE>Peaks</CODE>' kernel is an extension of the '<CODE><A HREF="index.html#ring"
>Ring</A></CODE>' kernel shown previously.  Two radii arguments will generate
a 'ring' of background pixels, surrounding a single foreground pixel in the at
the central 'origin'.  </P>

Here are some examples of some of the more useful '<CODE>Peak</CODE>' kernels...

<!--<CODE EXECUTE>
   kernel2image -20.1 -m "Peaks:1"         kernel_peaks_01.gif
   kernel2image -20.1 -m "Peaks:1.9"       kernel_peaks_02.gif
   kernel2image -15.1 -m "Peaks:2"         kernel_peaks_03.gif
   kernel2image -15.1 -m "Peaks:2.5"       kernel_peaks_04.gif
   kernel2image -15.1 -m "Peaks:2.9"       kernel_peaks_05.gif
   kernel2image  -8.1 -m "Peaks:4.3,5.3"   kernel_peaks_06.gif
</CODE>-->

<DIV ALIGN=center>
  <A HREF="kernel_peaks_01.gif"
      ><IMG SRC="kernel_peaks_01.gif"
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
  <A HREF="kernel_peaks_02.gif"
      ><IMG SRC="kernel_peaks_02.gif"
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
  <A HREF="kernel_peaks_03.gif"
      ><IMG SRC="kernel_peaks_03.gif"
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
  <A HREF="kernel_peaks_04.gif"
      ><IMG SRC="kernel_peaks_04.gif"
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
  <A HREF="kernel_peaks_05.gif"
      ><IMG SRC="kernel_peaks_05.gif"
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
  <A HREF="kernel_peaks_06.gif"
      ><IMG SRC="kernel_peaks_06.gif"
            ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

The above kernels can be used to either definitively locate a single pixel
'peak' value in a sea of darker pixels, or find any small shape that
completely fits inside the larger ring. </P>

They are especially useful to improve the contrast of a <A
HREF="../convolve/index.html#correlate_search" >Correlation Pattern Match Search</A>.
</P>

<A NAME="edges"></A>
<H4>Edges</H4>
<BR CLEAR=ALL>

The '<CODE>Edges</CODE>' kernel set, will match any pixel on a flat edge of
a shape.  It does not match pixels on a sharp ninety degree corner, though it
will match a corner pixel on an octagonal shape. </P>

<DIV ALIGN=center>
<!--<CODE EXECUTE>
   kernel2image -20.1 -ml '' -mt x1 "Edges"  miff:- | \
     convert -background LightSteelBlue  - label:Edges \
             -gravity center -append    kernel_edges.gif
</CODE>-->
  <A HREF="kernel_edges.gif"
      ><IMG SRC="kernel_edges.gif"
            ALIGN=middle BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

As you can see all the 90 degree rotations are generated, but they are ordered
in a 'flip-flop' mirror ordering that generally produces better results. </P>

Typically this kernel is used as a type of image '<CODE><A HREF="index.html#thinning"
>Thinning</A></CODE>' kernel, however as it stands it will fail to thin
diagonal edges, or generate a proper skeleton of an image. </P>

For example...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert man.gif -channel RG \
          -morphology Thinning:-1 Edges   thin_edges.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="man.gif"
     ><IMG SRC="man.gif"               WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="thin_edges.gif"
     ><IMG SRC="thin_edges.gif"      WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

See the '<CODE><A HREF="index.html#skeleton" >Skeleton</A></CODE>' kernels below. </P>


<A NAME="corners"></A>
<H4>Corners</H4>

The '<CODE>Corner</CODE>' kernels locate any diagonal corner pixel around the
edges of an image.  See '<CODE><A HREF="index.html#hitmiss" >Hit-And-Miss</A></CODE>'
above for an example of its use. </P>

<DIV ALIGN=center>
<!--<CODE EXECUTE>
   kernel2image -20.1 -ml '' -mt x1 "Corners"  miff:- | \
     convert -background LightSteelBlue  - label:Corners \
             -gravity center -append    kernel_corners.gif
</CODE>-->
  <A HREF="kernel_corners.gif"
      ><IMG SRC="kernel_corners.gif"
            ALIGN=middle BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

Here for example I used it to try and thin all diagonal edges...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert man.gif -channel RG \
          -morphology Thinning:-1 Corners  thin_corners.gif
</CODE></PRE></TD></TR></TABLE></P>

It can be combined with the '<CODE><A HREF="index.html#edges" >Edges</A></CODE>' kernel
to produce one method skeleton thinning.  See the '<CODE><A HREF="index.html#skeleton"
>Skeleton</A></CODE>' kernels below, for an example of this. </P>

</TD><TD>
  <A HREF="thin_corners.gif"
     ><IMG SRC="thin_corners.gif"      WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=0 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>


<A NAME="diagonals"></A>
<H4>Diagonals</H4>

The '<CODE>Diagonals</CODE>' kernel is an alternative to simply using
a '<CODE><A HREF="index.html#corners" >Corners</A></CODE>' kernel to thin 4-connected
diagonal lines down to a 8-connected diagonal lines. </P>

This can be used to thin 4-connected lines, by removing the outside set of
pixels from a corner toward the center until complete.  </P>

<DIV ALIGN=center>
<!-- <CODE EXECUTE>
   kernel2image -20.2 -ml '' -mt x1 "Diagonals"  miff:- | \
     convert -background LightSteelBlue  - label:Diagonals \
             -gravity center -append    kernel_diagonals.gif
</CODE> -->
  <A HREF="kernel_diagonals.gif"
      ><IMG SRC="kernel_diagonals.gif"
            ALIGN=middle BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

Note the results should be completed by using a '<CODE><A HREF="index.html#corners"
>Corners</A></CODE>' kernel, to locate and thin 90-degree corners.  See <A
HREF="index.html#thinner_skeleton" >Thinner Skeleton</A> for an example of usage. </P>

<A NAME="diagonals_subtypes"></A>
<B>Diagonals Sub-Types</B></P>

By providing a '<I>type</I>[,<I>angle</I>]' argument to the kernel you can
select specific sub-types that was used to make up the above kernel set.

<DIV ALIGN=center>
<!--<CODE EXECUTE>
   kernel2image -25.2 -m "Diagonals:1"  kernel_diagonals1.gif
   kernel2image -25.2 -m "Diagonals:2"  kernel_diagonals2.gif
</CODE>-->
  <A HREF="kernel_diagonals1.gif"
      ><IMG SRC="kernel_diagonals1.gif"
            ALIGN=middle HSPACE=25 BORDER=0 ALT="[IM Output]"></A>
  <A HREF="kernel_diagonals2.gif"
      ><IMG SRC="kernel_diagonals2.gif"
            ALIGN=middle HSPACE=25 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

This will let you specify your own specific set of kernels, to thin diagonals
in exactly the way you want them thinned. </P>

For example, you could separately thin each of the four types of diagonals
(using both the above kernels with the same <I>angle</I> value).  By doing
this you can do an iterative reducing of each type of diagonal one at a time,
aborting as soon as all those specific diagonals has been thinned, and thus
reducing the overall number of '<I>primitive morphology steps</I>' that are
performed. </P>

<I>example needed</I></P>

As it is given, the default kernel set will simply try to thin all the
diagonals simultaneously and repeatedly until they have all been thinned.
That means the all the kernel will be applied until all the diagonals have
been thinned, rather than just the diagonals that need thinning.  That means
it perform many '<I>primitive morphology steps</I>' that are no longer needed,
with most kernels making no changes to the image during each loop.  </P>

<I>full example needed</I></P>

Remember each of the four diagonals should still be performed using both pairs
of kernels (for each specific angle) so that both ends of each specific
diagonal are thinned together, such as when the diagonal is part of an 'arc'.
</P>

There is a related discussion about this type of thinning/thickening operation
in the IM forum, <A HREF="http://legacy.imagemagick.org/Usage/forum_link.cgi?f=1&amp;t=21253" >From 8-connected to
4-connected lines</A>. </P>


<A NAME="lineends"></A>
<H4>LineEnds</H4>

The '<CODE>LineEnds</CODE>' kernel set, as shown in <A HREF="index.html#thin_pruning"
>Pruning Ends of Lines</A> above, is designed to locate the end of lines.
More specifically it find the ends of sharp points. </P>

<DIV ALIGN=center>
<!--<CODE EXECUTE>
   kernel2image -20.2 -ml '' -mt x1 "LineEnds"  miff:- | \
     convert -background LightSteelBlue  - label:LineJunctions \
             -gravity center -append    kernel_lineends.gif
</CODE>-->
  <A HREF="kernel_lineends.gif"
      ><IMG SRC="kernel_lineends.gif"
            ALIGN=middle BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

As you can see, it will only match lines that have at least two pixels, with
the matching pixel 'capped' or 'surrounded' by background pixels. </P>

For example, here we use '<CODE><A HREF="index.html#hitmiss" >Hit-And-Miss</A></CODE>'
to find all the line ends.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert lines.gif -morphology HMT LineEnds  hmt_lineends.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="lines.gif"
     ><IMG SRC="lines.gif"               WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="hmt_lineends.gif"
     ><IMG SRC="hmt_lineends.gif"      WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="hmt_lineends_rings.gif"
     ><IMG SRC="hmt_lineends_rings.gif"      WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

Yes there is a lot of line ends in this image. But you should note that
lines which end in a 'loop' of some kind will not produce a match. </P>

Note that if you are '<CODE><A HREF="index.html#thinning" >Thinning</A></CODE>' an image
using this kernel using an 'iterative thinning' style (the default),
successive kernels could match the same end of a line two or more times, thus
shrinking the line many times during a single iteration of the whole '<CODE><A
HREF="index.html#thinning" >Thinning</A></CODE>' method.  See <A HREF="index.html#thinning_style"
>Thinning - Sequence vs Simultaneous</A> for more details.  </P>

<A NAME="lineends_subtypes"></A>
<B>Line End Sub-Types</B></P>

You can also this kernel give a '<I>type</I>[,<I>angle</I>]' arguments, which
will return one of the single kernel definitions that was used to generate the
above '<CODE><A HREF="index.html#lineends" >LineEnds</A></CODE>' kernel set. </P>

<DIV ALIGN=center>
<!--<CODE EXECUTE>
   kernel2image -20.2 -m "LineEnds:1"  kernel_lineends1.gif
   kernel2image -20.2 -m "LineEnds:2"  kernel_lineends2.gif
   kernel2image -20.2 -m "LineEnds:3"  kernel_lineends3.gif
   kernel2image -20.2 -m "LineEnds:4"  kernel_lineends4.gif
</CODE>-->
  <A HREF="kernel_lineends1.gif"
      ><IMG SRC="kernel_lineends1.gif"
            ALIGN=middle HSPACE=25 BORDER=0 ALT="[IM Output]"></A>
  <A HREF="kernel_lineends2.gif"
      ><IMG SRC="kernel_lineends2.gif"
            ALIGN=middle HSPACE=25 BORDER=0 ALT="[IM Output]"></A>
  <A HREF="kernel_lineends3.gif"
      ><IMG SRC="kernel_lineends3.gif"
            ALIGN=middle HSPACE=25 BORDER=0 ALT="[IM Output]"></A>
  <A HREF="kernel_lineends4.gif"
      ><IMG SRC="kernel_lineends4.gif"
            ALIGN=middle HSPACE=25 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

These can then be <A HREF="index.html#kernel_rotations" >Expanded into a Rotated Kernel
List</A> as you require, or rotated to a specific '<I>angle</I>', as needed.
The default '<CODE><A HREF="index.html#lineends" >LineEnds</A></CODE>' set, actually
uses the kernel definition.

<DIV ALIGN=center>
  '<CODE>LineEnds:1&gt; ; LineEnds:2&gt;</CODE>'
</DIV></P>

The '<CODE>LineEnds:3</CODE>' is the orthogonal equivalent to the diagonal
'<CODE>LineEnds:2</CODE>', which will only find the line ends well away from
any diagonal corner or junction. </P>

The '<CODE>LineEnds:4</CODE>' is a traditional line end kernel, which is
rotated in cyclic fashion to produce 8 kernels (for example
'<CODE>LineEnds:4@</CODE>).  However it will fail to locate the last pixel of
a line connecting to an orthogonal 'T' junction.  The default '<CODE><A
HREF="index.html#lineends" >LineEnds</A></CODE>' set, as defined above, does however
find that final pixel at 'T' junctions, using the same number of kernels. </P>


<A NAME="linejunctions"></A>
<H4>LineJunctions</H4>

Where '<CODE><A HREF="index.html#lineends" >LineEnds</A></CODE>' find the ends of
a group of lines, '<CODE>LineJunctions</CODE>' will find points that form
a junction of 3 or more lines.

<DIV ALIGN=center>
<!--<CODE EXECUTE SCRIPT IMAGE=kernel_linejunctions.gif>
   ( kernel2image -15.1 -ml '' -mt x1 "LineJunctions:1@"  miff:-
     kernel2image -15.1 -ml '' -mt x1 "LineJunctions:2>"  miff:-
   ) |
   convert -background LightSteelBlue  - label:LineJunctions \
           -gravity center -append    kernel_linejunctions.gif
</CODE>-->
  <A HREF="kernel_linejunctions.gif"
      ><IMG SRC="kernel_linejunctions.gif"
            ALIGN=middle BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

For example, here we use '<CODE><A HREF="index.html#hitmiss" >Hit-And-Miss</A></CODE>'
to find all the line junctions.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE DO_NOT_EXECUTE example done previously>
  convert lines.gif -morphology HMT LineJunctions hmt_junctions.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="lines.gif"
     ><IMG SRC="lines.gif"               WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="hmt_junctions.gif"
     ><IMG SRC="hmt_junctions.gif"      WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="hmt_junctions_rings.gif"
     ><IMG SRC="hmt_junctions_rings.gif"      WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

The '<CODE><A HREF="index.html#linejunctions" >LineJunctions</A></CODE>' kernel is
generally used for two purposes. <UL>

<LI>Count the number of line junctions in an image, and thus work toward
    a count of the number of line segments in the skeleton.
<LI>Disconnect all line segments from each other.
</UL> </P>

Note however that at the 'T' and '+' junctions in the above image, the 'Y'
junction kernel matches points that is one pixel one pixel away from the
actual intersection. Because of this junction counts may not be exactly as
expected, especially at the '+' where four matches were found rather than just
the required two for a junction count.  Caution is recommented. </P>

See <A HREF="index.html#skeleton_info" >Skeleton Information</A>, and <A
HREF="index.html#thinning_prune_fast" >Fast Line Pruning</A> for more details of these
two aspects. </P>

The kernel actually only defines foreground pixels as such it can be applied
simply as a '<CODE><A HREF="index.html#erode" >Erode</A></CODE>' method, instead of as
a '<CODE><A HREF="index.html#hitmiss" >Hit-and-Miss</A></CODE>' method. </P>


<A NAME="linejunctions_subtypes"></A>
<B>Line Junction Sub-Types</B></P>

This kernel also provides access to the various sub-types, by specifying
'<I>type</I>[,<I>angle</I>]' arguments. This can be used to search for
specific types of line junctions.

<DIV ALIGN=center>
<!--<CODE EXECUTE>
   kernel2image -25.2 -m "LineJunctions:1"  kernel_linejunctions1.gif
   kernel2image -25.2 -m "LineJunctions:2"  kernel_linejunctions2.gif
   kernel2image -25.2 -m "LineJunctions:3"  kernel_linejunctions3.gif
   kernel2image -25.2 -m "LineJunctions:4"  kernel_linejunctions4.gif
   kernel2image -25.2 -m "LineJunctions:5"  kernel_linejunctions5.gif
</CODE>-->
  <A HREF="kernel_linejunctions1.gif"
      ><IMG SRC="kernel_linejunctions1.gif"
            ALIGN=middle BORDER=0 ALT="[IM Output]"></A>
  <A HREF="kernel_linejunctions2.gif"
      ><IMG SRC="kernel_linejunctions2.gif"
            ALIGN=middle BORDER=0 ALT="[IM Output]"></A>
  <A HREF="kernel_linejunctions3.gif"
      ><IMG SRC="kernel_linejunctions3.gif"
            ALIGN=middle BORDER=0 ALT="[IM Output]"></A>
  <A HREF="kernel_linejunctions4.gif"
      ><IMG SRC="kernel_linejunctions4.gif"
            ALIGN=middle BORDER=0 ALT="[IM Output]"></A>
  <A HREF="kernel_linejunctions5.gif"
      ><IMG SRC="kernel_linejunctions5.gif"
            ALIGN=middle BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

The kernels  '<CODE>LineJunctions:2</CODE>' can also be specified using
'<CODE>LineJunctions:3,45</CODE>', and similarly
'<CODE>LineJunctions:5</CODE>' and '<CODE>LineJunctions:4,45</CODE>' are
equivilent. </P>

The default '<CODE><A HREF="index.html#linejunctions" >LineJunctions</A></CODE>' kernel
set only uses the first two junction definitions (the '<CODE>Y</CODE>' and
diagonal '<CODE>T</CODE>' junctions), in the following way...

<DIV ALIGN=center>
  '<CODE>LineJunctions:1@ ; LineJunctions:2&gt;</CODE>'
</DIV></P>

This is appropriate for a 8-connected line junctions. </P>

As discussed in IM Forums "<A HREF="http://legacy.imagemagick.org/Usage/forum_link.cgi?f=1&amp;t=22776" >Kernels
used by LineJunctions</A>" if you want to test for 4-connected line junctions
only, you would need to look for orthogonal 'T' junctions, and a '+'
junctions.

<DIV ALIGN=center>
  '<CODE>LineJunctions:3&gt; ; LineJunctions:5</CODE>'
</DIV></P>

However as the 'T' kernels will also hit a '+', you can cut the above down
to just...

<DIV ALIGN=center>
  '<CODE>LineJunctions:3&gt;</CODE>'
</DIV></P>

A separate image test for just 4-way '+' junction can be used to separate them
from 3 way 'T' junctions, if that is needed for determining line segment
counts.  </P>


<A NAME="ridges"></A>
<H4>Ridges</H4>

The '<CODE>Ridges</CODE>' kernels are used to locate ridges and thin lines of
pixels, such as in a <A HREF="index.html#distance" >Distance Gradient</A> image. </P>

<I>These Kernels are experimental and may change.</I> </P>

The default is designed to locate a single pixel thick ridge lines. </P>

<DIV ALIGN=center>
<!--<CODE EXECUTE>
  kernel2image -20.2 -ml '' -mt x1 "Ridges"  miff:- | \
    convert -background LightSteelBlue  - label:Ridges \
            -gravity center -append    kernel_ridges.gif
</CODE>-->
  <A HREF="kernel_ridges.gif"
      ><IMG SRC="kernel_ridges.gif"
            ALIGN=middle BORDER=0 ALT="[IM Output]"></A>
</DIV></P>


<A NAME="ridges2"></A>
<B>Ridges:2</B></P>

A special expanded subtype that is designed to find two pixel thick ridge
lines. The complexity is caused by the need to locate and mark a slanted line
of this sort, including mirrors of those lines. </P>

<DIV ALIGN=center>
<!--<CODE EXECUTE>
   kernel2image -15.1 -ml '' -mt x3 "Ridges:2"  miff:- | \
      montage -label Ridges:2 -  -background LightSteelBlue \
              -geometry +0+0  kernel_ridges2.gif
</CODE>-->
  <A HREF="kernel_ridges2.gif"
      ><IMG SRC="kernel_ridges2.gif"
            ALIGN=middle BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

This set of kernels is important as a 'Morphological Skeleton' actually
consists both 1 and 2 pixel thick lines. </P>


<A NAME="convexhull"></A>
<H4>ConvexHull</H4>

The '<CODE>ConvexHull</CODE>' kernel set, is designed to thicken shapes
so as to produce a 'Octagonal Convex Hull' of the shape. That is the smallest
octagonal shape that can contain the whole of the shape. </P>

<DIV ALIGN=center>
<!--<CODE EXECUTE>
   kernel2image -15.1 -ml '' -mt x2 "ConvexHull"  miff:- | \
      montage -label ConvexHull -  -background LightSteelBlue \
              -geometry +0+0  kernel_convexhull.gif
</CODE>-->
  <A HREF="kernel_convexhull.gif"
      ><IMG SRC="kernel_convexhull.gif"
            ALIGN=middle BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

There are two sets of 90 degree rotated kernels, one the mirror image of the
other.  As the origin is actually a 'background' element, it is really only
meant to be used as a '<CODE><A HREF="index.html#thicken" >Thicken</A></CODE>' pattern
kernel. </P>

However the kernel will fail for images containing horizontal or vertical
'slots', such as we have in the 'man' shape.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert man.gif -channel R \
          -morphology Thicken:-1 ConvexHull  man_hull.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="man.gif"
     ><IMG SRC="man.gif"              WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="man_hull.gif"
     ><IMG SRC="man_hull.gif"      WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>

The solution is to '<CODE><A HREF="index.html#close" >Close</A></CODE>' these slots (and
the central hole) before using  '<CODE><A HREF="index.html#convexhull"
>ConvexHull</A></CODE>'.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE DO_NOT_EXECUTE this was done above>
  convert man.gif -morphology Close Diamond \
                  -morphology Thicken:-1 ConvexHull \
                  -morphology Close Diamond       man_hull_full.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="man_hull_full.gif"
     ><IMG SRC="man_hull_full.gif"      WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Note in the above I also repeated the '<CODE><A HREF="index.html#close"
>Close</A></CODE>' after using '<CODE><A HREF="index.html#convexhull"
>ConvexHull</A></CODE>'.  The reason is that any large 'holes' in an image
will also be reduced by the '<CODE><A HREF="index.html#thicken" >Thicken</A></CODE>'
down down to single pixels, or orthogonal 'slots'.  Repeating the '<CODE><A
HREF="index.html#close" >Close</A></CODE>' removes those holes without effecting the
final shape. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

Here is another example, where the original shape (white) was expanded using
a convex hull thickening (red).

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert circles.gif -channel R \
          -morphology Thicken:-1 ConvexHull  circles_hull.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="circles_hull.gif"
     ><IMG SRC="circles_hull.gif"      WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

As you can see the result is an octagonal shape, while the central hole was
reduced down to a two pixel slot, ready to be closed. </P>


<A NAME="skeleton"></A>
<H4>Skeleton</H4>

Generating 'skeletons' by thinning of a particular shape is not an easy
matter.  Even with the same kernel set, re-ordering the kernels can generate
a different variation on the final 'skeleton'. </P>

Because of this I have not implemented just one '<CODE>Skeleton</CODE>' kernel
set, but a number of them, which can be selected by giving a '<I>type</I>'
argument number.  </P>

<A NAME="skeleton1"></A>
<H4>Skeleton:1</H4>

The first and default set, '<CODE><B>Skeleton:1</B></CODE>', is
a traditional thinning kernel, as what was first used.  This is basically
exactly like the '<CODE><A HREF="index.html#edges" >Edges</A></CODE>' kernel above, but
cyclically rotated in 45 degree increments. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=center>
<!--<CODE EXECUTE>
   kernel2image -15.1 -ml '' -mt x1 "Skeleton:1"  miff:- | \
      montage -label "Skeleton:1 (Traditional)" - \
          -background LightSteelBlue -geometry +0+0  kernel_skeleton1.gif
</CODE>-->
  <A HREF="kernel_skeleton1.gif"
      ><IMG SRC="kernel_skeleton1.gif"
            ALIGN=middle BORDER=0 ALT="[IM Output]"></A>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert man.gif -channel RG \
          -morphology Thinning:-1 Skeleton   thin_skeleton1.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="thin_skeleton1.gif"
     ><IMG SRC="thin_skeleton1.gif"      WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=2 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>


The result is a reasonable 'thinned skeleton' of a shape, though diagonals
tend to remain a little thick on one side. basically the skeletion produced
is 4-connected, which will allow you to use a <A HREF="http://legacy.imagemagick.org/Usage/morphology/thinning_prune_fast"
>Fast Pruning</A> technique. </P>

Also note that this kernel set does not correctly expand single pixel hole in
the image.  In other words the skeleton around that hole is not even close to
the center line between the hole and the rest of the image. </P> </P>

For more details see <A HREF="index.html#thinning_skeleton" >Thinning Down to
a Skeleton</A>. </P>

<A NAME="skeleton2"></A>
<H4>Skeleton:2</H4>

The '<CODE><B>Skeleton:2</B></CODE>' variant is almost exactly the same as the
traditional '<CODE>Skeleton:1</CODE>' version.  It was found in the <A
HREF="http://homepages.inf.ed.ac.uk/rbf/HIPR2/thin.htm" >HIPR2 Image
Processing Resources</A> documentation. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=center>
<!--<CODE EXECUTE>
   kernel2image -15.1 -ml '' -mt x1 "Skeleton:2"  miff:- | \
      montage -label "Skeleton:2 (HIPR2)" - \
          -background LightSteelBlue -geometry +0+0  kernel_skeleton2.gif
</CODE>-->
  <A HREF="kernel_skeleton2.gif"
      ><IMG SRC="kernel_skeleton2.gif"
            ALIGN=middle BORDER=0 ALT="[IM Output]"></A>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert man.gif -channel RG \
          -morphology Thinning:-1 Skeleton:2   thin_skeleton2.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="thin_skeleton2.gif"
     ><IMG SRC="thin_skeleton2.gif"      WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=0 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

If you compare this with the previous set, you will notice that the internal
pixel of the corners have been removed.  This will then allow the thinning
operation to remove the extra thickening from the diagonals. However this
diagonal thinning is not symmetrical, and highly dependant of the shape of the
image, and the order in which the kernels are applied. </P>

<A NAME="edge-corner"></A>

The '<CODE>Skeleton:2</CODE>' variant is very closely related to just using
a combined '<CODE><B>Edges;Corners</B></CODE>' kernel list.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=center>

<!--<CODE EXECUTE>
   kernel2image -15.1 -ml '' -mt x1 "Edges;Corners"  miff:- | \
      montage -label 'Edges ; Corners' - \
              -background LightSteelBlue -geometry +0+0  kernel_edge-corner.gif
</CODE>-->
  <A HREF="kernel_edge-corner.gif"
      ><IMG SRC="kernel_edge-corner.gif"
            ALIGN=middle VSPACE=5 BORDER=0 ALT="[IM Output]"></A>

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert man.gif -channel RG \
          -morphology Thinning:-1 'Edges;Corners' thin_edge-corner.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="thin_edge-corner.gif"
     ><IMG SRC="thin_edge-corner.gif"      WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=0 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

The only difference between this and what '<CODE>Skeleton:2</CODE>' uses is
the ordering of the kernels in the list. </P>

Note how the resulting skeleton also differs, even though the same set of
kernels was used.  This shows that generating skeletons by thinning is
actually rather fragile, as just a simple change of order can produce
different results in the connected skeleton. </P>


<A NAME="skeleton3"></A>
<H4>Skeleton:3</H4>

The '<CODE><B>Skeleton:3</B></CODE>' was developed in a formal study of using
Thinning Kernels (See <A HREF="http://legacy.imagemagick.org/Usage/morphology/thinse" >ThinSE Kernels</A> below), in
a research paper "<A HREF="http://www.leptonica.com/papers/conn.pdf"
>Connectivity-Preserving Morphological Image Transformations</A>" by Dan S.
Bloomberg, 1991. </P>

He developed quite a number of such skeletons, and tabled the results of the
study. The following is the best one he was able to come up with, that will
generate a 4 connected skeleton.
However unlike previous skeletons this requires the use of
3 rotated kernels (12 total).

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=center>

<!--<CODE EXECUTE>
   kernel2image -15.1 -ml '' -mt x1 "Skeleton:3"  miff:- | \
      montage -label "Skeleton:3 (Bloomberg)" - \
          -background LightSteelBlue -geometry +0+0  kernel_skeleton3.gif
</CODE>-->
  <A HREF="kernel_skeleton3.gif"
      ><IMG SRC="kernel_skeleton3.gif"
            ALIGN=middle BORDER=0 ALT="[IM Output]"></A>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert man.gif -channel RG \
          -morphology Thinning:-1 Skeleton:3   thin_skeleton3.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="thin_skeleton3.gif"
     ><IMG SRC="thin_skeleton3.gif"      WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=0 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

It should be noted that the first group of rotated kernels contains just
a single background pixel.  That means this skeleton was able to open up the
single pixel hole that is present in the 'man' shape, and produce a  center
line oriented skeleton.  It does not generate too may branches, produces clean
smooth lines, and also thins down completely.  </P>

All in all this is one of the better skeleton thinning kernels. </P>


<A NAME="thinse"></A>
<H4>ThinSE</H4>

The same research paper "<A HREF="http://www.leptonica.com/papers/conn.pdf"
>Connectivity-Preserving Morphological Image Thansformations</A>" by Dan S.
Bloomberg, actually developed from first principles a complete range of
minimal 3x3 'Thinning Structure Elements' that were all designed to preserve
either 4-connected line or 8-connected lines. </P>

The '<CODE><B>ThinSE:</B>{<I>type</I>}</CODE>' kernel set is a list of all
those structuring elements, and are listed below sorted into groups based on
connectivity and strength in preservation. </P>

The '<CODE>{<I>type</I>}</CODE>' is a number based on the super-script
(connected-ness) and sub-script element numbers used in the research paper.
As such kernel '<CODE><B>ThinSE:41</B></CODE>' is the first of the 4-connected
line preserving elements.  You can also add a rotation angle, or generate
a set of rotated or mirror-rotated flags to the given kernel definition.

<!--<CODE EXECUTE SCRIPT>
  flags="-tile x1 -background LightSteelBlue -geometry +0+0"
  for i in `seq 41 44`; do
      kernel2image -15.1 -m -ml $i  "ThinSE:$i" miff:-
  done | montage - $flags miff:- |
    montage -label "Strong 4-connected" - \
      -font ArialB $flags kernel_thinse_4strong.gif

  for i in `seq 45 49`; do
      kernel2image -15.1 -m -ml $i "ThinSE:$i" miff:-
  done | montage - $flags miff:- |
    montage -label "Weak 4-connected" - \
      -font ArialB $flags kernel_thinse_4weak.gif

  for i in `seq 81 84`; do
      kernel2image -15.1 -m -ml $i "ThinSE:$i" miff:-
  done | montage - $flags miff:- |
    montage -label "Strong 8-connected" - \
      -font ArialB $flags kernel_thinse_8strong.gif

  for i in `seq 85 89`; do
      kernel2image -15.1 -m -ml $i "ThinSE:$i" miff:-
  done | montage - $flags miff:- |
    montage -label "Weak 8-connected" - \
      -font ArialB $flags kernel_thinse_8weak.gif

  for i in 423 823; do
      kernel2image -15.1 -m -ml $i "ThinSE:$i" miff:-
  done | montage - $flags -geometry +15+0 miff:- |
    montage -label "Weak, Combined 2 and 3" - \
      -font ArialB $flags -geometry +25+0 kernel_thinse_23comb.gif

  for i in 481 482; do
      kernel2image -15.1 -m -ml $i "ThinSE:$i" miff:-
  done | montage - $flags -geometry +15+0 miff:- |
    montage -label "General 4 & 8 Conection Preserving" - \
      -font ArialB $flags -geometry +25+0 kernel_thinse_48gen.gif
-->
<DIV ALIGN=center>
  <A HREF="kernel_thinse_4strong.gif"
     ><IMG SRC="kernel_thinse_4strong.gif"
           ALIGN=middle VSPACE=2 HSPACE=20 BORDER=0 ALT="[IM Output]"></A>
  <A HREF="kernel_thinse_4weak.gif"
     ><IMG SRC="kernel_thinse_4weak.gif"
           ALIGN=middle VSPACE=2 HSPACE=20 BORDER=0 ALT="[IM Output]"></A>
<BR>
  <A HREF="kernel_thinse_8strong.gif"
     ><IMG SRC="kernel_thinse_8strong.gif"
           ALIGN=middle VSPACE=2 HSPACE=20 BORDER=0 ALT="[IM Output]"></A>
  <A HREF="kernel_thinse_8weak.gif"
     ><IMG SRC="kernel_thinse_8weak.gif"
           ALIGN=middle VSPACE=2 HSPACE=20 BORDER=0 ALT="[IM Output]"></A>
<BR>
  <A HREF="kernel_thinse_23comb.gif"
     ><IMG SRC="kernel_thinse_23comb.gif"
           ALIGN=middle VSPACE=2 HSPACE=20 BORDER=0 ALT="[IM Output]"></A>
  <A HREF="kernel_thinse_48gen.gif"
     ><IMG SRC="kernel_thinse_48gen.gif"
           ALIGN=middle VSPACE=2 HSPACE=20 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>


The very last '<I>General Thinning Kernel</I>,
'<CODE><B>ThinSE:482</B></CODE>', you may recognise as the being same kernel
used to define the set of <A HREF="index.html#edge" >Edge Detection Kernel</A>.  This
general kernel is actual the core kernel from which all the other thinning
kernels shown above were developed. It is the default kernel of the set.  </P>

Note that both general kernels '<CODE>ThinSE:481</CODE>' and
'<CODE>ThinSE:482</CODE>' are the only kernels rotationaly related. That is
'<CODE>ThinSE:481x45</CODE>' is equivalent to '<CODE>ThinSE:482</CODE>'. </P>

Many of the other built-in HMT kernel sets are actually internally defined in
terms of these kernels. For example, the kernel set '<CODE><B>ThinSE:41
; ThinSE:42 ; ThinSE:43</B></CODE>', and its rotated expansion, will produce
the 12 kernels used to create the '<CODE><A HREF="index.html#skeleton3"
>Skeleton:3</A></CODE>' set. This skeleton and was listed in the paper as
being the best kernel set found to produce good thinned skeleton.  The other
skeleton generating thinning kernels are also defined using the above kernels.
</P>

<BR>

Be warned however that some kernels, such as '<CODE>ThinSE:44</CODE>', which
while designed to preserve 'connected-ness', does not actually preserve line
ends, and as such will cause a skeleton to be pruned down to a single point,
or set of connected rings. </P>

All the kernels do not define the central origin value, which means you can
these 'thinning kernels' are not only for '<A HREF="index.html#thinning" >Thinning
Shapes</A>', but also can be used '<A HREF="index.html#thicken" >Thicken Shapes</A>' as
well, to generate SKIZ (zones of influence). </P>

If you look carefully, you will probably note that each of the 4-connected
kernels are actually also present in a negative and  180 rotated form in the
8-connected set, and visa-versa.  For example '<CODE>ThinSE:41</CODE>' and
'<CODE>ThinSE:84</CODE>' are negated rotations of each other. </P>

The reason is that 4 and 8 connectivity is closely related to each other via
the duality of thinning and thicken morphological methods (using negated
images).   Essentually, a 4-connection preserving 'thinning kernel', which is
then used to thicken an image, will result in a 8-connected background
skeleton (unpruned SKIZ) around the shape, and visa-versa.  So by using the
negated forms (so thicken and thin methods are swapped) you can generate the
other form of connected-ness for the same operation. </P>

<BR>

<HR><!-- ---------------------------------------------------------------- -->

<A NAME="distance"></A>
<H2>Distance Gradient Morphology</H2>

The '<CODE>Distance</CODE>' morphology method is the first of the many
specialized methods that is possible.  What it does is use a specialized kernel
to measure the distance of each foreground pixel from the shapes 'edge'.  More
specially it measures the pixels distance from a 'zero' or 'black' color
value. </P>

It however only works with pure binary (white on black) shapes, though as you
will see later you can modify an anti-aliased shape to work with the distance
method.  And only with specially designed <A HREF="index.html#distance_kernels"
>Distance Kernels</A>. </P>

The distance kernel is applied to the image so that each pixel is assigned the
smallest pixel value plus the kernel value for that distance.  This is applied
all over the image simultaneously, using an algorithm that does not require
multiple iterations, as we saw in previous morphology methods. </P>

Because of this it is about as fast as a single primitive morphological
operation, which is blindingly fast compared to say a <A
HREF="index.html#thinning_skeletion" >Thinning Skeleton</A> morpholgical method. </P>

As it is applied across the whole image, no '<I>iteration</I>' argument is
needed, as repeating (iterating) the same kernel operation will result in no
further change to the result. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/warning.gif"  WIDTH=28 HEIGHT=28
    ><IMG SRC="../img_www/space.gif"   WIDTH=12 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  Before IM v6.6.9-4, a '<CODE>-1</CODE>' iteration count was needed, as the
  kernel was applied using a technique similar to a normal <A HREF="index.html#erode"
  >Erode</A>.  This is no longer needed, and any 'iteration' argument given,
  other than zero (no action), is now simply ignored.
</I></FONT></TD></TR></TABLE></P>

Here is an example of using the '<CODE>Distance</CODE>' method, on our 'man'
shape.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert man.gif -threshold 50% \
          -morphology Distance Euclidean:4 \
          +depth  distance.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="man.gif"
     ><IMG SRC="man.gif"               WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="distance.png"
     ><IMG SRC="distance.png"      WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

Well that was real exciting, <FONT SIZE=+1>NOT</FONT>! </P>

The problem is that the final images color is very very dark.  But if you have
a good monitor, and can look closely, you may see a very dark 'ghost' like
shape where the 'man' was. </P>

What happened is that, at least for this small image, all the pixels are
'close' to the edge, and so do not get a very large 'distance' value. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  A PNG image is recommended for any use of the '<CODE>Distance</CODE>'
  method. That is because it provides can provide greater output value 'depth'
  than for example GIF, without any color loss like JPEG. </P>

  It is also the reason why the <A HREF="../basics/index.html#depth" >Depth Setting</A>
  "<CODE>+depth</CODE>" was used to ensure the output is reset to 16-bit depth
  (for my Q16 version of IM) even though I read in an 8-bit GIF source image.
  </P>

  For users with a Q8 version of IM, I suggest you read about the 'scale'
  distance kernel option in <A HREF="index.html#distance_kernels" >Distance Kernels</A>
  (below) to adjust the 'scaling values' used (see next section below). Using
  Q8 versions of IM with non-interger distance kernels (like this <A
  HREF="index.html#euclidean" >Euclidean Distance Kernel</A>) is not recommended, though
  will produce a less accuriate result. </P>

  See IM Examples section on <A HREF="../basics/index.html#depth" >Quality and
  Depth</A>, for a better understanding of these two aspects. </P>

</I></FONT></TD></TR></TABLE></P>

By default the built-in <A HREF="index.html#distance_kernels" >Distance Kernels</A> will
apply a color value of "100 &times; {<I>pixel_distance</I>}" to each pixel.
If a pixel is brighter that this, it is set to that value so that the smallest
distance from a pixel to any edge is assigned. </P>

The result is that pixels along the very edge of a shape will be assigned
a 100 unit value more than background color. The next pixel further in will be
given 100 units more.  Exactly how many units will be assigned is given by the
<A HREF="index.html#distance_kernels" >Distance Kernel</A> that is used. </P>

So lets look at the largest color value that was set in the above image.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE NOIMAGE OUT=distance_max.txt>
  identify -verbose distance.png | grep max:
</CODE></PRE></TD></TR></TABLE>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD>
  <A HREF="distance_max.txt"
     ><IMG SRC="distance_max.txt.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE>
</DIV></P>

That is the largest color value in the resulting image was '<CODE>1616</CODE>'
making the 'brightest' pixel in the image a very dark 2.5% grey, and its
distance from the nearest edge, 16.16 pixels away. </P>

In other words, we see a very dark, but not really completely black image.
</P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>

Lets use the mathematical "<CODE><A HREF="../../../html/www/command-line-options.html#auto-level"
>-auto-level</A></CODE>" to adjust the resulting color values so the
brightest, or most distant pixel from an edge is set to white.  This way we
can actually see the full effect of the 'distance gradient' generated.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert distance.png -auto-level  distance_man.gif
</CODE></PRE></TD></TR></TABLE>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  As we no longer care about the exact 'distance' values generated for this
  image, just the visible effect of the distance, the image can now be saved
  and displayed using the GIF image file format.
</I></FONT></TD></TR></TABLE></P>

</TD><TD>
  <A HREF="distance_man.gif"
     ><IMG SRC="distance_man.gif"      WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

This is what the '<CODE>Distance</CODE>' method does.  Generate a gradient
across the given shape defining how far each pixel is from the nearest edge,
according to the specific <A HREF="index.html#distance_kernels" >Distance Kernel</A>
used. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>

Another way of making the resulting 'distance' image brighter is to actually
use a larger distance kernel '<I>scale</I>' value, for example a value of
3000 units (Q8 users can probably use a value of 20).

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert man.gif -threshold 50% +depth \
          -morphology Distance Euclidean:4,3000     distance_scaled.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="distance_scaled.gif"
     ><IMG SRC="distance_scaled.gif"      WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=0 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

Note that the distance gradient did not cover from black to white, with it
reaching a peak at some grey-scale value.  As we already know the 'distance of
the peak, we can calculate that maximum peak to be  <CODE>16.16 * 3000 =>
48480</CODE> or about 74% grey. </P>

You can also use a percentage scaling factor, for example use a 8% color range
value for each pixel distance from the edge.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert man.gif -threshold 50% +depth \
          -morphology Distance Euclidean:4,8%    distance_scale_percent.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="distance_scale_percent.gif"
     ><IMG SRC="distance_scale_percent.gif"      WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=0 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

As you can see this time we reached our maximum value limit before reaching
the maximum distance.  You can calculate that maximum distance that the
distance gradient can cover is <CODE>(100% at maximum range) / (8% per pixel)
=&gt; 12.5 pixel_distance</CODE>. </P>

Of course if you were using a <A HREF="../basics/index.html#hdri" >HDRI version
of ImageMagick</A> the full distance values will be kept in memory, at least
until you <A HREF="../basics/index.html#clamp" >Clamp</A> it value, or save it into
a non-floating point image file format. </P>

You can also directly specify the maximum pixel distance you are
interested in by using the special <A HREF="index.html#distance_scaling_flags" >Distance
Scaling Flag</A>, '<CODE>!</CODE>'. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>

As we already know out shape as a maximum distance from edge of 16.16. least
request a limit of 18 pixel.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert man.gif -threshold 50% +depth \
          -morphology Distance Euclidean:4,'18!'   distance_range.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="distance_range.gif"
     ><IMG SRC="distance_range.gif"      WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE>

The '<CODE>!</CODE>' flag will scale the the distance so as to give 'n'
grey-scale values before the color range limit is reached.  As such a value of
1 will only 'feather' (or make gray) only the pixels that are a direct
neighbour to the edge of the image. </P>

As you can see all the scaling methods however depend heavily on the actual
size of the shape you are performing the '<CODE>Distance</CODE>' method on.
Too small and it is very dark and may not be accurate for your needs. Too
large and the distance may get 'clipped' by the maximum posible color value of
your ImageMagick's <A HREF="http://legacy.imagemagick.org/Usage/basic/#quality" >Compile Time Quality</A>.  For
more details on the '<I>scale</I>' factor in the kernel, see <A
HREF="index.html#distance_kernels" >Distance Kernel</A> section below. </P>

I would like to make one final note about the man-like 'shape' used in these
examples.  The shape contains a single pixel 'hole' that created a sort of
'gradient well' around it. This results in a very strong effect on upper half
of the resulting 'distance gradient' image. </P>

One solution to this is to remove that hole, by using '<CODE><A HREF="index.html#close"
>Close</A></CODE>', so as to make the shape 'clean n smooth'.  For example...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert man.gif -morphology Close Diamond  man_clean.gif
  convert man_clean.gif   -morphology Distance Euclidean \
                                    -auto-level   distance_clean.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="man.gif"
     ><IMG SRC="man.gif"               WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="man_clean.gif"
     ><IMG SRC="man_clean.gif"               WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="distance_clean.gif"
     ><IMG SRC="distance_clean.gif"      WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

Of course this also has the effect of also 'closing' the gap between the
shapes 'legs' too, which effects the lower half of the final result. </P>

An alternative solution is to use a <A HREF="../color_basics/index.html#floodfill_draw"
>Floodfill</A> method to extract the outside of the image, and convert that
into new mask.  The result is that any holes have been closed, but the outside
boundary of the image has been preserved.  For example..

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert man.gif -gamma 0,1,1 -bordercolor black -border 1x1 \
          -fill red -floodfill +0+0 black -shave 1x1 \
          -channel R -separate +channel -negate  man_floodfill.gif
  convert man_floodfill.gif    -morphology Distance Euclidean \
                                    -auto-level   distance_floodfill.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="man.gif"
     ><IMG SRC="man.gif"               WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="man_floodfill.gif"
     ><IMG SRC="man_floodfill.gif"               WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="distance_floodfill.gif"
     ><IMG SRC="distance_floodfill.gif"      WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=2 HSPACE=15 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>




<A NAME="distance_kernels"></A>
<H3>Distance Kernels</H3>

The kernel given is very special, as it is used to define the actual distance
measurements that is to be assigned to each pixel.  For example here the <A
HREF="index.html#showkernel" >Show Kernel</A> output of one of the built-in 'Distance
Kernels'.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE NOIMAGE ERR=k_chebyshev_3.txt>
  convert xc: -define morphology:showkernel=1 -precision 3 \
          -morphology Distance:0 Chebyshev:3     null:
</CODE></PRE></TD></TR></TABLE>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD>
  <A HREF="k_chebyshev_3.txt"
     ><IMG SRC="k_chebyshev_3.txt.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE>
</DIV></P>

The important thing to note is that the 'origin' (in this case the exact
center of the kernel) has a value of zero.  This is very important.  That
'origin' is then surrounded by larger values, which increase linearly with
greater distance from that 'origin'.  If the kernel is not defined in this
specific way, unexpected and strange effects may result. </P>

The value given in the kernel is the actual 'value' that will be added to
an already 'known' distance, assigned to a pixel if that value is smaller than
what is already assigned.  The result is that 'white' pixels are made darker
the closer they are to an edge, and linearly brighter (adding to previously
assigned values) the further it gets from the edge.  </P>

All the provided built-in Distance kernels can take two optional
<I>k_arguments</I>...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE DO_NOT_EXECUTE>
     {<I>distance_kernel</I>}[:{<I>radius</I>}[,{<I>scale</I>}[%][!]]]
</CODE></PRE></TD></TR></TABLE>
</DIV></P>

The first argument like all the <A HREF="index.html#kernels" >Shape Kernels</A> is the
kernels <I>radius</I> which defines how big to make the generated kernel.  By
default the <I>radius</I> is set to '<CODE>1</CODE>' for the built-in distance
kernels, resulting in a very small 3 by 3 kernel, which in most cases works
quite well. </P>

The second argument '<I>scale</I>' sets the distance scale used to represent
the distance of one pixel length.  As shown in the example above it defaults
to a value of '<CODE>100</CODE>'.  That is a pixel which is given a final
pixel or grey-scale value of say '<CODE>300</CODE>' should be exactly '3
pixels' away from the edge. </P>

<A NAME="distance_scaling"></A>
<B>Distance Scaling</B></P>

As mentioned previously, a large '<I>scale</I>' value is used so that you can
use 'fractional' distances for more 'exact' distance measurements.  However
only the provided '<CODE><A HREF="index.html#euclidean" >Euclidean</A></CODE>' distance
kernel uses such 'fractional' values. </P>

In the previous examples, the 'largest distance' value assigned was
'<CODE>1700</CODE>', which would overflow a Q8 version of ImageMagick  (See <A
HREF="http://legacy.imagemagick.org/Usage/basic/#quality" >Quality, in memory bit depth</A>).  An IM Q8, only
allows color values to reach a maximum value of 255 (2<SUP>Q</SUP> =>
2<SUP>8</SUP> => 256 color values, ranging from 0 to 255).  As such using
a smaller <I>scale</I> such as '<CODE>10</CODE>' or '<CODE>20</CODE>' will
work better for users using the IM Q8 compile time variant. Though it is far
less accurate when used with a '<CODE><A HREF="index.html#euclidean"
>Euclidean</A></CODE>' kernel. </P>

Because of this it is recommended that user with Q8 versions of IM, restrict
themselves to using the other 'integer' distance kernels, with a scale factor
of '<CODE>1</CODE>'. </P>


<A NAME="distance_scaling_flags"></A>

You can also specify the distance scaling as a percentage of the full color
range by including a '<CODE>%</CODE>' in the scaling factor.  That means if
you use a scale of '<CODE>12.5%</CODE>' of the color value range, then you
will be able to get a distance metric of about 8 pixels before the distance
overflows the color range limits of the IM version you are using.  </P>

Alternatively you can instead use a '<CODE>!</CODE>' which means the scale is
a divisor of the color range.  That is if you specify a scale of
'<CODE>20!</CODE>' the distance scaling will be set so that the color range
limit will be reached 20 pixels from the edge of the image. </P>

However even with these 'special scaling flags' you will still have severe
range accuracy limitation in Q8 versions of IM.  It just does not have the
range for the data values needed for may distance operations. </P>

Of course any <I>scale</I> (including full floating point) can be accurately
used for a <A HREF="http://legacy.imagemagick.org/Usage/basic/#hdri" >HDRI</A> versions of IM, as the resulting
color values are also stored as floating-point values.  Just be sure to
rescale the color range appropriately before attempting to save such an image
to non-floating point image file formats. </P>

<BR>

A number of different distance measuring kernels are provided, with one that
can be used in a two different ways. Each kernel provides to with different
resulting 'distance metrics' for specifying the pixel distance from the edge,
and basically define what is to be considered the 'nearest edge'. </P>


<A NAME="chebyshev"></A>
<H4>Chebyshev (Chessboard) Distance Kernel</H4>

The '<CODE><B>Chebyshev</B></CODE>' distance kernel is the simplest, and
specifies that all pixel around the 'origin' is simply 1 distance unit from
its neighbours.  That is all 8 neighbours are 'next' to each other. As such
only are the immediate four neighbours a distance of 1 unit, but the diagonal
neighbours are also exactly 1 unit away. </P>

This is often likened to the distance in squares that a 'King' or 'Queen'
chess piece moves of a chessboard, and hence is often also known as
a '<I>Chessboard</I>' distance metric. </P>

Note however that distance kernels have use a default <I>{scale}</I> factor of
100 distance units, per pixel of distance. As such the distance is 100 units
for every step away from the origin. </P>

This was also the kernel that was used in the previous examples above.  </P>

Here is the actual kernel it generates...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE NOIMAGE ERR=k_chebyshev.txt>
  convert xc: -define morphology:showkernel=1  -precision 4 \
          -morphology Distance:0 Chebyshev       null:
</CODE></PRE></TD></TR></TABLE>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD>
  <A HREF="k_chebyshev.txt"
     ><IMG SRC="k_chebyshev.txt.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE>
</DIV></P>

The name of this kernel is that of the Russian mathematician Pafnuty Chebyshev
who first mathematically described this form of distance measurement.  You can
find out more about this measure on <A
HREF="http://en.wikipedia.org/wiki/Chebyshev_distance" >Wikipedia, Chebyshev
Distance</A>. </P>

Using a '<CODE>Chebyshev</CODE>' distance measure, the final distance of
a pixel is the largest X or Y value to the closest edge. However as the
diagonal distance is only 1 unit, the maximum distance within an image is
usually smaller than you would expect. </P>

Lets generate a 'distance gradient' using this kernel 'metric'.
However so we can see what is going on lets use a slower '<CODE>Iterative
Distance</CODE>' morphology method using an infinite iteration count.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=top><TD WIDTH=10% ALIGN=justify ROWSPAN=2></TD>
               <TD WIDTH=80% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE OUT=chebyshev_distance.txt
                           ERR=chebyshev_gradient.txt>
  convert man.gif -threshold 50% +depth \
          -define debug=true  -morphology IterativeDistance:-1 Chebyshev  \
          chebyshev_gradient.png

<n>  identify -format 'Maximum Distance = %[max]' chebyshev_gradient.png
  convert chebyshev_gradient.png -auto-level chebyshev_gradient.gif
  rm chebyshev_gradient.png
</CODE></PRE></TD></TR></TABLE></TD><TD ALIGN=center ROWSPAN=2>
  <A HREF="chebyshev_gradient.gif"
     ><IMG SRC="chebyshev_gradient.gif"      WIDTH=100   HEIGHT=125
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR><TR><TD>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD>
  <A HREF="chebyshev_gradient.txt"
     ><IMG SRC="chebyshev_gradient.txt.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
<BR>
  <A HREF="chebyshev_distance.txt"
     ><IMG SRC="chebyshev_distance.txt.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE></TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  The '<CODE>Iterative Distance</CODE>' morphology method calculates distance
  by applying the distance kernel repeatally until no more changes in value
  are seen.  </P>

  This is much slower than the more normal '<CODE>Distance</CODE>' method,
  which uses a two pass method to set the distance across the image as
  a whole.  However the verbose output of '<CODE>Distance</CODE>' method is
  far less interesting. </P>
</I></FONT></TD></TR></TABLE></P>

I turned on the <A HREF="index.html#verbose" >Verbose</A> flag so that the command will
output how many pixels were changed (all white pixels) by the operation,
during each interation (pass) through the image. </P>

Then I extracted the 'maximum' distance generated ('<CODE>1400</CODE>'),
before adjusting the result (normalizing) into an image where you can see the
resulting gradient. </P>

The maximum distance '<CODE>1400</CODE>', is value of the brightest pixels in
the image (actually it is a cluster of 4 such pixels).  This information is
the most important result of this distance kernel (metric), as it represents
the size of the largest square that will fit within this shape.  Specially 14
pixel radius or a square of approximately (R-1)*2+1 => 27 pixels per side,
centered on those 4 maximum pixels.  </P>

As all the distances units in this kernel are always multiples of '100' then
this final distance value should always be a multiple of '100', and will never
have any fractional component. </P>

Basically this kernel will produce an integer distance, and you can a simple '1
unit' <I>scale</I> with this kernel without loss of any distance information.
This is recommended if you are using a <A HREF="../basics/index.html#quality" >Q8
version of ImageMagick</A>, or are applying this to very very large images.
</P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>

Here is an magnification of the gradient between the shapes 'legs' which
highlights the features of the distance gradient generated.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert chebyshev_gradient.gif -crop 25x20+39+69 +repage \
          -scale 500% chebyshev_magnify.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="chebyshev_magnify.gif"
     ><IMG SRC="chebyshev_magnify.gif"      WIDTH=125 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

As you can see the '<CODE><A HREF="index.html#chebyshev" >Chebyshev</A></CODE>' distance
kernel produces a very square like gradient.  This is a specific feature of
this simple form of distance metric, and directly reflect the square nature of
the distance kernel itself. </P>

The above also shows the 4 maximum distance pixels in the figures 'belly'
close to the top of the image. By centering a square on any of these 4 point
you can generate the largest odd sized square that is wholly contained within
the figure. </P>

However be warned that there may be a number of such 'peaks'. </P>

<A NAME="manhattan"></A>
<H4>Manhattan (Taxi Cab) Distance Kernel</H4>

The '<CODE><B>Manhattan</B></CODE>' distance kernel, measures the distance by
adding the X and Y values to the closest edge. It is basically the distance
you need to travel when you are restricted to only grid-like movements, such
as a taxi cab on the streets of large cities like Manhattan, New York. </P>

Because of this other more common names for this measure is '<I>Taxi Cab</I>'
or '<I>City Block</I>' distance metric.  You can find out more on <A
HREF="http://en.wikipedia.org/wiki/Manhattan_distance" >Wikipedia, Manhattan
Distance</A>. </P>

Here is the actual kernel it generates...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE NOIMAGE ERR=k_manhattan.txt>
  convert xc: -define morphology:showkernel=1  -precision 4 \
          -morphology Distance:0 Manhattan     null:
</CODE></PRE></TD></TR></TABLE>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD>
  <A HREF="k_manhattan.txt"
     ><IMG SRC="k_manhattan.txt.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE>
</DIV></P>

Note that the diagonals now have a value of '200' or 2 units from the center.
That is to reach a diagonal pixel you would have to travel through two pixels
in the gird-like movements mentioned.  As a result of this, diagonals tend to
be larger than expected, as such the final distance measurements also tends to
be larger. </P>

Lets again get extract the maximum distance and the 'distance gradient' image
using this 'metric'.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=top><TD WIDTH=10% ALIGN=justify ROWSPAN=2></TD>
               <TD WIDTH=80% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE OUT=manhattan_distance.txt>
  convert man.gif -threshold 50% +depth \
          -morphology Distance Manhattan      manhattan_gradient.png

<n>  identify -format 'Maximum Distance = %[max]' manhattan_gradient.png
  convert manhattan_gradient.png -auto-level manhattan_gradient.gif
  rm manhattan_gradient.png
</CODE></PRE></TD></TR></TABLE></TD><TD ALIGN=center ROWSPAN=2>
  <A HREF="manhattan_gradient.gif"
     ><IMG SRC="manhattan_gradient.gif"      WIDTH=100   HEIGHT=125
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR><TR><TD>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD>
  <A HREF="manhattan_distance.txt"
     ><IMG SRC="manhattan_distance.txt.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE></TD></TR></TABLE></P>

I did not use '<CODE>Iterative Distance</CODE>' this time, and even if I did
the total count of pixels changed would not be accurite. Only the previous
'<CODE><A HREF="index.html#chebyshev" >Chebyshev</A></CODE>' kernel will set a pixel
distance once and only once. </P>

Note how the final maximum distance for the image is much larger, at
'<CODE>1700</CODE>' distance units, making the maximum pixel(s) within the
shape 17 pixels from the edge.  </P>

This distance kernel is also a 'integer' kernel and as such you can set the
<I>scale</I> to just '1 unit' without loss of information.  </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>

Here is an magnification of the gradient.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert manhattan_gradient.gif -crop 25x20+39+69 +repage \
          -scale 500% manhattan_magnify.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="manhattan_magnify.gif"
     ><IMG SRC="manhattan_magnify.gif"      WIDTH=125 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

As you can see the '<CODE><A HREF="index.html#manhattan" >Manhattan</A></CODE>' distance
kernel generated a diamond-like gradient, which is basically what this simple
distance metric represents, as eflected by the actual kernel values. </P>


<A NAME="octagonal"></A>
<H4>Octagonal Distance Kernel</H4>

The '<CODE><B>Octagonal</B></CODE>' distance kernel is a little different than
the other two.  It is created by generating first a <A HREF="index.html#manhattan"
>Manhattan</A> distance for the pixels on the very edge, then using <A
HREF="index.html#chebyshev" >Chebyshev</A> for the pixels that are 2 units distance from
the edge. It then repeats using <A HREF="index.html#manhattan" >Manhattan</A> distance
for the 3 unit distance pixels, and so on.  The result is an 'interleaving' or
'averaging' of distance resulting from using the two simpler kernels.  </P>

As this kernel is based on an interleaving of two integer distance kernels, it
is also an integer distance kernel. As such a <I>scale</I> of '1 unit' can be
used to produce smaller values, for lower quality ImageMagick versions, or
very large distance measurements. </P>

The distance shape is also a mixture of the two kernels and as such produces
a the equivalent of the '<CODE><A HREF="index.html#octagon" >Octagon</A></CODE>' shaped
kernel. </P>

Here is the actual kernel it generates...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE NOIMAGE ERR=k_octagonal.txt>
  convert xc: -define morphology:showkernel=1  -precision 4 \
          -morphology Distance:0 Octagonal     null:
</CODE></PRE></TD></TR></TABLE>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD>
  <A HREF="k_octagonal.txt"
     ><IMG SRC="k_octagonal.txt.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE>
</DIV></P>

Note that the kernel has a minimum and default size of radius 2, forming a 5x5
pixel kernel.  This slightly bigger kernel is needed to generate the
'interleaving' of the kernels. The overall distance will generally be very
slightly smaller than a true distance. </P>

Here we again calculate the maximum distance...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=top><TD WIDTH=10% ALIGN=justify ROWSPAN=2></TD>
               <TD WIDTH=80% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE OUT=octagonal_distance.txt>
  convert man.gif -threshold 50% +depth \
          -morphology Distance Octagonal  octagonal_gradient.png

<n>  identify -format 'Maximum Distance = %[max]' octagonal_gradient.png
  convert octagonal_gradient.png -auto-level octagonal_gradient.gif
  rm octagonal_gradient.png
</CODE></PRE></TD></TR></TABLE></TD><TD ALIGN=center ROWSPAN=2>
  <A HREF="octagonal_gradient.gif"
     ><IMG SRC="octagonal_gradient.gif"      WIDTH=100   HEIGHT=125
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR><TR><TD>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD>
  <A HREF="octagonal_distance.txt"
     ><IMG SRC="octagonal_distance.txt.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE></TD></TR></TABLE></P>

The result of '<CODE>1500</CODE>' is an 'integer' distance, and actually falls
between the too-small Chebyshev Distance, and the too-large Manhattan
Distance. However in general it should be reasonably close to the real actual
distance to the center of the shape, while remaining an 'integer' value. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>

Here is an magnification of the gradient.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert octagonal_gradient.gif -crop 25x20+39+69 +repage \
          -scale 500% octagonal_magnify.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="octagonal_magnify.gif"
     ><IMG SRC="octagonal_magnify.gif"      WIDTH=125 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

You can clearly see the 'octagonal' distances that have developed around the
top of the leg gap. You can also see that the diagonal was generated using an
interleaving of thick and thin diagonal lines.  </P>

<A NAME="fractional_octogon"></A>
<H4>Fractional Octogon Distance Kernel</H4>

<I>A named distance kernel has not been provided. But it fits into the
distance kernel sequence we are studing nicely at this point. </I> </P>

You can generate another type of integer distance kernel using an octagonal
shape.  However the integer distance in this case uses an unit value of 2
per pixel, so really the distance values generated needs to be halved,
generating a frational value from the small integers that are generated. This
the name "Fractional Octogon". </P>

To do this we use an integer distance of 2 between neighbouring pixels, and
3 for the diagonal.
<PRE>'3: 3,2,3
    2,0,2
    3,2,3'</PRE></P>

As 'half integers' can be generated the smallest minimal scale that can be
used is '2 units'. and while not as accurate a 'knights move' it does work
well. </P>

The octogon of this kernel has 'points' in the orthogonal direction, rather
than 'flats' as the previous kernel generates.  It is related to, but not
quite the same as the next 'Knights Move' kernel, and could be considered
a sort of 'near integer' form of the '<CODE>knights</CODE>' kernel. </P>

If you want to scaling this the same as previous IM distance kernels you can
use. this kernel.
<PRE>'3: 150,100,150
    100, 0 ,100
    150,100,150'</PRE>

Here is an example

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=top><TD WIDTH=10% ALIGN=justify ROWSPAN=2></TD>
               <TD WIDTH=80% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE OUT=fractional_distance.txt>
  convert man.gif -threshold 50% +depth \
          -morphology Distance '3:3,2,3 2,0,2 3,2,3' \
          fractional_gradient.png

<n>  identify -format 'Maximum Distance = %[max]' fractional_gradient.png
  convert fractional_gradient.png -auto-level fractional_gradient.gif
  rm fractional_gradient.png
</CODE></PRE></TD></TR></TABLE></TD><TD ALIGN=center ROWSPAN=2>
  <A HREF="fractional_gradient.gif"
     ><IMG SRC="fractional_gradient.gif"      WIDTH=100   HEIGHT=125
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR><TR><TD>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD>
  <A HREF="fractional_distance.txt"
     ><IMG SRC="fractional_distance.txt.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE></TD></TR></TABLE></P>

The result of '<CODE>34</CODE>' is an 'integer' distance, but needs to be
divided by 2 to produce an actual maximum distance result of 17. however while
this is also an integer, it could just as easilly come out as being
a fractional distance of 16.5. </P>

This fractional aspect of distance results is why most kernels are defined
using units of 100, and will in later kernels become more prevelent as we move
away from purely integer distance kernels. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>

Here is an magnification of the gradient.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert fractional_gradient.gif -crop 25x20+39+69 +repage \
          -scale 500% fractional_magnify.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="fractional_magnify.gif"
     ><IMG SRC="fractional_magnify.gif"      WIDTH=125 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>

The gradient (if you study the results carfully) is an octagonal shape.  But
it is hard to see the pixels that have common distance values. To see the
shape more clearly, I have taken the above image and colored one set of pixels
with the same color value, red.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert fractional_magnify.gif -fill red -opaque gray53 \
          fractional_magnify_shape.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="fractional_magnify_shape.gif"
     ><IMG SRC="fractional_magnify_shape.gif"      WIDTH=125 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

As you can see pixels of the same value are generally separated in a 'knight's
move' pattern, but form lines that generate an octagonal shape.  The octogon is
however rotated 45 degrees from the <A HREF="http://legacy.imagemagick.org/Usage/morphology/octagonal" >Octagonal Distance
Kernel</A> </P>

It is also this shape difference that causes the final maximum distance to be
larger.  Essentually a larger octagon rotated in this way fits into the shape
better, thus the larger maximal distance result. </P>


Another fractional distance 'interger' kernel that can be used is this one,
though the distance is in terms of 3 units instead of 2. That is the results
need to be divided by 3 to get the distance in terms of pixel size, which is
not really a great divisor to use.  It is however another octagonal type
distance metric.

<PRE>'3: 4,3,4
    3,0,3
    4,3,4'</PRE></P>

The <A HREF="index.html#knight" >Euclidean (Knights Move) Distance Kernel</A> below also
generates an octagonal style of shape (all 3x3 distance kernels do), but tries
to be as accurite as posible along the diagonals.  This may or may not be
the best idea, but it is the most mathematically logical octagonal distance
kernel of this type. </P>


<A NAME="chamfer"></A>
<H4>Chamfer Distance Kernels</H4>

<I>A named distance kernel has not been provided. But it fits into the
distance kernel sequence we are studing nicely at this point. </I> </P>

A 'Chamfer' Distance kernel (not yet implemented), is defined using just the
numbers (typically integers) that is to be used to fill in the distance
matrix. </P>

You can for example give it 2 numbers to define any 3x3 'octagonal' type
distance kernel, as described above. </P>

Here are the definitions of the pervious interget kernels,
<TABLE ALIGN=center>
<TR><TD>Chebyshev</TD><TD>Chamfer:1,1</TD></TR>
<TR><TD>Manhattan</TD><TD>Chamfer:1,2</TD></TR>
<TR><TD>Fractional Octagon &nbsp;</TD>
            <TD>Chamfer:2,3 &nbsp;</TD><TD>&nbsp; /2</TD></TR>
</TABLE></P>
<TR><TD>Fractional Octagon Alturnative &nbsp;</TD>
            <TD>Chamfer:3,4 &nbsp;</TD><TD>&nbsp; /3</TD></TR>
</TABLE></P>

All these kernals are simple radius 1 kernels.  The values give can be
regarded as the actual 'distance scaling' values it should be using. </P>

Note however that the previous Integer <A HREF="index.html#octagonal" >Octagonal</A>
kernel requires a 3 number radius 2 Chamfor Kernel to define it. </P>

The most well known Chamfer kernel is as radius 2 kernel, 'Chamfer:5,7,11',
which generates a very accurate distance, and also generates an integer
distance values making it well suited for Q8 users. </P>

Traditionally the kernel (chamfor 5,7,11) is of the form...
<PRE>'5:  -   11   -   11   -
    11    7   5   7    11
     -    5   0   5    -
    11    7   5   7    11
     -   11   -   11   -'</PRE>
OR multiply the above by 20, to produce the same pixel distance scaling (100)
used normally by ImageMagick for distance kernels....
<PRE>'5:  -   220   -   220   -
    220  140  100  140  220
     -   100   0   100   -
    220  140  100  140  220
     -   220   -   220   -'</PRE></P>

Note how the kernel does not actually fill in ALL the kernel distances.  That
is because those values will get their distances from the other values already
provided.  that is you don't actually need to fill out the whole
2-diamentional array to fully define a distance kernel, though it is typically
done for easier processing. </P>

Here is a list of other known Chamfer kernels (only using integer values) that
I have found in my research.

<TABLE ALIGN=center>
<TR><TD>Chamfer:3,4 &nbsp;</TD>
    <TD>&nbsp; /3</TD></TR>
<TR><TD><B>Chamfer:5,7,11</B> &nbsp;</TD>
    <TD>&nbsp; /5</TD></TR>
<TR><TD>Chamfer:99,141,221 &nbsp;</TD>
    <TD>&nbsp; /100</TD></TR>
<TR><TD>Chamfer:987,1414,2206 &nbsp;</TD>
    <TD>&nbsp; /1000</TD></TR>
<TR><TD>Chamfer:12,17,27,38,43 &nbsp;</TD>
    <TD>&nbsp; /12</TD></TR>
</TABLE></P>

<DIV ALIGN=center><FONT SIZE=-2>
  <IMG SRC="../img_diagrams/chamfor_values.png" WIDTH=100 HEIGHT=100
       BORDER=0 HSPACE=0 VSPACE=0 ALT="[diagram]">
  <BR>How 5 values are placed to define a radius 3 Chamfor kernel
</FONT></DIV></P>

The kernel highlighted in the above table is the most well known and commonly
used Chamfor Distance Kernel.  It generates image using only small integer
values, as such the large distance gradent images can be stored without loss
of precision. It is also very accurite, at least enough for just about every
imaginable purpose. As a bonus the distance results do not create recursive
decimal places just a single digit fraction when normalized.  This is another
reason why it is often selected by many image processing packages. </P>

<I>The "Chamfer:5,7,11" should be regarded as the default "Chamfor" Distance
kernel. </I></P>

<A NAME="knight"></A>
<H4>Euclidean (Knights Move) Distance Kernel</H4>

The '<CODE><B>Euclidean</B></CODE>' kernel is generated using exact floating
point distance numbers.  But to make this work with non-HDRI versions of
ImageMagick requires the use of a fractional diagonal distances. Such as the
diagonal which has a value of the square root of 2, a value of about 1.4142
distance units.  To allow this to work the distances are scaled by a value of
100 (as in all the above kernels), to produce a fractional percentage
distance.  </P>

Here is the default kernel it generates...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE NOIMAGE ERR=k_knight.txt>
  convert xc: -define morphology:showkernel=1  -precision 4 \
          -morphology Distance:0 Euclidean    null:
</CODE></PRE></TD></TR></TABLE>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD>
  <A HREF="k_knight.txt"
     ><IMG SRC="k_knight.txt.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE>
</DIV></P>

Now by using the default <I>radius</I> of 1, while a big improvement on the
previous kernels in terms of accuracy, still has some limitations.  Basically,
it provides a distance in terms of just 45 degree diagonals and orthogonal (X
and Y) moves. That is the distances are somewhat like a '<I>Knight's Move</I>'
in the game of chess. </P>

Here is the maximum distance and the 'distance gradient' image that was
created using the default '<CODE>Euclidean</CODE>' or 'Knight Move' kernel.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=top><TD WIDTH=10% ALIGN=justify ROWSPAN=2></TD>
               <TD WIDTH=80% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE OUT=knight_distance.txt>
  convert man.gif -threshold 50% +depth \
          -morphology Distance Euclidean    knight_gradient.png

<n>  identify -format 'Maximum Distance = %[max]' knight_gradient.png
  convert knight_gradient.png -auto-level knight_gradient.gif
  rm knight_gradient.png
</CODE></PRE></TD></TR></TABLE></TD><TD ALIGN=center ROWSPAN=2>
  <A HREF="knight_gradient.gif"
     ><IMG SRC="knight_gradient.gif"      WIDTH=100   HEIGHT=125
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR><TR><TD>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD>
  <A HREF="knight_distance.txt"
     ><IMG SRC="knight_distance.txt.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE></TD></TR></TABLE></P>

As you can see for this specific shape, you also get a distance value of
'<CODE>1700</CODE>' distance units.  Normally the result would be some
fractional distance, between the smaller '<CODE><A HREF="index.html#chebyshev"
>Chebyshev</A></CODE>' distance, or the larger '<CODE><A HREF="index.html#manhattan"
>Manhattan</A></CODE>' distance. It is just plain luck that it came out as
a simple multiple of '<CODE>100</CODE>' and that it also happened to be the
same as the '<CODE><A HREF="index.html#manhattan" >Manhattan</A></CODE>' distance. </P>

The actual distance to a pixel is actually the sum of the diagonal distance,
plus the orthogonal (axis) distance.  That is not quite a perfect Euclidean
distance, but it is the closest to it you can get while using the smallest
distance kernel posible (of radius 1). </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>

Here is an magnification of the gradient between the shapes 'legs'.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert knight_gradient.gif -crop 25x20+39+69 +repage \
          -scale 500% knight_magnify.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="knight_magnify.gif"
     ><IMG SRC="knight_magnify.gif"      WIDTH=125 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

As you can see the gradient has a much more rounded look to it, without the
onion-like 'levels' or 'terraces' effect that you get in a 'integer' distance
kernel.  This is because each pixel is more likely to be assigned individual
fractional distance from the edge. </P>

The final shape of the gradient however is actually roughly 'octagonal' in
shape, though with points like a compass, rather than flats top and bottom as
you get with the previous '<CODE><A HREF="index.html#octagonal" >Octagonal</A></CODE>'
distance kernel. </P>

For general distance work (such as 'feathering') this default
'<CODE>Euclidean</CODE>' or 'Knights Move' kernel provides a good result.
However as you do not get 'integer' distances, you can not use this using
a distance scale factor of '<CODE>1</CODE>', making it less useful for Q8
versions of ImageMagick. </P>


<A NAME="euclidean"></A>
<H4>Larger Euclidean Distance Kernel</H4>

By increasing the '<I>radius</I>' of the generated '<CODE>Euclidean</CODE>'
kernel and you produce an even more accurate 'Pythagorean' or true 'Euclidean'
distance metric. </P>

The larger the <I>radius</I> the more accurate the result, but it will take
longer for the morphological '<CODE><A HREF="index.html#distance" >Distance</A></CODE>'
method method to run, though fewer such iterations will be needed. </P> Beyond
a radius of 4 however you will not get much more accuracy, but you will get
a much greater loss of speed.  See <A HREF="index.html#distance_anti-alias" >Distance
with an Anti-Aliased Shape</A> below for some examples of using very large
'<CODE>Euclidean</CODE>' kernels to improve accuracy. </P>

Here is a true '<CODE>Euclidean</CODE>' kernel using the recommended radius of
4, which generates a larger 9&times;9 kernel...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE NOIMAGE ERR=k_euclidean.txt>
  convert xc: -define morphology:showkernel=1  -precision 4 \
          -morphology Distance:0 Euclidean:4     null:
</CODE></PRE></TD></TR></TABLE>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD>
  <A HREF="k_euclidean.txt"
     ><IMG SRC="k_euclidean.txt.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE>
</DIV></P>

The added advantage of using a radius of 4 is that the kernel also contains
the Pythagorean Triangle, which has sides 3,4,5, or with the default kernel
scale, units of 300,400,500.   Though this can reduce the number of fractional
components in the resulting image, it is really only a minor effect.  Still it
is a logical choice for more accuracy. </P>

Here is its application...

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=top><TD WIDTH=10% ALIGN=justify ROWSPAN=2></TD>
               <TD WIDTH=80% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE OUT=euclidean_distance.txt>
  convert man.gif -threshold 50% +depth \
          -morphology Distance Euclidean:4     euclidean_gradient.png

<n>  identify -format 'Maximum Distance = %[max]' euclidean_gradient.png
  convert euclidean_gradient.png -auto-level euclidean_gradient.gif
  rm euclidean_gradient.png
</CODE></PRE></TD></TR></TABLE></TD><TD ALIGN=center ROWSPAN=2>
  <A HREF="euclidean_gradient.gif"
     ><IMG SRC="euclidean_gradient.gif"      WIDTH=100   HEIGHT=125
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR><TR><TD>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD>
  <A HREF="euclidean_distance.txt"
     ><IMG SRC="euclidean_distance.txt.gif"
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=0 ALT="[IM Text]"></A>
</TD></TR></TABLE></TD></TR></TABLE></P>

As a result of using this larger radius '<CODE>Euclidean</CODE>' kernel, the
final maximum distance is the most accurate maximum distance measurement yet.
It also makes in unlikely for you to get more than one 'brightest' pixel in
the image, unless the shape is very regular. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>

Here is an magnification of the gradient between the shapes 'legs'.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert euclidean_gradient.gif -crop 25x20+39+69 +repage \
          -scale 500% euclidean_magnify.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="euclidean_magnify.gif"
     ><IMG SRC="euclidean_magnify.gif"      WIDTH=125 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

As you can see the gradient produces a near-perfect circular gradient around
the end of the 'leg gap'. </P>

The cost of using this kernel is as I said above, a marginally slower running
time. </P>

<A NAME="distance_compare"></A>
<H4>Comparison of Distance Kernels</H4>

Here again is a side-by-side comparison of the magnifications.  This clearly
shows the very different gradients generated by each of each of the four
distance metrics used.

<DIV ALIGN=center>
<TABLE BORDER=0 CELLSPACING=5 CELLPADDING=5 WIDTH=80%>
<TR VALIGN=top>
<TD ALIGN=center>
  <A HREF="chebyshev_magnify.gif"
     ><IMG SRC="chebyshev_magnify.gif"      WIDTH=125 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=1 ALT="[IM Output]"></A>
  <BR>Chebyshev
  <BR><FONT SIZE=-1>(Chessboard)</FONT>
</TD><TD ALIGN=center>
  <A HREF="manhattan_magnify.gif"
     ><IMG SRC="manhattan_magnify.gif"      WIDTH=125 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=1 ALT="[IM Output]"></A>
  <BR>Manhattan
  <BR><FONT SIZE=-1>(Taxi Cab)</FONT>
</TD><TD ALIGN=center>
  <A HREF="octagonal_magnify.gif"
     ><IMG SRC="octagonal_magnify.gif"      WIDTH=125 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=1 ALT="[IM Output]"></A>
  <BR>Octagonal
  <BR><FONT SIZE=-1>(Mixed)</FONT>
</TD><TD ALIGN=center>
  <A HREF="knight_magnify.gif"
     ><IMG SRC="knight_magnify.gif"      WIDTH=125 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=1 ALT="[IM Output]"></A>
  <BR>Euclidean
  <BR><FONT SIZE=-1>(Knights Move)</FONT>
</TD><TD ALIGN=center>
  <A HREF="euclidean_magnify.gif"
     ><IMG SRC="euclidean_magnify.gif"      WIDTH=125 HEIGHT=100
           ALIGN=middle VSPACE=0 HSPACE=0 BORDER=1 ALT="[IM Output]"></A>
  <BR>Euclidean
  <BR><FONT SIZE=-1>(radius=4)</FONT>
</TD></TR></TABLE></DIV></P>

Here is another comparision this time getting the distance away from a single
black pixel close to the lower left corner, without any magnification of the
pixels.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE SCRIPT>
  convert -size 100x100 xc: -draw 'point 20,80'  distance_start.png

  for kernel in chebyshev manhattan octagonal euclidean euclidean:2 euclidean:4
  do
    convert distance_start.png    -morphology Distance $kernel \
            -auto-level  point_$kernel.png
  done
</CODE></PRE></TD></TR></TABLE>
<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=80%>
<TR VALIGN=top>
<!--
<TD ALIGN=center>
  <A HREF="distance_start.png"
     ><IMG SRC="distance_start.png"    WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD><TD ALIGN=center>
  <IMG SRC="../img_www/right.gif"   WIDTH=20 HEIGHT=20
       ALIGN=middle VSPACE=45 HSPACE=5 BORDER=0 ALT="==>">
</TD> -->
<TD ALIGN=center>
  <A HREF="point_chebyshev.png"
     ><IMG SRC="point_chebyshev.png"    WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR>Chebyshev
  <BR><FONT SIZE=-1>(Chessboard)</FONT>
</TD><TD ALIGN=center>
  <A HREF="point_manhattan.png"
     ><IMG SRC="point_manhattan.png"    WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR>Manhattan
  <BR><FONT SIZE=-1>(Taxi Cab)</FONT>
</TD><TD ALIGN=center>
  <A HREF="point_octagonal.png"
     ><IMG SRC="point_octagonal.png"    WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR>Octagonal
  <BR><FONT SIZE=-1>(Mixed)</FONT>
</TD><TD ALIGN=center>
  <A HREF="point_euclidean.png"
     ><IMG SRC="point_euclidean.png"    WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR>Euclidean
  <BR><FONT SIZE=-1>(Knights Move)</FONT>
</TD><TD ALIGN=center>
  <A HREF="http://legacy.imagemagick.org/Usage/morphology/point_euclidean:2.png"
     ><IMG SRC="http://legacy.imagemagick.org/Usage/morphology/point_euclidean:2.png"    WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR>Euclidean
  <BR><FONT SIZE=-1>(radius=2)</FONT>
</TD><TD ALIGN=center>
  <A HREF="http://legacy.imagemagick.org/Usage/morphology/point_euclidean:4.png"
     ><IMG SRC="http://legacy.imagemagick.org/Usage/morphology/point_euclidean:4.png"    WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
  <BR>Euclidean
  <BR><FONT SIZE=-1>(radius=4)</FONT>
</TD></TR></TABLE>
</DIV></P>

These images clearly shows the lines along which pixels are thought to be
closer to the starting pixel than you probably expect, and how the various
kernels become smoother as they get more complex. </P>

Only the last shows no visible lines of 'closer pixels', but even at radius
4 they are present. For this kernel the lines only appear at a great distance
from the source.  A radius 7 produces even better results, but at a great cost
in speed, though sometimes such accuracy is needed to avoid artifacts in the
resulting image. </P>

Remember only the first three kernels will produce integer distances, which
can be used on a Q8 version of ImageMagick (with appropriate scale adjustment,
see the individual kernel description). And it is these that are typically
what many image processing packages will use. </P>

Calculating distance from a single point will be looked at again later in <A
HREF="index.html#distance_constrainted" >Constrainted Distance</A> examples below.  </P>


<A NAME="distance_user"></A>
<H4>Special User defined Distance Kernels</H4>


You are not limited to the distance kernels that have been provided for you.
As long as you stick to the rules, of using a zero value at the 'origin', and
an increasing distance value surrounding it, you can generate other very
interesting distance effects. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

For example here I apply a very small <A HREF="index.html#user" >User Defined Kernel</A>
that simply says make any pixel to the right larger in value.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert man.gif -threshold 50% +depth \
          -morphology Distance  '2x1+0+0: 0,100 ' \
          -auto-level    distance_linear.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="distance_linear.gif"
     ><IMG SRC="distance_linear.gif"      WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Notice the effect of the gap between the legs, which 'resets' the slowly
increasing gradient that it generates. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

And here I create a distance gradient from just the two sides, but
with different scales for each side!

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert man.gif -threshold 50% +depth \
          -morphology Distance  '3x1: 50,0,100 ' \
          -auto-level    distance_sides.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="distance_sides.gif"
     ><IMG SRC="distance_sides.gif"      WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

These is just some examples of distance kernel variants that are possible.  Can
you think of others, please let me know. </P>

Note if your image comes out bad, your kernel origin setting is probably
wrong, or the origin was not a 'zero' value.  This is not checked for by the
morphology distance function. </P>


<A NAME="distance_anti-alias"></A>
<H3>Distance with an Anti-Aliased Shape</H3>

The Distance method works very well. But the best test of its functionality is
to apply the distance function to a circle, and then <A
HREF="http://legacy.imagemagick.org/Usage/transform/#shade" >Shade</A> it so as to highlight even the smallest
error that may be generated by the function.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 129x129 xc: -draw 'circle 64,64 60,4' \
          -negate  circle_shape.png

  convert circle_shape.png  -morphology Distance Euclidean:4 \
          -auto-level cone_distance.png

  convert cone_distance.png -shade 135x30 -auto-level \
          +level 10,90%  cone_distance_shade.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="circle_shape.png"
     ><IMG SRC="circle_shape.png"   WIDTH=129 HEIGHT=129
           ALIGN=middle VSPACE=10 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="cone_distance.png"
     ><IMG SRC="cone_distance.png"   WIDTH=129 HEIGHT=129
           ALIGN=middle VSPACE=10 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="cone_distance_shade.png"
     ><IMG SRC="cone_distance_shade.png"   WIDTH=129 HEIGHT=129
           ALIGN=middle VSPACE=10 HSPACE=2 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

You can see from the above that while you do get a 'conical' looking result,
it is far from the smooth 'cone'.  It is covered by a network of radial ridges
starting at the edges. </P>

If closely looking at the edge of the shaded cone, you will see that the cone
does not have a smooth circular base of the original shape. It is highly
'aliased' or 'stair-cased', and it is these 'steps' that are being reflected by
the distance function to form the radial ridges that is seen. </P>

The problem is that the distance method has no idea about the small 'grey'
anti-aliasing pixels the circle uses around the edge to give it that smooth
look.  In fact any 'grey' pixel is generally being thought of as a whole pixel
rather than the anti-aliased partial edge pixel they represent. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=top><TD WIDTH=100% ALIGN=justify>

What we need to do is somehow include those grey edge values in the result,
and this is done using a pre-processing step before the distance method is
applied.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert circle_shape.png  -gamma 2 +level 0,100 -white-threshold 99 \
          -morphology Distance Euclidean:4   -auto-level \
          -shade 135x30 -auto-level +level 10,90%   cone_antialiased.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="cone_antialiased.png"
     ><IMG SRC="cone_antialiased.png"   WIDTH=129 HEIGHT=129
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

What was done was to first convert all those grey pixels from a representation
of how much of the pixel was inside the circle boundary, to a representation
of how far the pixel was from the edge of the circle. </P>

As you can see from the result almost all the staircase edge errors have been
fixed.  </P>

The final errors that are visible only occur away from the edge, and become
more visible toward center of the 'cone'. They are caused by the
iteration of the distance function, every 4 pixel (the size of the euclidean
distance kernel) over and over.  As such the minor inaccuracies become
enhanced as we get further from the edge. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

This is typically not a problem in most situations, but you can reduce, or
possibly even eliminate even those small errors by using a larger Euclidean
kernel, so as to produce a much more accurate and smoother result. However
this does take longer to generate.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert circle_shape.png  -gamma 2 +level 0,100 -white-threshold 99 \
          -morphology Distance Euclidean:7   -auto-level \
          -shade 135x30 -auto-level +level 10,90%   cone_improved.png
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="cone_improved.png"
     ><IMG SRC="cone_improved.png"   WIDTH=129 HEIGHT=129
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

The result is an almost perfect distance function for an anti-aliased or
smooth shape.  </P>

Here is another example, this time using the two <A HREF="index.html#distance_user"
>User Defined Distance Kernels</A> from the previous section.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
   convert circle_shape.png -gamma 2 +level 0,100 -white-threshold 99 \
           -morphology Distance  '2x1+0+0:0,100'  -auto-level \
           circle_gradient.png

   convert circle_shape.png -gamma 2 +level 0,100 -white-threshold 99 \
           -morphology Distance  '3x1:50,0,100'  -auto-level \
           circle_ridge.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="circle_gradient.png"
     ><IMG SRC="circle_gradient.png"  WIDTH=129 HEIGHT=129
           ALIGN=middle VSPACE=2 HSPACE=25 BORDER=1 ALT="[IM Output]"></A>
  <A HREF="circle_ridge.png"
     ><IMG SRC="circle_ridge.png"
           ALIGN=middle VSPACE=2 HSPACE=25 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

Without the special handling for anti-alised pixels, the above would not
produce such a smooth gradient across the image. As it is we still need to
restore the 'shape' of the original shape. </P>

<A NAME="distance_feather"></A>
<H3>Feathering Shapes using Distance</H3>

The above technique can be applied to the Alpha Channel of a shape so as
to properly 'feather' the object. </P>

For example here is a 10 pixel 'smoothed' feather around an shaped object.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
   convert rose_orig.png \
           \( +clone -fill black -colorize 100% \
              -fill white -draw 'circle 114,75 110,2' \
           \) -alpha off -compose CopyOpacity -composite \
           -trim +repage rose_shape.png

   convert rose_shape.png \
           \( +clone -alpha extract -virtual-pixel black \
              -gamma 2 +level 0,100 -white-threshold 99 \
              -morphology Distance Euclidean:4,10! \
              -sigmoidal-contrast 3,0% \
           \) -compose CopyOpacity -composite \
           rose_feathered.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="rose_shape.png"
     ><IMG SRC="rose_shape.png"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="rose_feathered.png"
     ><IMG SRC="rose_feathered.png"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

This will preserve ALL edges exactly, unlike the simpler <A
HREF="../blur/index.html#feathering" >Blurred Feathering</A> technique. </P>

I could have applied the above directly against the alpha channel except that
some operators do not treat the transparency channel as 'alpha values' but as
'opacity values' (specifically "<CODE><A
HREF="../../../html/www/command-line-options.html#white-threshold" >-white-threshold</A></CODE>"
operator).  As such I extracted the alpha channel so as to handle it as
a grey-scale image, before merge it back into the final image. </P>

The special distance kernel will do three iterations of a 4 pixel <A
HREF="index.html#euclidean" >Euclidean Kernel</A>, to generate enough of a distance
gradient close to the edge of the shape.  The "<CODE><A
HREF="../../../html/www/command-line-options.html#level" >-level</A></CODE>" operator then convert that
into a linear gradient form the edge ('<CODE>0</CODE>') to 10 pixels
('<CODE>1000</CODE>' units) into the shape.. </P>

The "<CODE><A HREF="../../../html/www/command-line-options.html#virtual-pixel"
>-virtual-pixel</A></CODE>" setting is also provided to ensure the any shape
that touches the edge of the rectangular image container is also thought to
be surrounded by transparency. </P>

The result of the distance function in this case is a 'linear ramp' or 'bevel'
which can produce some sharp looking effects.  As such an a small "<CODE><A
HREF="../../../html/www/command-line-options.html#sigmoidal-contrast" >-sigmoidal-contrast</A></CODE>"
modification will smooth this transition from transparency to opaque. The
higher the strength ('<CODE>3</CODE>' in the above) the sharper the feathering
will be at the edge. If you like to have the feather 'taper' more smoothly
into transparency, replace the '<CODE>0%</CODE>' in the above code, with
'<CODE>50%</CODE>' to place the 'shoulder' of the sigmoidal curve in the
middle of the 10 pixel feather. </P>

<A NAME="distance_feather_bitmap"></A>
<B>Bitmap Shape Feathering</B></P>

If the shape is a bitmap, such as from a GIF image, or a <A
HREF="../masking/index.html#masks" >Image Masks</A>, then you can simplify the above
feathering operation. </P>

For example...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert figure.gif -channel A -virtual-pixel transparent \
          -morphology Distance Euclidean:4,3!  boolean_feathered.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="../images/figure.gif"
     ><IMG SRC="../images/figure.gif"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
  <IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="boolean_feathered.png"
     ><IMG SRC="boolean_feathered.png"
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=0 ALT="[IM Output]"></A>
</DIV></P>

The key changes is that you don't have far less pre- and post-processing the
distance function you can simply specify a special distance unit using
'<CODE>3!</CODE>'. Which will generate a 3 pixel linear gradient around the
edge of the shape. </P>

Another example of this type of feathering (a larger 'linear feather') can
be seen in <A HREF="../thumbnails/index.html#soft_edges" >Thumbnails, Soft Edges</A>.
</P>

You can use "<CODE><A HREF="../../../html/www/command-line-options.html#sigmoidal-contrast"
>-sigmoidal-contrast</A></CODE>" operator in the above to smooth out larger
feathers, but be warned that at this time it processes transparency as 'matte'
values rather than alpha values. as such a value of '<CODE>100%</CODE>' should
be used instead of '<CODE>05</CODE>' in the previous solution. </P>

For bitmap shapes, it may be better to apply a "<CODE>-blur 1x0.7</CODE>" to
the alpha channel, to smooth it slightly, before applying the previous, more
complex distance feather to those results. </P>

<HR><!-- ---------------------------------------------------------------- -->

<A NAME="conditional"></A>
<H2>Conditional or Constrained Morphology</H2>

Here we look at techniques where the repeated morphology operations are
constrained or limited to a particular area or region of an image.  Basically
techniques that can be used to ensure that you do not 'overflow' or grow
beyond some limit or area of interest. </P>

This generally requires a 'mask' image of some kind, and is typically done
using a <A HREF="../masking/index.html#write_mask" >Write Protect Mask</A>, to limit
what pixels are updated. </P>


<A NAME="dilate_conditional"></A>
<H3>Conditional Dilation</H3>

The <A HREF="index.html#dilate" >Dilate Morphology Method</A> as you know will expand
a specific shape according to a given kernel neighbourhood. '<B>Conditional
Dilation</B>' is essentually the same thing, but sets a limit as to how far
the dilation can spread when repeatedly applied to an image. </P>

A <A HREF="../color_basics/index.html#floodfill_draw" >Draw Flood-Fill</A> is in one
sense the ultimate 'Conditional Dilation'.  It will simply fill any orthogonal
(<A HREF="index.html#diamond" >Diamond Kernel</A> neighbourhood) that happens to be the
same color as the starting point. </P>

For example, we can select a single point in one of number of disks, and
conditionally dilate (flood fill) until that disk has been completely
recolored, seperating it from the other shapes.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert disks.gif -fill red -draw 'color 60,60 floodfill' \
          cond_dilate_draw.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="../images/disks.gif"
     ><IMG SRC="../images/disks.gif"    WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="cond_dilate_draw.gif"
     ><IMG SRC="cond_dilate_draw.gif"    WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

Similarly you can use the <A HREF="../color_basics/index.html#floodfill" >Floodfill
Operator</A> to do the same thing but only if the start point also matches
an user provided 'conditional color'.

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR><TD WIDTH=100% ALIGN=justify>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert disks.gif \
          -fill green -floodfill +10+40 white \
          -fill blue  -floodfill +30+50 white \
          cond_dilate_floodfill.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="cond_dilate_floodfill.gif"
     ><IMG SRC="cond_dilate_floodfill.gif"    WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

In this case the 'green' floodfill 'hit a disk' (and filled it), while the
'blue' flood fill operation, did not match, so no disk was filled. </P>

The problem with such 'flood-fill' methods is that you can only dilate from
a single user provided point.  It is however very fast, and works on the image
as a whole. </P>

Repeated or iterated <A HREF="index.html#dilate" >Dilate</A> is the same as floodfill
but can have multiple starting points, but has no understanding of limits or
bounds to the fill operation it provides. To limit its effects we need to
provide not only the 'starting points' but also the 'conditional bounds' of
the fill. </P>

To do this we create a <A HREF="../masking/index.html#write_mask" >Write Protect Mask</A>
(what parts of the image which are write protected).

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert disks.gif disks.gif -morphology Erode:7 Diamond disks_big_center.gif

  convert disks.gif -negate  disks_mask.gif

  convert disks_big_center.gif  -mask disks_mask.gif \
          -morphology Dilate:15 Diamond    +mask disks_big_found.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="../images/disks.gif"
     ><IMG SRC="../images/disks.gif"    WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="disks_big_center.gif"
     ><IMG SRC="disks_big_center.gif"    WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/plus.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT=" + ">
  <A HREF="disks_mask.gif"
     ><IMG SRC="disks_mask.gif"    WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="disks_big_found.gif"
     ><IMG SRC="disks_big_found.gif"    WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

In the above we first used a <A HREF="index.html#erode" >Erode Method</A> to locate any
disk that is larger than a radius of 7  (diameter 7x2+1 => 15 pixels).  We
then 'Conditionally Dilate' the discovered points by the same amount so as to
'perfectly' restore the object found. </P>

Note that 'Conditional Dilatation' is very different to using an <A
HREF="index.html#open" >Open Method</A> for object restoration.  That method would have
generated the internal 'diamond' shape of the kernel, rather that the exact
shape of the original object. It also will not handle 'odd shaped' or 'off
centered' seed points. </P>

The iteration number '<CODE>15</CODE>' is not critical, but should be large
enough to completely restore the object. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/reminder.gif" WIDTH=20 HEIGHT=16
    ><IMG SRC="../img_www/space.gif"   WIDTH=20 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  Remember it is better to use a small kernel, such as a <A HREF="index.html#diamond"
  >Diamond</A> or <A HREF="index.html#square" >Square</A> with a <A HREF="index.html#iteration"
  >Iteration Count</A> when performing <A HREF="index.html#basic" >Basic Morphology
  Operations</A> than using a much larger kernel, such as a <A HREF="index.html#disk"
  >Disk</A> with a large radius. </P>

  This becomes especially important when doing a <A HREF="index.html#dilate_conditional"
  >Conditional Dialation</A>, as large kernels could in effect 'jump' over
  gaps that separate multiple objects. </P>

</I></FONT></TD></TR></TABLE></P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/warning.gif"  WIDTH=28 HEIGHT=28
    ><IMG SRC="../img_www/space.gif"   WIDTH=12 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  Do not use a '<CODE>-1</CODE>' or (near) infinite iteration count with
  a write mask.  IMv6 Morphology currently will not realize that pixels are
  un-writable, and as such will not abort when it sees no more changes to the
  image, as it always sees changes, (which never gets written) around the
  edges of the shape. </P>

  This will be fixed with IMv7, which provided a major internal re-structure
  that will let the operator be a little smarter with regards to write
  protected pixels. </P>
</I></FONT></TD></TR></TABLE></P>

Here is another example of the versitility of using a <A
HREF="../masking/index.html#write_mask" >Write Protect Mask</A>.  Find the disks will be
hit by a diagonal line across the image.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert -size 80x80 xc:black -fill white \
                        -draw 'line 0,0 79,79'   disks_line.gif

  convert disks_line.gif disks.gif \
          -compose Multiply  -composite    disks_line_find.gif

  convert disks_line_find.gif  -mask disks_mask.gif \
          -morphology Dilate:15 Diamond    +mask disks_line_found.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="../images/disks.gif"
     ><IMG SRC="../images/disks.gif"    WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/plus.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT=" + ">
  <A HREF="disks_line.gif"
     ><IMG SRC="disks_line.gif"    WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="disks_line_find.gif"
     ><IMG SRC="disks_line_find.gif"    WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/plus.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT=" + ">
  <A HREF="disks_mask.gif"
     ><IMG SRC="disks_mask.gif"    WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="disks_line_found.gif"
     ><IMG SRC="disks_line_found.gif"    WIDTH=80 HEIGHT=80
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

Note the extra masking step (using a <A HREF="../compose/index.html#multiply" >Multiply
Composition</A>), ensures that only objects the line actually goes
<I>though</I> will be 'found'.  Without this step, objects that is also close
to the line, that is within the kernel radius of the 'seed points' (just
touching in the above), would also be 'dilated'. </P>

Of course if you are wanting to include 'near objects' then by all means
dilate the line (making it wider) with a disk kernel of the appropriate
radius, before doing the initial masking step. that will give you more 'near'
control than relying on the square kernel radius. </P>

In summery a <A HREF="index.html#dilate_conditional" >Conditional Dialation</A> could be
regarded as a multi-point <A HREF="../color_basics/index.html#floodfill_draw" >Draw
Flood-Fill</A>, that while slower, can be more versitle in selecting exactly
what should be filled, or 'discovered'. </P>


<A NAME="distance_constrainted"></A>
<H3>Constrained Distance</H3>

The <A HREF="index.html#distance" >Distance</A> morphology method can be easily used to
find how far a point within an object is from an edge.  But it can also be
used to find how distant each point within the object is from another point.
</P>

For example here I discover how far each point is from a single 'seed' point
(as the crow flys)...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
<c>  convert -size 100x100 xc: -draw 'point 20,80'  distance_start.png

  convert distance_start.png -morphology Distance Euclidean \
          -auto-level  distance_point.png

  convert -font Casual -pointsize 140 label:D \
          -trim +repage -gravity center -extent 100x100 \
          -threshold 20% distance_bounds.png

  convert distance_point.png \( distance_bounds.png -negate \)  \
          -compose multiply -composite  -auto-level distance_direct.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="distance_start.png"
     ><IMG SRC="distance_start.png"    WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="distance_point.png"
     ><IMG SRC="distance_point.png"    WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/plus.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="distance_bounds.png"
     ><IMG SRC="distance_bounds.png"    WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="distance_direct.png"
     ><IMG SRC="distance_direct.png"    WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

The distance from a point is masked by the shape of the object as these are
the only points we are interested in.  </P>

The problem is that distance gradient above represents a 'as the crow flys' or
direct distance to the 'starting point'.  Simply masking that gradient by the
object does not change that.  Unfortunatally this is typically not what an
user wants in the way of a "distance from the start point".  If the shape
represented an island, you would get quite wet if you wanted to take the
'direct route' from one end of this island to the other. </P>

<A NAME="iterative_distance"></A>

What you really want is the distance that is limited to paths '<I>with-in the
object</I>'.  That is you want the distance to be 'constrained' by the
object itself, and follows the smallest path possible, inside the object.</P>

To do this we can set up a <A HREF="http://legacy.imagemagick.org/Usage/maskng/#write_mask" >Write Protect
Mask</A> so that as the distance gradient is calculated it does not cross
(write to) the 'no go' areas or background of the image.

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=80% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert distance_start.png  -mask distance_bounds.png \
          -morphology IterativeDistance:150 Euclidean \
          +mask -fill black -opaque white -auto-level \
          distance_constrained.png
</CODE></PRE></TD></TR></TABLE>
  <A HREF="distance_start.png"
     ><IMG SRC="distance_start.png"    WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/plus.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="distance_bounds.png"
     ><IMG SRC="distance_bounds.png"    WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="distance_constrained.png"
     ><IMG SRC="distance_constrained.png"    WIDTH=100 HEIGHT=100
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</DIV></P>

The result as you can see is a correct 'distance across image' gradient,
that clearly shows the largest distance (white) from the starting point is the
other end of the island that is just a 'stones throw' across the gap in the
object. </P>

<BR>

Note that I did not simply use a normal <A HREF="index.html#distance" >Distance
Method</A> but a lower level '<CODE>Iterative_Distance</CODE>' morphology
method. </P>

The normal <A HREF="index.html#distance" >Distance Method</A> is a special 2-pass FAST
distance method that is applied to the image as a whole.  Because of this the
write mask will not restrict its actions along a 'row' of pixels, and as such
the write mask will have little effect.  The result is that
'<CODE>Distance</CODE>' will have a tendency to 'jump' over horizontal gaps,
regardless of the write mask.  That is the normal <A HREF="index.html#distance"
>Distance Method</A> is not properly 'constrained'. </P>

The '<CODE>Iterative_Distance</CODE>' method however works more like a simpler
<A HREF="index.html#basic" >Basic Morphology Method</A> and is only applied
incrementally to the local neighbourhood.  It is actually more like a gradient
form of 'dilate', and is in fact closely related to a <A HREF="index.html#greyscale"
>True Gray-scale Morphology</A> method.  As it processes the image in smaller
'incremental steps' the '<CODE>Iterative_Distance</CODE>' method will be
'constrained' by the write mask.  </P>

Unfortunatally it is much also much slower.  Instead of 2 passes though the
image, the above performs 150 passes, as given by the <A HREF="index.html#iteration"
>Iteration Count</A> to the morphology method.  It is best to try and keep
this iterative count as small as possible, but large enough to cover the
largest distance that will be found within the image. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=90% ALIGN=center>
<TR VALIGN=top>
<TD><IMG SRC="../img_www/warning.gif"  WIDTH=28 HEIGHT=28
    ><IMG SRC="../img_www/space.gif"   WIDTH=12 HEIGHT=16></TD>
<TD ALIGN=justify WIDTH=100%><FONT SIZE=-1><I>
  Do not use a '<CODE>-1</CODE>' or (near) infinite iteration count with
  a write mask.  IMv6 Morphology does not understand that some pixels are
  un-writable, as as such will not abort when it sees no more changes to the
  image, as it always sees changes to 'un-writable pixels' around the edges of
  the shape. </P>

  This will hopefully be fixed with IMv7, which provides a major internal
  re-structure that will let the operator be a little smarter, by
  understanding that some pixels are not writable, and thus avoid calculating,
  or counting them as having been 'changed'. </P>

</I></FONT></TD></TR></TABLE></P>

Finally you will notice that I used a <A HREF="index.html#distance_kernels" >Distance
Kernel</A> that only has a radius of 1, even though such kernels are not as
accurate.  This is important as a larger kernel could result in the distance
gradient jumping across any gap that is smaller than its radius. See <A
HREF="http://legacy.imagemagick.org/Usage/morphology/dilate_conditional" >Conditional Dilate</A> above. </P>

If more accuracy is needed, then you will need to ensure that their is no gaps
that is smaller than the <A HREF="index.html#distance_kernels" >Distance Kernel</A> you
want to use.  That includes gaps due to a sharp bend in the image edge. </P>

<BR>
<HR><!-- ---------------------------------------------------------------- -->

<A NAME="skeletons"></A>
<H2>Generating Skeletons of shapes.</H2>

<DIV ALIGN=center><FONT SIZE=+2><B>
<IMG SRC="../img_www/const_barrier.gif" WIDTH=39 HEIGHT=35 ALIGN=top>
Under Construction
<IMG SRC="../img_www/const_hole.gif" WIDTH=144 HEIGHT=50 ALIGN=middle>
</B></FONT></DIV></P>

<PRE>
From HIPR2 Morphology
http://homepages.inf.ed.ac.uk/rbf/HIPR2/morops.htm


The skeleton/MAT can be produced in two main ways. The first is to use some
kind of morphological thinning that successively erodes away pixels from the
boundary (while preserving the end points of line segments) until no more
thinning is possible, at which point what is left approximates the skeleton.

The alternative method is to first calculate the distance transform of the
image. The skeleton then lies along the singularities (i.e. creases or
curvature discontinuities) in the distance transform. This latter approach is
more suited to calculating the MAT since the MAT is the same as the distance
transform but with all points not part of the skeleton suppressed to zero.

Note: The MAT is often described as being the 'locus of local maxima' on the
distance transform. This is not really true in any normal sense of the phrase
'local maximum'. If the distance transform is displayed as a 3-D surface plot
with the third dimension representing the gray-value, the MAT can be imagined
as the ridges on the 3-D surface.



Definition??</P>

Morphological Skeleton (by erosion?), (by thinning)

Skeletons are calculated either by repeated thinning,  or by distance
transform, and finding the 'creases', or ridges on the 3d surface (watershed
transform?).

   mat.gif -morphology HMT Ridges           -threshold 0
   mat.gif -morphology HMT LineEnds         -threshold 0
   mat.gif -morphology HMT Ridges\;LineEnds -threshold 0

   mat.gif -morphology HMT Ridges\;Ridges2  -threshold 0

   mat.gif -morphology TopHat Diamond              -threshold 0

   mat.gif -define morphology:compose=Lighten \
              -morphology TopHat '3@:-,1,- -,1,- -,-,-' -threshold 0


One definition of medial axis transform (MAT) uses the intensity of each point
to represent the distance ot the boundary.  That the skeleton was used as
a mask for the distance transform. The distance transform method is more
suited to this, and it is probably faster to calculate than by thinning.

SKIZ (Skeleton by Influence Zones) is a skeleton of the background, the
negative of the operation.  That is dividing the regions closest to each
foreground object.  (generated by thickening)

Generally a SKIZ is pruned down to simple areas, or basins, by also eroding
end of line segments, unless they are attached to an image edge.

Identifying shape by their skeletons.
   distance between farthest 'end' points,
   number of 'loops' or regions in image,
   number of triple points.


</PRE>

<A NAME="distance_skeleton"></A>
<H3>Distance to Skeleton</H3>

One quick and dirty way to generate a raw 'morphological skeleton' from an
image is by applying the '<CODE><A HREF="index.html#tophat" >TopHat</A></CODE>' method
to the distance gradient. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

For example, here is a skeleton of the shape after it is been <A HREF="index.html#open"
>Opened</A> a little to smooth its outline a bit.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert man.gif \
          -morphology Open  Diamond \
          -morphology Distance  Chebyshev \
          -morphology TopHat Diamond \
          -auto-level    chebyshev_dist_skel.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="chebyshev_dist_skel.gif"
     ><IMG SRC="chebyshev_dist_skel.gif"      WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

This is basically a morphological skeleton.  It only shows the pixels where
a maximal 'square' (more commonly known as a 'Maximal Ball') could be found,
which is why it looks incomplete. However it is still a very raw result with
many isolated pixels.  Amazingly it does work.  </P>

Without the '<CODE><A HREF="index.html#open" >Open</A></CODE>' the result is very bad,
due to the shape having such a rough outline. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

Using an Euclidean distance measure produces a better skeleton of the shape.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert man.gif \
          -morphology Open  Diamond \
          -morphology Distance Euclidean:4 \
          -morphology TopHat Diamond \
          -auto-level    euclidean_dist_skel.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="euclidean_dist_skel.gif"
     ><IMG SRC="euclidean_dist_skel.gif"      WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

But as you can see you also get more noise and the skeleton while more
complete is also very dirty with many gray-scale values. </P>

<TABLE BORDER=0 CELLSPACING=0 CELLPADDING=0 WIDTH=100%>
<TR VALIGN=bottom><TD WIDTH=100% ALIGN=justify>

Here is an enlargement of the 'head' of the skeleton, showing how it
remains disjointed.

<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert euclidean_dist_skel.gif -crop 35x28+30+13 +repage \
          -scale 400%   euclidean_dist_skel_mag.gif
</CODE></PRE></TD></TR></TABLE></TD><TD>
  <A HREF="euclidean_dist_skel_mag.gif"
     ><IMG SRC="euclidean_dist_skel_mag.gif"      WIDTH=140 HEIGHT=112
           ALIGN=middle VSPACE=0 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
</TD></TR></TABLE></P>

Of course the above could be thresholded and used as a mask with the actual
distance gradient that was used to generate it.  This will allow you to look
up the actual size (distance radius) of the maximal disks that makes up the
skeleton, letting you re-create the original shape.  </P>

<A NAME="autotrace_skeleton"></A>
<H3>Skeleton using Autotrace</H3>

Another alternative to skeleton generation, is to use the "<CODE><A
HREF="http://autotrace.sourceforge.net/" >AutoTrace</A></CODE>" program and
its special centerline option.  Note that it assumes black on white for its
processing due to it involvement with printing and font conversion. </P>

For example...

<DIV ALIGN=center>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=5 WIDTH=100% BGCOLOR="#CCCCCC">
<TR><TD><PRE><CODE EXECUTE>
  convert man.gif -negate man_at_prep.pgm
  autotrace -centerline -output-format svg man_at_prep.pgm |\
      convert SVG:-  man_centerline.gif
  convert man.gif man_centerline.gif \
          -compose multiply -composite man_at_skeleton.gif
</CODE></PRE></TD></TR></TABLE>
  <A HREF="man.gif"
     ><IMG SRC="man.gif"      WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="man_at_prep.png"
     ><IMG SRC="man_at_prep.png"      WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="man_centerline.gif"
     ><IMG SRC="man_centerline.gif"      WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>
<IMG SRC="../img_www/right.gif" ALIGN=middle WIDTH=20 HEIGHT=20 ALT="==>">
  <A HREF="man_at_skeleton.gif"
     ><IMG SRC="man_at_skeleton.gif"      WIDTH=100 HEIGHT=125
           ALIGN=middle VSPACE=5 HSPACE=5 BORDER=1 ALT="[IM Output]"></A>

</DIV></P>

Note that the centerline generated is in the form of a smooth curve due to the
vector nature of the process.  It is also disconnected, with gaps in skeleton
loops, and disconnected branches.  However I have not looked at how
"autotrace" actually generates this skeleton. </P>

For other example of using "<CODE><A HREF="http://autotrace.sourceforge.net/"
>AutoTrace</A></CODE>", see <A HREF="../draw/index.html#svg_output" >SVG Output
Handling</A>, and <A HREF="http://legacy.imagemagick.org/Usage/transform/#edge_vector" >Raster to Vector
Edging</A>.  </P>


<BR>
<HR><!-- ---------------------------------------------------------------- -->
<ADDRESS>
Created: 4 January 2010 <BR>
Updated: 15 Feburary 2013 <BR>
Author: <A HREF="https://antofthy.gitlab.io/anthony.html"
        >Anthony Thyssen</A>, &lt;Anthony.Thyssen&#64;gmail.com&gt;<BR>
Major Input:
        <A HREF="http://www.fmwconcepts.com/fmw/fmw.html" >Fred Weinhaus</A>,
        &lt;fmw at alink.net&gt;<BR>
Examples Generated with:
        <IMG SRC="version.gif" ALIGN=absmiddle ALT="[version image]"><BR>
URL: <CODE>https://legacy.imagemagick.org/Usage/morphology/</CODE>
</ADDRESS></BODY></HTML>
